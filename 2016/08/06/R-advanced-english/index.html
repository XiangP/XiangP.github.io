<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Xiang"><meta name="description" content="Sourceoninternet.hadley."><meta name="keywords" content=""><title>R advanced(english edition) Â· Eric</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="http://yoursite.com/2016/08/06/R-advanced-english/"><link rel="alternate" href="/atom.xml" title="Eric"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Eric</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/categories/" target="_self">Categories</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">R advanced(english edition)</h1><span class="post-time">Aug 6, 2016</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Contents</h3><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Welcome"><span class="toc-text">Welcome</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-text">Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Who-should-read-this-book"><span class="toc-text">Who should read this book</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What-you-will-get-out-of-this-book"><span class="toc-text">What you will get out of this book</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Meta-techniques"><span class="toc-text">Meta-techniques</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Recommended-reading"><span class="toc-text">Recommended reading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Getting-help"><span class="toc-text">Getting help</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Acknowledgments"><span class="toc-text">Acknowledgments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conventions"><span class="toc-text">Conventions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Colophon"><span class="toc-text">Colophon</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Data-structures"><span class="toc-text">Data structures</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Quiz"><span class="toc-text">Quiz</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline"><span class="toc-text">Outline</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vectors"><span class="toc-text">Vectors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic-vectors"><span class="toc-text">Atomic vectors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Types-and-tests"><span class="toc-text">Types and tests</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Coercion"><span class="toc-text">Coercion</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lists"><span class="toc-text">Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Attributes"><span class="toc-text">Attributes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Names"><span class="toc-text">Names</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Factors"><span class="toc-text">Factors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-1"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Matrices-and-arrays"><span class="toc-text">Matrices and arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-2"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-frames"><span class="toc-text">Data frames</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Creation"><span class="toc-text">Creation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Testing-and-coercion"><span class="toc-text">Testing and coercion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Combining-data-frames"><span class="toc-text">Combining data frames</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Special-columns"><span class="toc-text">Special columns</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-3"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answers"><span class="toc-text">Answers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Subsetting"><span class="toc-text">Subsetting</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Quiz-1"><span class="toc-text">Quiz</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-1"><span class="toc-text">Outline</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-types"><span class="toc-text">Data types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic-vectors-1"><span class="toc-text">Atomic vectors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lists-1"><span class="toc-text">Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Matrices-and-arrays-1"><span class="toc-text">Matrices and arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-frames-1"><span class="toc-text">Data frames</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#S3-objects"><span class="toc-text">S3 objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#S4-objects"><span class="toc-text">S4 objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-4"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Subsetting-operators"><span class="toc-text">Subsetting operators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Simplifying-vs-preserving-subsetting"><span class="toc-text">Simplifying vs. preserving subsetting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#"><span class="toc-text">$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Missing-out-of-bounds-indices"><span class="toc-text">Missing/out of bounds indices</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-5"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Subsetting-and-assignment"><span class="toc-text">Subsetting and assignment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Applications"><span class="toc-text">Applications</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lookup-tables"><span class="toc-text">Lookup tables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Matching-and-merging-by-hand-integer-subsetting"><span class="toc-text">Matching and merging by hand(integer subsetting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Random-samples-bootstrap-integer-subsetting"><span class="toc-text">Random samples/bootstrap (integer subsetting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ordering-integer-subsetting"><span class="toc-text">Ordering (integer subsetting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Expanding-aggregated-counts-integer-subsetting"><span class="toc-text">Expanding aggregated counts (integer subsetting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Removing-columns-from-data-frames-character-subsetting"><span class="toc-text">Removing columns from data frames (character subsetting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selecting-rows-based-on-a-condition-logical-subsetting"><span class="toc-text">Selecting rows based on a condition (logical subsetting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean-algebra-vs-sets-logical-amp-integer-subsetting"><span class="toc-text">Boolean algebra vs. sets (logical & integer subsetting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-6"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answers-1"><span class="toc-text">Answers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vocabulary"><span class="toc-text">Vocabulary</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#The-basics"><span class="toc-text">The basics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Common-data-structures"><span class="toc-text">Common data structures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Statistics"><span class="toc-text">Statistics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Working-with-R"><span class="toc-text">Working with R</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O"><span class="toc-text">I/O</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Style-guide"><span class="toc-text">Style guide</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Notation-and-naming"><span class="toc-text">Notation and naming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#File-names"><span class="toc-text">File names</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-names"><span class="toc-text">Object names</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Syntax"><span class="toc-text">Syntax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spacing"><span class="toc-text">Spacing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Curly-braces"><span class="toc-text">Curly braces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Line-length"><span class="toc-text">Line length</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Indentation"><span class="toc-text">Indentation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Assignment"><span class="toc-text">Assignment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Organisation"><span class="toc-text">Organisation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Commenting-guidelines"><span class="toc-text">Commenting guidelines</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Functions"><span class="toc-text">Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Quiz-2"><span class="toc-text">Quiz</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-2"><span class="toc-text">Outline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites"><span class="toc-text">Prerequisites</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-components"><span class="toc-text">Function components</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Primitive-functions"><span class="toc-text">Primitive functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-7"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lexical-scoping"><span class="toc-text">Lexical scoping</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Name-masking"><span class="toc-text">Name masking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Functions-vs-variables"><span class="toc-text">Functions vs. variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-fresh-start"><span class="toc-text">A fresh start</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic-lookup"><span class="toc-text">Dynamic lookup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-8"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Every-operation-is-a-function-call"><span class="toc-text">Every operation is a function call</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-arguments"><span class="toc-text">Function arguments</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Calling-functions"><span class="toc-text">Calling functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calling-a-function-given-a-list-of-arguments"><span class="toc-text">Calling a function given a list of arguments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Default-and-missing-arguments"><span class="toc-text">Default and missing arguments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lazy-evaluation"><span class="toc-text">Lazy evaluation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-text">...</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-9"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Special-calls"><span class="toc-text">Special calls</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Infix-functions"><span class="toc-text">Infix functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Replacement-functions"><span class="toc-text">Replacement functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-10"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Return-values"><span class="toc-text">Return values</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#On-exit"><span class="toc-text">On exit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-11"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quiz-answers"><span class="toc-text">Quiz answers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OO-field-guide"><span class="toc-text">OO field guide</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites-1"><span class="toc-text">Prerequisites</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Quiz-3"><span class="toc-text">Quiz</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-3"><span class="toc-text">Outline</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Base-types"><span class="toc-text">Base types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#S3"><span class="toc-text">S3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Recognising-objects-generic-functions-and-methods"><span class="toc-text">Recognising objects, generic functions, and methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-classes-and-creating-objects"><span class="toc-text">Defining classes and creating objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Creating-new-methods-and-generics"><span class="toc-text">Creating new methods and generics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-dispatch"><span class="toc-text">Method dispatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-12"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#S4"><span class="toc-text">S4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Recognising-objects-generic-functions-and-methods-1"><span class="toc-text">Recognising objects, generic functions, and methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-classes-and-creating-objects-1"><span class="toc-text">Defining classes and creating objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Creating-new-methods-and-generics-1"><span class="toc-text">Creating new methods and generics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-dispatch-1"><span class="toc-text">Method dispatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-13"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RC"><span class="toc-text">RC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-classes-and-creating-objects-2"><span class="toc-text">Defining classes and creating objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recognising-objects-and-methods"><span class="toc-text">Recognising objects and methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-dispatch-2"><span class="toc-text">Method dispatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-14"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Picking-a-system"><span class="toc-text">Picking a system</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quiz-answers-1"><span class="toc-text">Quiz answers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Environments"><span class="toc-text">Environments</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Quiz-4"><span class="toc-text">Quiz</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-4"><span class="toc-text">Outline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites-2"><span class="toc-text">Prerequisites</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Environment-basics"><span class="toc-text">Environment basics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-15"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Recursing-over-environments"><span class="toc-text">Recursing over environments</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-16"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-environments"><span class="toc-text">Function environments</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-enclosing-environment"><span class="toc-text">The enclosing environment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binding-environments"><span class="toc-text">Binding environments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Execution-environments"><span class="toc-text">Execution environments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calling-environments"><span class="toc-text">Calling environments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-17"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binding-names-to-values"><span class="toc-text">Binding names to values</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-18"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Explicit-environments"><span class="toc-text">Explicit environments</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Avoiding-copies"><span class="toc-text">Avoiding copies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Package-state"><span class="toc-text">Package state</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#As-a-hashmap"><span class="toc-text">As a hashmap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quiz-answers-2"><span class="toc-text">Quiz answers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Debugging-condition-handling-and-defensive-programming"><span class="toc-text">Debugging, condition handling, and defensive programming</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Prototype-of-a-Condition-System-for-R"><span class="toc-text">A Prototype of a Condition System for R</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction-1"><span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interface"><span class="toc-text">Interface</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exiting-Handlers"><span class="toc-text">Exiting Handlers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calling-Handlers"><span class="toc-text">Calling Handlers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Recovery-Mechanisms"><span class="toc-text">Recovery Mechanisms</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Some-Issues"><span class="toc-text">Some Issues</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Minor-Issues"><span class="toc-text">Minor Issues</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#How-To-Integrate-The-restart-Function"><span class="toc-text">How To Integrate The restart Function</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation"><span class="toc-text">Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Call-With-Current-Continuation"><span class="toc-text">Call With Current Continuation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Handler-Stack-Management"><span class="toc-text">Handler Stack Management</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Handling-Conditions"><span class="toc-text">Handling Conditions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Signaling-Conditions"><span class="toc-text">Signaling Conditions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Establishing-Handlers"><span class="toc-text">Establishing Handlers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition-Objects"><span class="toc-text">Condition Objects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Default-Handlers"><span class="toc-text">Default Handlers</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Default-Handler-For-Exceptions"><span class="toc-text">Default Handler For Exceptions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Default-Handler-For-Warnigs"><span class="toc-text">Default Handler For Warnigs</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Internal-Error-Conversion"><span class="toc-text">Internal Error Conversion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resets"><span class="toc-text">Resets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tests"><span class="toc-text">Tests</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dylan-Condition-Handling"><span class="toc-text">Dylan Condition Handling</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Beyond-Exception-Handling-Conditions-and-Restarts"><span class="toc-text">Beyond Exception Handling: Conditions and Restarts</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#The-R-Way"><span class="toc-text">The R Way</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conditions"><span class="toc-text">Conditions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Condition-Handlers"><span class="toc-text">Condition Handlers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-style-exception-handling"><span class="toc-text">Java style exception handling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Restarts"><span class="toc-text">Restarts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Providing-Multiple-Restarts"><span class="toc-text">Providing Multiple Restarts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Other-Uses-for-Conditions"><span class="toc-text">Other Uses for Conditions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Writing-Robust-Software"><span class="toc-text">Writing Robust Software</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Quiz-5"><span class="toc-text">Quiz</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-5"><span class="toc-text">Outline</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debugging-techniques"><span class="toc-text">Debugging techniques</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debugging-tools"><span class="toc-text">Debugging tools</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Determining-the-sequence-of-calls"><span class="toc-text">Determining the sequence of calls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Browsing-on-error"><span class="toc-text">Browsing on error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Browsing-arbitrary-code"><span class="toc-text">Browsing arbitrary code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-call-stack-traceback-where-and-recover"><span class="toc-text">The call stack: traceback(), where, and recover()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Other-types-of-failure"><span class="toc-text">Other types of failure</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Condition-handling"><span class="toc-text">Condition handling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ignore-errors-with-try"><span class="toc-text">Ignore errors with try</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handle-conditions-with-tryCatch"><span class="toc-text">Handle conditions with tryCatch()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#withCallingHandlers"><span class="toc-text">withCallingHandlers()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Custom-signal-classes"><span class="toc-text">Custom signal classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-19"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Defensive-programming"><span class="toc-text">Defensive programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-20"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quiz-answers-3"><span class="toc-text">Quiz answers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Functional-programming"><span class="toc-text">Functional programming</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-6"><span class="toc-text">Outline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prequisites"><span class="toc-text">Prequisites</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Motivation"><span class="toc-text">Motivation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Anonymous-functions"><span class="toc-text">Anonymous functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-21"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Closures"><span class="toc-text">Closures</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Function-factories"><span class="toc-text">Function factories</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutable-state"><span class="toc-text">Mutable state</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-22"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lists-of-functions"><span class="toc-text">Lists of functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Moving-lists-of-functions-to-the-global-environment"><span class="toc-text">Moving lists of functions to the global environment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-23"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Case-study-numerical-integration"><span class="toc-text">Case study: numerical integration</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-24"><span class="toc-text">Exercises</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Functionals"><span class="toc-text">Functionals</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-7"><span class="toc-text">Outline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites-3"><span class="toc-text">Prerequisites</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#My-first-functional-lapply"><span class="toc-text">My first functional: lapply()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Looping-patterns"><span class="toc-text">Looping patterns</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-25"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#For-loop-functionals-friends-of-lapply"><span class="toc-text">For loop functionals: friends of lapply()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-output-sapply-and-vapply"><span class="toc-text">Vector output: sapply and vapply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multiple-inputs-Map-and-mapply"><span class="toc-text">Multiple inputs: Map (and mapply)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rolling-computations"><span class="toc-text">Rolling computations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallelisation"><span class="toc-text">Parallelisation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-26"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manipulating-matrices-and-data-frames"><span class="toc-text">Manipulating matrices and data frames</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Matrix-and-array-operations"><span class="toc-text">Matrix and array operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Group-apply"><span class="toc-text">Group apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-plyr-package"><span class="toc-text">The plyr package</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-27"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manipulating-lists"><span class="toc-text">Manipulating lists</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reduce"><span class="toc-text">Reduce()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicate-functionals"><span class="toc-text">Predicate functionals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-28"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mathematical-functionals"><span class="toc-text">Mathematical functionals</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-29"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loops-that-should-be-left-as-is"><span class="toc-text">Loops that should be left as is</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifying-in-place"><span class="toc-text">Modifying in place</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recursive-relationships"><span class="toc-text">Recursive relationships</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#While-loops"><span class="toc-text">While loops</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-family-of-functions"><span class="toc-text">A family of functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-30"><span class="toc-text">Exercises</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Function-operators"><span class="toc-text">Function operators</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-8"><span class="toc-text">Outline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites-4"><span class="toc-text">Prerequisites</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Behavioural-FOs"><span class="toc-text">Behavioural FOs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memoisation"><span class="toc-text">Memoisation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Capturing-function-invocations"><span class="toc-text">Capturing function invocations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Laziness"><span class="toc-text">Laziness</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-31"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Output-FOs"><span class="toc-text">Output FOs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-modifications"><span class="toc-text">Minor modifications</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Changing-what-a-function-does"><span class="toc-text">Changing what a function does</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-32"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Input-FOs"><span class="toc-text">Input FOs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prefilling-function-arguments-partial-function-application"><span class="toc-text">Prefilling function arguments: partial function application</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Changing-input-types"><span class="toc-text">Changing input types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-33"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Combining-FOs"><span class="toc-text">Combining FOs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Function-composition"><span class="toc-text">Function composition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logical-predicates-and-boolean-algebra"><span class="toc-text">Logical predicates and boolean algebra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-34"><span class="toc-text">Exercises</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Non-standard-evaluation"><span class="toc-text">Non-standard evaluation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-9"><span class="toc-text">Outline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites-5"><span class="toc-text">Prerequisites</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Capturing-expressions"><span class="toc-text">Capturing expressions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-35"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Non-standard-evaluation-in-subset"><span class="toc-text">Non-standard evaluation in subset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-36"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scoping-issues"><span class="toc-text">Scoping issues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-37"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Calling-from-another-function"><span class="toc-text">Calling from another function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-38"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Substitute"><span class="toc-text">Substitute</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Adding-an-escape-hatch-to-substitute"><span class="toc-text">Adding an escape hatch to substitute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Capturing-unevaluated-â¦"><span class="toc-text">Capturing unevaluated â¦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-39"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-downsides-of-non-standard-evaluation"><span class="toc-text">The downsides of non-standard evaluation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Formulas"><span class="toc-text">Formulas</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Formula-as-a-quoting-function"><span class="toc-text">Formula as a quoting function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xtabs"><span class="toc-text">xtabs()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Formulas-for-modelling"><span class="toc-text">Formulas for modelling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-40"><span class="toc-text">Exercises</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Expressions"><span class="toc-text">Expressions</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-10"><span class="toc-text">Outline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites-6"><span class="toc-text">Prerequisites</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Structure-of-expressions"><span class="toc-text">Structure of expressions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-41"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Names-1"><span class="toc-text">Names</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-42"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Calls"><span class="toc-text">Calls</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifying-a-call"><span class="toc-text">Modifying a call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Creating-a-call-from-its-components"><span class="toc-text">Creating a call from its components</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-43"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Capturing-the-current-call"><span class="toc-text">Capturing the current call</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-44"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pairlists"><span class="toc-text">Pairlists</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-45"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parsing-and-deparsing"><span class="toc-text">Parsing and deparsing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-46"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Walking-the-AST-with-recursive-functions"><span class="toc-text">Walking the AST with recursive functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Finding-F-and-T"><span class="toc-text">Finding F and T</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Finding-all-variables-created-by-assignment"><span class="toc-text">Finding all variables created by assignment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifying-the-call-tree"><span class="toc-text">Modifying the call tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-47"><span class="toc-text">Exercises</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Domain-specific-languages"><span class="toc-text">Domain specific languages</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites-7"><span class="toc-text">Prerequisites</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML"><span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Goal"><span class="toc-text">Goal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Escaping"><span class="toc-text">Escaping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-tag-functions"><span class="toc-text">Basic tag functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tag-functions"><span class="toc-text">Tag functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Processing-all-tags"><span class="toc-text">Processing all tags</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-48"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LaTeX"><span class="toc-text">LaTeX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LaTeX-mathematics"><span class="toc-text">LaTeX mathematics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Goal-1"><span class="toc-text">Goal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#to-math"><span class="toc-text">to_math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Known-symbols"><span class="toc-text">Known symbols</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unknown-symbols"><span class="toc-text">Unknown symbols</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Known-functions"><span class="toc-text">Known functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unknown-functions"><span class="toc-text">Unknown functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-49"><span class="toc-text">Exercises</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Performance"><span class="toc-text">Performance</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-is-R-slow"><span class="toc-text">Why is R slow?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Microbenchmarking"><span class="toc-text">Microbenchmarking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-50"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Language-performance"><span class="toc-text">Language performance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Extreme-dynamism"><span class="toc-text">Extreme dynamism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Name-lookup-with-mutable-environments"><span class="toc-text">Name lookup with mutable environments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lazy-evaluation-overhead"><span class="toc-text">Lazy evaluation overhead</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-51"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementation-performance"><span class="toc-text">Implementation performance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Extracting-a-single-value-from-a-data-frame"><span class="toc-text">Extracting a single value from a data frame</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifelse-pmin-and-pmax"><span class="toc-text">ifelse(), pmin(), and pmax()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-52"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Alternative-R-implementations"><span class="toc-text">Alternative R implementations</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Optimising-code"><span class="toc-text">Optimising code</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-11"><span class="toc-text">Outline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites-8"><span class="toc-text">Prerequisites</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Measuring-performance"><span class="toc-text">Measuring performance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Limitations"><span class="toc-text">Limitations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Improving-performance"><span class="toc-text">Improving performance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-organisation"><span class="toc-text">Code organisation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Has-someone-already-solved-the-problem"><span class="toc-text">Has someone already solved the problem?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-53"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Do-as-little-as-possible"><span class="toc-text">Do as little as possible</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-54"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vectorise"><span class="toc-text">Vectorise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-55"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Avoid-copies"><span class="toc-text">Avoid copies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Byte-code-compilation"><span class="toc-text">Byte code compilation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Case-study-t-test"><span class="toc-text">Case study: t-test</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parallelise"><span class="toc-text">Parallelise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Other-techniques"><span class="toc-text">Other techniques</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Memory"><span class="toc-text">Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-12"><span class="toc-text">Outline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites-9"><span class="toc-text">Prerequisites</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sources"><span class="toc-text">Sources</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-size"><span class="toc-text">Object size</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-56"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-usage-and-garbage-collection"><span class="toc-text">Memory usage and garbage collection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-profiling-with-lineprof"><span class="toc-text">Memory profiling with lineprof</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-57"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Modification-in-place"><span class="toc-text">Modification in place</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Loops"><span class="toc-text">Loops</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-58"><span class="toc-text">Exercises</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#High-performance-functions-with-Rcpp"><span class="toc-text">High performance functions with Rcpp</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-13"><span class="toc-text">Outline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequistes"><span class="toc-text">Prerequistes</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Getting-started-with-C"><span class="toc-text">Getting started with C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#No-inputs-scalar-output"><span class="toc-text">No inputs, scalar output</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scalar-input-scalar-output"><span class="toc-text">Scalar input, scalar output</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-input-scalar-output"><span class="toc-text">Vector input, scalar output</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-input-vector-output"><span class="toc-text">Vector input, vector output</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Matrix-input-vector-output"><span class="toc-text">Matrix input, vector output</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-sourceCpp"><span class="toc-text">Using sourceCpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-59"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Attributes-and-other-classes"><span class="toc-text">Attributes and other classes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lists-and-data-frames"><span class="toc-text">Lists and data frames</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Functions-1"><span class="toc-text">Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Other-types"><span class="toc-text">Other types</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Missing-values"><span class="toc-text">Missing values</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scalars"><span class="toc-text">Scalars</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Integers"><span class="toc-text">Integers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Doubles"><span class="toc-text">Doubles</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Strings"><span class="toc-text">Strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean"><span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vectors-1"><span class="toc-text">Vectors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-60"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rcpp-sugar"><span class="toc-text">Rcpp sugar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Arithmetic-and-logical-operators"><span class="toc-text">Arithmetic and logical operators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logical-summary-functions"><span class="toc-text">Logical summary functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-views"><span class="toc-text">Vector views</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Other-useful-functions"><span class="toc-text">Other useful functions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-STL"><span class="toc-text">The STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-iterators"><span class="toc-text">Using iterators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithms"><span class="toc-text">Algorithms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-structures-1"><span class="toc-text">Data structures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vectors-2"><span class="toc-text">Vectors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sets"><span class="toc-text">Sets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises-61"><span class="toc-text">Exercises</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Case-studies"><span class="toc-text">Case studies</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Gibbs-sampler"><span class="toc-text">Gibbs sampler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#R-vectorisation-vs-C-vectorisation"><span class="toc-text">R vectorisation vs. C++ vectorisation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Using-Rcpp-in-a-package"><span class="toc-text">Using Rcpp in a package</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Learning-more"><span class="toc-text">Learning more</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Acknowledgments-1"><span class="toc-text">Acknowledgments</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Râs-C-interface"><span class="toc-text">Râs C interface</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Outline-14"><span class="toc-text">Outline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites-10"><span class="toc-text">Prerequisites</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Calling-C-functions-from-R"><span class="toc-text">Calling C functions from R</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-data-structures"><span class="toc-text">C data structures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Creating-and-modifying-vectors"><span class="toc-text">Creating and modifying vectors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Creating-vectors-and-garbage-collection"><span class="toc-text">Creating vectors and garbage collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Missing-and-non-finite-values"><span class="toc-text">Missing and non-finite values</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Accessing-vector-data"><span class="toc-text">Accessing vector data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Character-vectors-and-lists"><span class="toc-text">Character vectors and lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifying-inputs"><span class="toc-text">Modifying inputs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coercing-scalars"><span class="toc-text">Coercing scalars</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Long-vectors"><span class="toc-text">Long vectors</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pairlists-1"><span class="toc-text">Pairlists</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Input-validation"><span class="toc-text">Input validation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finding-the-C-source-code-for-a-function"><span class="toc-text">Finding the C source code for a function</span></a></li></ol></li></ol></div><div class="post-content"><p>Source on internet. <a href="https://github.com/hadley/adv-r/" target="_blank" rel="external">hadley</a>. <a id="more"></a></p>
<p>[TOC]</p>
<hr>
<h1 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h1><p>This is the companion website for â<a href="http://amzn.com/1466586966?tag=devtools-20" target="_blank" rel="external">Advanced R</a>â, a book in Chapman &amp; Hallâs R Series. The book is designed primarily for R users who want to improve their programming skills and understanding of the language.  It should also be useful for programmers coming to R from other languages, as it explains some of Râs quirks and shows how some parts that seem horrible do have a positive side.</p>
<p>(You may also be interested in â<a href="http://r-pkgs.had.co.nz/" target="_blank" rel="external">R Packages</a>â, a similar book teaching you how to make the most of Râs fantastic package system.)</p>
<hr>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>With more than 10 years experience programming in R, Iâve had the luxury of being able to spend a lot of time trying to figure out and understand how the language works. This book is my attempt to pass on what Iâve learned so that you can quickly become an effective R programmer. Reading it will help you avoid the mistakes Iâve made and dead ends Iâve gone down, and will teach you useful tools, techniques, and idioms that can help you to attack many types of problems. In the process, I hope to show that, despite its frustrating quirks, R is, at its heart, an elegant and beautiful language, well tailored for data analysis and statistics.</p>
<p>If you are new to R, you might wonder what makes learning such a quirky language worthwhile. To me, some of the best features are:</p>
<ul>
<li>Itâs free, open source, and available on every major platform. As a result, if you do your analysis in R, anyone can easily replicate it.</li>
<li>A massive set of packages for statistical modelling, machine learning, visualisation, and importing and manipulating data. Whatever model or graphic youâre trying to do, chances are that someone has already tried to do it. At a minimum, you can learn from their efforts.</li>
<li>Cutting edge tools. Researchers in statistics and machine learning will often publish an R package to accompany their articles. This means immediate access to the very latest statistical techniques and implementations.</li>
<li>Deep-seated language support for data analysis. This includes features likes missing values, data frames, and subsetting.</li>
<li>A fantastic community. It is easy to get help from experts on the <a href="https://stat.ethz.ch/mailman/listinfo/r-help" target="_blank" rel="external">R-help mailing list</a>, <a href="http://stackoverflow.com/questions/tagged/r" target="_blank" rel="external">stackoverflow</a>, or subject-specific mailing lists like <a href="https://stat.ethz.ch/mailman/listinfo/r-sig-mixed-models" target="_blank" rel="external">R-SIG-mixed-models</a> or <a href="https://groups.google.com/forum/#!forum/ggplot2" target="_blank" rel="external">ggplot2</a>. You can also connect with other R learners via <a href="https://twitter.com/search?q=%23rstats" target="_blank" rel="external">twitter</a>, <a href="http://www.linkedin.com/groups/R-Project-Statistical-Computing-77616" target="_blank" rel="external">linkedin</a>, and through many local <a href="http://blog.revolutionanalytics.com/local-r-groups.html" target="_blank" rel="external">user groups</a>.</li>
<li>Powerful tools for communicating your results. R packages make it easy to produce html or pdf <a href="http://yihui.name/knitr/" target="_blank" rel="external">reports</a>, or create <a href="http://www.rstudio.com/shiny/" target="_blank" rel="external">interactive websites</a>.</li>
<li>A strong foundation in functional programming. The ideas of functional programming are well suited to solving many of the challenges of data analysis. R provides a powerful and flexible toolkit which allows you to write concise yet descriptive code.</li>
<li>An <a href="http://www.rstudio.com/ide/" target="_blank" rel="external">IDE</a> tailored to the needs of interactive data analysis and statistical programming.</li>
<li>Powerful metaprogramming facilities. R is not just a programming language, it is also an environment for interactive data analysis. Its metaprogramming capabilities allow you to write magically succinct and concise functions and provide an excellent environment for designing domain-specific languages.</li>
<li>Designed to connect to high-performance programming languages like C, Fortran, and C++.</li>
</ul>
<p>Of course, R is not perfect. Râs biggest challenge is that most R users are not programmers. This means that:</p>
<ul>
<li>Much of the R code youâll see in the wild is written in haste to solve a pressing problem. As a result, code is not very elegant, fast, or easy to understand. Most users do not revise their code to address these shortcomings.</li>
<li>Compared to other programming languages, the R community tends to be more focussed on results instead of processes. Knowledge of software engineering   best practices is patchy: for instance, not enough R programmers use source<br>code control or automated testing.</li>
<li>Metaprogramming is a double-edged sword. Too many R functions use   tricks to reduce the amount of typing at the cost of making code that   is hard to understand and that can fail in unexpected ways.</li>
<li>Inconsistency is rife across contributed packages, even within base R.  You are confronted with over 20 years of evolution every time you use R.  Learning R can be tough because there are many special cases to remember.</li>
<li>R is not a particularly fast programming language, and poorly written R code  can be terribly slow. R is also a profligate user of memory.</li>
</ul>
<p>Personally, I think these challenges create a great opportunity for experienced programmers to have a profound positive impact on R and the R community. R users do care about writing high quality code, particularly for reproducible research, but they donât yet have the skills to do so. I hope this book will not only help more R users to become R programmers but also encourage programmers from other languages to contribute to R.</p>
<h2 id="Who-should-read-this-book"><a href="#Who-should-read-this-book" class="headerlink" title="Who should read this book"></a><a href="id=&quot;who-should-read&quot;">Who should read this book</a></h2><p>This book is aimed at two complementary audiences:</p>
<ul>
<li><p>Intermediate R programmers who want to dive deeper into R and learn new<br>strategies for solving diverse problems.</p>
</li>
<li><p>Programmers from other languages who are learning R and want to understand<br>why R works the way it does.</p>
</li>
</ul>
<p>To get the most out of this book, youâll need to have written a decent amount of code in R or another programming language. You might not know all the details, but you should be familiar with how functions work in R and although you may currently struggle to use them effectively, you should be familiar with the apply family (like <code>apply()</code> and <code>lapply()</code>).</p>
<h2 id="What-you-will-get-out-of-this-book"><a href="#What-you-will-get-out-of-this-book" class="headerlink" title="What you will get out of this book"></a><a href="id=&quot;what-you-will-get&quot;">What you will get out of this book</a></h2><p>This book describes the skills I think an advanced R programmer should have: the ability to produce quality code that can be used in a wide variety of circumstances.</p>
<p>After reading this book, you will:</p>
<ul>
<li>Be familiar with the fundamentals of R. You will understand complex data types  and the best ways to perform operations on them. You will have a deep  understanding of how functions work, and be able to recognise and use the four<br>object systems in R.</li>
<li>Understand what functional programming means, and why it is a useful tool for  data analysis. Youâll be able to quickly learn how to use existing tools, and  have the knowledge to create your own functional tools when needed.</li>
<li>Appreciate the double-edged sword of metaprogramming. Youâll be able to  create functions that use non-standard evaluation in a principled way,  saving typing and creating elegant code to express important operations.  Youâll also understand the dangers of metaprogramming and why you should be  careful about its use.</li>
<li>Have a good intuition for which operations in R are slow or use a lot of  memory. Youâll know how to use profiling to pinpoint performance  bottlenecks, and youâll know enough C++ to convert slow R functions to<br>fast C++ equivalents.</li>
<li>Be comfortable reading and understanding the majority of R code.  Youâll recognise common idioms (even if you wouldnât use them yourself)  and be able to critique othersâ code.</li>
</ul>
<h2 id="Meta-techniques"><a href="#Meta-techniques" class="headerlink" title="Meta-techniques"></a><a href="id=&quot;meta-techniques&quot;">Meta-techniques</a></h2><p>There are two meta-techniques that are tremendously helpful for improving your skills as an R programmer: reading source code and adopting a scientific mindset.</p>
<p>Reading source code is important because it will help you write better code. A great place to start developing this skill is to look at the source code of the functions and packages you use most often. Youâll find things that are worth emulating in your own code and youâll develop a sense of taste for what makes good R code. You will also see things that you donât like, either because its virtues are not obvious or it offends your sensibilities. Such code is nonetheless valuable, because it helps make concrete your opinions on good and bad code.</p>
<p>A scientific mindset is extremely helpful when learning R. If you donât understand how something works, develop a hypothesis, design some experiments, run them, and record the results. This exercise is extremely useful since if you canât figure something out and need to get help, you can easily show others what you tried. Also, when you learn the right answer, youâll be mentally prepared to update your world view. When I clearly describe a problem to someone else (the art of creating a <a href="http://stackoverflow.com/questions/5963269" target="_blank" rel="external">reproducible example</a>), I often figure out the solution myself.</p>
<h2 id="Recommended-reading"><a href="#Recommended-reading" class="headerlink" title="Recommended reading"></a><a href="id=&quot;recommended-reading&quot;">Recommended reading</a></h2><p>R is still a relatively young language, and the resources to help you understand it are still maturing. In my personal journey to understand R, Iâve found it particularly helpful to use resources from other programming languages. R has aspects of both functional and object-oriented (OO) programming languages. Learning how these concepts are expressed in R will help you leverage your existing knowledge of other programming languages, and will help you identify areas where you can improve.</p>
<p>To understand why Râs object systems work the way they do, I found <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html" target="_blank" rel="external">The Structure and Interpretation of Computer Programs</a> (SICP) by Harold Abelson and Gerald Jay Sussman, particularly helpful. Itâs a concise but deep book. After reading it, I felt for the first time that I could actually design my own object-oriented system. The book was my first introduction to the generic function style of OO common in R. It helped me understand its strengths and weaknesses. SICP also talks a lot about functional programming, and how to create simple functions which become powerful when combined.</p>
<p>To understand the trade-offs that R has made compared to other programming languages, I found <a href="http://amzn.com/0262220695?tag=devtools-20" target="_blank" rel="external">Concepts, Techniques and Models of Computer Programming</a> by Peter van Roy and Sef Haridi extremely helpful. It helped me understand that Râs copy-on-modify semantics make it substantially easier to reason about code, and that while its current implementation is not particularly efficient, it is a solvable problem.</p>
<p>If you want to learn to be a better programmer, thereâs no place better to turn than <a href="http://amzn.com/020161622X?tag=devtools-20" target="_blank" rel="external"><em>The Pragmatic Programmer</em></a> by Andrew Hunt and David Thomas. This book is language agnostic, and provides great advice for how to be a better programmer.</p>
<h2 id="Getting-help"><a href="#Getting-help" class="headerlink" title="Getting help"></a><a href="id=&quot;getting-help&quot;">Getting help</a></h2><p>Currently, there are two main venues to get help when youâre stuck and canât figure out whatâs causing the problem: <a href="http://stackoverflow.com" target="_blank" rel="external">stackoverflow</a> and the R-help mailing list. You can get fantastic help in both venues, but they do have their own cultures and expectations. Itâs usually a good idea to spend a little time lurking, learning about community expectations, before you put up your first post.</p>
<p>Some good general advice:</p>
<ul>
<li>Make sure you have the latest version of R and of the package (or packages)  you are having problems with. It may be that your problem is the result of  a recently fixed bug.</li>
<li>Spend some time creating a  <a href="http://stackoverflow.com/questions/5963269" target="_blank" rel="external">reproducible example</a>. This  is often a useful process in its own right, because in the course of making  the problem reproducible you often figure out whatâs causing the problem.</li>
<li>Look for related problems before posting. If someone has already asked  your question and it has been answered, itâs much faster for everyone if you  use the existing answer.</li>
</ul>
<h2 id="Acknowledgments"><a href="#Acknowledgments" class="headerlink" title="Acknowledgments"></a><a href="id=&quot;intro-ack&quot;">Acknowledgments</a></h2><p>I would like to thank the tireless contributors to R-help and, more recently, <a href="http://stackoverflow.com/questions/tagged/r" target="_blank" rel="external">stackoverflow</a>. There are too many to name individually, but Iâd particularly like to thank Luke Tierney, John Chambers, Dirk Eddelbuettel, JJ Allaire and Brian Ripley for generously giving their time and correcting my countless misunderstandings.</p>
<p>This book was <a href="https://github.com/hadley/adv-r/" target="_blank" rel="external">written in the open</a>, and chapters were advertised on <a href="https://twitter.com/hadleywickham" target="_blank" rel="external">twitter</a> when complete. It is truly a community effort: many people read drafts, fixed typos, suggested improvements, and contributed content. Without those contributors, the book wouldnât be nearly as good as it is, and Iâm deeply grateful for their help. Special thanks go to Peter Li, who read the book from cover-to-cover and provided many fixes. Other outstanding contributors were Aaron Schumacher, @crtahlin, Lingbing Feng, @juancentro, and @johnbaums.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#contribs &lt;- system("git --no-pager shortlog -ns &gt; contribs.txt", intern = T)</span></span><br><span class="line">contribs &lt;- read.delim(<span class="string">"contribs.txt"</span>, header = <span class="literal">FALSE</span>,</span><br><span class="line">  stringsAsFactors = <span class="literal">FALSE</span>)[-<span class="number">1</span>, ]</span><br><span class="line">names(contribs) &lt;- c(<span class="string">"n"</span>, <span class="string">"name"</span>)</span><br><span class="line"></span><br><span class="line">contribs &lt;- contribs[order(contribs$name), ]</span><br><span class="line">contribs$uname &lt;- ifelse(!grepl(<span class="string">" "</span>, contribs$name),</span><br><span class="line">  paste0(<span class="string">"@"</span>, contribs$name), contribs$name)</span><br><span class="line"></span><br><span class="line">cat(<span class="string">"Thanks go to all contributers in alphabetical order: "</span>)</span><br><span class="line">cat(paste0(contribs$uname, collapse = <span class="string">", "</span>))</span><br><span class="line">cat(<span class="string">".\n"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Conventions"><a href="#Conventions" class="headerlink" title="Conventions"></a><a href="id=&quot;conventions&quot;">Conventions</a></h2><p>Throughout this book I use <code>f()</code> to refer to functions, <code>g</code> to refer to variables and function parameters, and <code>h/</code> to paths.</p>
<p>Larger code blocks intermingle input and output. Output is commented so that if you have an electronic version of the book, e.g., <a href="http://adv-r.had.co.nz" target="_blank" rel="external">http://adv-r.had.co.nz</a>, you can easily copy and paste examples into R. Output comments look like <code>#&gt;</code> to distinguish them from regular comments.</p>
<h2 id="Colophon"><a href="#Colophon" class="headerlink" title="Colophon"></a><a href="id=&quot;colophon&quot;">Colophon</a></h2><p>This book was written in <a href="http://rmarkdown.rstudio.com/" target="_blank" rel="external">Rmarkdown</a> inside <a href="http://www.rstudio.com/ide/" target="_blank" rel="external">Rstudio</a>. <a href="http://yihui.name/knitr/" target="_blank" rel="external">knitr</a> and <a href="http://johnmacfarlane.net/pandoc/" target="_blank" rel="external">pandoc</a> converted the raw Rmarkdown to html and pdf. The <a href="http://adv-r.had.co.nz" target="_blank" rel="external">website</a> was made with <a href="http://jekyllrb.com/" target="_blank" rel="external">jekyll</a>, styled with <a href="http://getbootstrap.com/" target="_blank" rel="external">bootstrap</a>, and automatically published to Amazonâs <a href="http://aws.amazon.com/s3/" target="_blank" rel="external">S3</a> by <a href="https://travis-ci.org/" target="_blank" rel="external">travis-ci</a>. The complete source is available from <a href="https://github.com/hadley/adv-r" target="_blank" rel="external">github</a>.</p>
<p>Code is set in <a href="http://levien.com/type/myfonts/inconsolata.html" target="_blank" rel="external">inconsolata</a>.</p>
<hr>
<h1 id="Data-structures"><a href="#Data-structures" class="headerlink" title="Data structures"></a><a href="id=&quot;data-structures&quot;">Data structures</a></h1><p>This chapter summarises the most important data structures in base R. Youâve probably used many (if not all) of them before, but you may not have thought deeply about how they are interrelated. In this brief overview, I wonât discuss individual types in depth. Instead, Iâll show you how they fit together as a whole. If you need more details, you can find them in Râs documentation.</p>
<p>Râs base data structures can be organised by their dimensionality (1d, 2d, or nd) and whether theyâre homogeneous (all contents must be of the same type) or heterogeneous (the contents can be of different types). This gives rise to the five data types most often used in data analysis:</p>
<table>
<thead>
<tr>
<th></th>
<th>Homogeneous</th>
<th>Heterogeneous</th>
</tr>
</thead>
<tbody>
<tr>
<td>1d</td>
<td>Atomic vector</td>
<td>List</td>
</tr>
<tr>
<td>2d</td>
<td>Matrix</td>
<td>Data frame</td>
</tr>
<tr>
<td>nd</td>
<td>Array</td>
</tr>
</tbody>
</table>
<p>Almost all other objects are built upon these foundations. In <a href="#oo">the OO field guide</a> youâll see how more complicated objects are built of these simple pieces. Note that R has no 0-dimensional, or scalar types. Individual numbers or strings, which you might think would be scalars, are actually vectors of length one.</p>
<p>Given an object, the best way to understand what data structures itâs composed of is to use <code>str()</code>. <code>str()</code> is short for structure and it gives a compact, human readable description of any R data structure.</p>
<h5 id="Quiz"><a href="#Quiz" class="headerlink" title="Quiz"></a>Quiz</h5><p>Take this short quiz to determine if you need to read this chapter. If the answers quickly come to mind, you can comfortably skip this chapter. You can check your answers in <a href="#data-structure-answers">answers</a>.</p>
<ol>
<li>What are the three properties of a vector, other than its contents?</li>
<li>What are the four common types of atomic vectors? What are the two   rare types?</li>
<li>What are attributes? How do you get them and set them?</li>
<li>How is a list different from an atomic vector? How is a matrix different   from a data frame?</li>
<li>Can you have a list that is a matrix? Can a data frame have a column   that is a matrix?</li>
</ol>
<h5 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#vectors">Vectors</a> introduces you to atomic vectors and lists, Râs 1d  data structures.</li>
<li><a href="#attributes">Attributes</a> takes a small detour to discuss attributes,  Râs flexible metadata specification. Here youâll learn about factors,  an important data structure created by setting attributes of an atomic  vector.</li>
<li><a href="#matrices-and-arrays">Matrices and arrays</a> introduces matrices and arrays,  data structures for storing 2d and higher dimensional data.</li>
<li><a href="#data-frames">Data frames</a> teaches you about the data frame, the most  important data structure for storing data in R. Data frames combine  the behaviour of lists and matrices to make a structure ideally suited for  the needs of statistical data.</li>
</ul>
<h2 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a><a href="id=&quot;vectors&quot;">Vectors</a></h2><p>The basic data structure in R is the vector. Vectors come in two flavours: atomic vectors and lists. They have three common properties:</p>
<ul>
<li>Type, <code>typeof()</code>, what it is.</li>
<li>Length, <code>length()</code>, how many elements it contains.</li>
<li>Attributes, <code>attributes()</code>, additional arbitrary metadata.</li>
</ul>
<p>They differ in the types of their elements: all elements of an atomic vector must be the same type, whereas the elements of a list can have different types.</p>
<p>NB: <code>is.vector()</code> does not test if an object is a vector. Instead it returns <code>TRUE</code> only if the object is a vector with no attributes apart from names. Use <code>is.atomic(x) || is.list(x)</code> to test if an object is actually a vector.</p>
<h3 id="Atomic-vectors"><a href="#Atomic-vectors" class="headerlink" title="Atomic vectors"></a>Atomic vectors</h3><p>There are four common types of atomic vectors that Iâll discuss in detail: logical, integer, double (often called numeric), and character. There are two rare types that I will not discuss further: complex and raw.</p>
<p>Atomic vectors are usually created with <code>c()</code>, short for combine:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dbl_var &lt;- c(1, 2.5, 4.5)</span><br><span class="line"># With the L suffix, you get an integer rather than a double</span><br><span class="line">int_var &lt;- c(1L, 6L, 10L)</span><br><span class="line"># Use TRUE and FALSE (or T and F) to create logical vectors</span><br><span class="line">log_var &lt;- c(TRUE, FALSE, T, F)</span><br><span class="line">chr_var &lt;- c(&quot;these are&quot;, &quot;some strings&quot;)</span><br></pre></td></tr></table></figure>
<p>Atomic vectors are always flat, even if you nest <code>c()</code>âs:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c(1, c(2, c(3, 4)))</span><br><span class="line"># the same as</span><br><span class="line">c(1, 2, 3, 4)</span><br></pre></td></tr></table></figure>
<p>Missing values are specified with <code>NA</code>, which is a logical vector of length 1. <code>NA</code> will always be coerced to the correct type if used inside <code>c()</code>, or you can create <code>NA</code>s of a specific type with <code>NA_real_</code> (a double vector), <code>NA_integer_</code> and <code>NA_character_</code>.</p>
<h4 id="Types-and-tests"><a href="#Types-and-tests" class="headerlink" title="Types and tests"></a>Types and tests</h4><p>Given a vector, you can determine its type with <code>typeof()</code>, or check if itâs a specific type with an âisâ function: <code>is.character()</code>, <code>is.double()</code>, <code>is.integer()</code>, <code>is.logical()</code>, or, more generally, <code>is.atomic()</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int_var &lt;- c(1L, 6L, 10L)</span><br><span class="line">typeof(int_var)</span><br><span class="line">is.integer(int_var)</span><br><span class="line">is.atomic(int_var)</span><br><span class="line"></span><br><span class="line">dbl_var &lt;- c(1, 2.5, 4.5)</span><br><span class="line">typeof(dbl_var)</span><br><span class="line">is.double(dbl_var)</span><br><span class="line">is.atomic(dbl_var)</span><br></pre></td></tr></table></figure>
<p>NB: <code>is.numeric()</code> is a general test for the ânumberlinessâ of a vector and returns <code>TRUE</code> for both integer and double vectors. It is not a specific test for double vectors, which are often called numeric.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is.numeric(int_var)</span><br><span class="line">is.numeric(dbl_var)</span><br></pre></td></tr></table></figure>
<h4 id="Coercion"><a href="#Coercion" class="headerlink" title="Coercion"></a>Coercion</h4><p>All elements of an atomic vector must be the same type, so when you attempt to combine different types they will be <strong>coerced</strong> to the most flexible type. Types from least to most flexible are: logical, integer, double, and character.</p>
<p>For example, combining a character and an integer yields a character:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str(c(&quot;a&quot;, 1))</span><br></pre></td></tr></table></figure>
<p>When a logical vector is coerced to an integer or double, <code>TRUE</code> becomes 1 and <code>FALSE</code> becomes 0. This is very useful in conjunction with <code>sum()</code> and <code>mean()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(FALSE, FALSE, TRUE)</span><br><span class="line">as.numeric(x)</span><br><span class="line"></span><br><span class="line"># Total number of TRUEs</span><br><span class="line">sum(x)</span><br><span class="line"></span><br><span class="line"># Proportion that are TRUE</span><br><span class="line">mean(x)</span><br></pre></td></tr></table></figure>
<p>Coercion often happens automatically. Most mathematical functions (<code>+</code>, <code>log</code>, <code>abs</code>, etc.) will coerce to a double or integer, and most logical operations (<code>&amp;</code>, <code>|</code>, <code>any</code>, etc) will coerce to a logical. You will usually get a warning message if the coercion might lose information. If confusion is likely, explicitly coerce with <code>as.character()</code>, <code>as.double()</code>, <code>as.integer()</code>, or <code>as.logical()</code>.</p>
<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>Lists are different from atomic vectors because their elements can be of any type, including lists. You construct lists by using <code>list()</code> instead of <code>c()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- list(1:3, &quot;a&quot;, c(TRUE, FALSE, TRUE), c(2.3, 5.9))</span><br><span class="line">str(x)</span><br></pre></td></tr></table></figure>
<p>Lists are sometimes called <strong>recursive</strong> vectors, because a list can contain other lists. This makes them fundamentally different from atomic vectors.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- list(list(list(list())))</span><br><span class="line">str(x)</span><br><span class="line">is.recursive(x)</span><br></pre></td></tr></table></figure>
<p><code>c()</code> will combine several lists into one. If given a combination of atomic vectors and lists, <code>c()</code> will coerce the vectors to lists before combining them. Compare the results of <code>list()</code> and <code>c()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- list(list(1, 2), c(3, 4))</span><br><span class="line">y &lt;- c(list(1, 2), c(3, 4))</span><br><span class="line">str(x)</span><br><span class="line">str(y)</span><br></pre></td></tr></table></figure>
<p>The <code>typeof()</code> a list is <code>list</code>. You can test for a list with <code>is.list()</code> and coerce to a list with <code>as.list()</code>. You can turn a list into an atomic vector with <code>unlist()</code>. If the elements of a list have different types, <code>unlist()</code> uses the same coercion rules as <code>c()</code>.</p>
<p>Lists are used to build up many of the more complicated data structures in R. For example, both data frames (described in <a href="#data-frames">data frames</a>) and linear models objects (as produced by <code>lm()</code>) are lists:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">is.list(mtcars)</span><br><span class="line"></span><br><span class="line">mod &lt;- lm(mpg ~ wt, data = mtcars)</span><br><span class="line">is.list(mod)</span><br></pre></td></tr></table></figure>
<h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>What are the six types of atomic vector? How does a list differ from an   atomic vector?</li>
<li>What makes <code>is.vector()</code> and <code>is.numeric()</code> fundamentally different to   <code>is.list()</code> and <code>is.character()</code>?</li>
<li><p>Test your knowledge of vector coercion rules by predicting the output of   the following uses of <code>c()</code>:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c(1, FALSE)</span><br><span class="line">c(&quot;a&quot;, 1)</span><br><span class="line">c(list(1), &quot;a&quot;)</span><br><span class="line">c(TRUE, 1L)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Why do you need to use <code>unlist()</code> to convert a list to an    atomic vector? Why doesnât <code>as.vector()</code> work?</p>
</li>
<li>Why is <code>1 == &quot;1&quot;</code> true? Why is <code>-1 &lt; FALSE</code> true? Why is <code>&quot;one&quot; &lt; 2</code> false?</li>
<li>Why is the default missing value, <code>NA</code>, a logical vector? Whatâs special   about logical vectors? (Hint: think about <code>c(FALSE, NA_character_)</code>.)</li>
</ol>
<h2 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a><a href="id=&quot;attributes&quot;">Attributes</a></h2><p>All objects can have arbitrary additional attributes, used to store metadata about the object. Attributes can be thought of as a named list (with unique names). Attributes can be accessed individually with <code>attr()</code> or all at once (as a list) with <code>attributes()</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y &lt;- 1:10</span><br><span class="line">attr(y, &quot;my_attribute&quot;) &lt;- &quot;This is a vector&quot;</span><br><span class="line">attr(y, &quot;my_attribute&quot;)</span><br><span class="line">str(attributes(y))</span><br></pre></td></tr></table></figure>
<p>The <code>structure()</code> function returns a new object with modified attributes:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">structure(1:10, my_attribute = &quot;This is a vector&quot;)</span><br></pre></td></tr></table></figure>
<p>By default, most attributes are lost when modifying a vector:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">attributes(y[1])</span><br><span class="line">attributes(sum(y))</span><br></pre></td></tr></table></figure>
<p>The only attributes not lost are the three most important:</p>
<ul>
<li>Names, a character vector giving each element a name, described in  <a href="#vector-names">names</a>.</li>
<li>Dimensions, used to turn vectors into matrices and arrays,  described in <a href="#matrices-and-arrays">matrices and arrays</a>.</li>
<li>Class, used to implement the S3 object system, described in <a href="#s3">S3</a>.</li>
</ul>
<p>Each of these attributes has a specific accessor function to get and set values. When working with these attributes, use <code>names(x)</code>, <code>dim(x)</code>, and <code>class(x)</code>, not <code>attr(x, &quot;names&quot;)</code>, <code>attr(x, &quot;dim&quot;)</code>, and <code>attr(x, &quot;class&quot;)</code>.</p>
<h4 id="Names"><a href="#Names" class="headerlink" title="Names"></a><a href="id=&quot;vector-names&quot;">Names</a></h4><p>You can name a vector in three ways:</p>
<ul>
<li>When creating it: <code>x &lt;- c(a = 1, b = 2, c = 3)</code>.</li>
<li>By modifying an existing vector in place:  <code>x &lt;- 1:3; names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code>.</li>
<li>By creating a modified copy of a vector:  <code>x &lt;- setNames(1:3, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code>.</li>
</ul>
<p>Names donât have to be unique. However, character subsetting, described in <a href="#lookup-tables">subsetting</a>, is the most important reason to use names and it is most useful when the names are unique.</p>
<p>Not all elements of a vector need to have a name. If some names are missing, <code>names()</code> will return an empty string for those elements. If all names are missing, <code>names()</code> will return <code>NULL</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y &lt;- c(a = 1, 2, 3)</span><br><span class="line">names(y)</span><br><span class="line"></span><br><span class="line">z &lt;- c(1, 2, 3)</span><br><span class="line">names(z)</span><br></pre></td></tr></table></figure>
<p>You can create a new vector without names using <code>unname(x)</code>, or remove names in place with <code>names(x) &lt;- NULL</code>.</p>
<h3 id="Factors"><a href="#Factors" class="headerlink" title="Factors"></a>Factors</h3><p>One important use of attributes is to define factors. A factor is a vector that can contain only predefined values, and is used to store categorical data. Factors are built on top of integer vectors using two attributes: the <code>class()</code>, âfactorâ, which makes them behave differently from regular integer vectors, and the <code>levels()</code>, which defines the set of allowed values.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;))</span><br><span class="line">x</span><br><span class="line">class(x)</span><br><span class="line">levels(x)</span><br><span class="line"></span><br><span class="line"># You can&apos;t use values that are not in the levels</span><br><span class="line">x[2] &lt;- &quot;c&quot;</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"># NB: you can&apos;t combine factors</span><br><span class="line">c(factor(&quot;a&quot;), factor(&quot;b&quot;))</span><br></pre></td></tr></table></figure>
<p>Factors are useful when you know the possible values a variable may take, even if you donât see all values in a given dataset. Using a factor instead of a character vector makes it obvious when some groups contain no observations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sex_char &lt;- c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;)</span><br><span class="line">sex_factor &lt;- factor(sex_char, levels = c(&quot;m&quot;, &quot;f&quot;))</span><br><span class="line"></span><br><span class="line">table(sex_char)</span><br><span class="line">table(sex_factor)</span><br></pre></td></tr></table></figure>
<p>Sometimes when a data frame is read directly from a file, a column youâd thought would produce a numeric vector instead produces a factor. This is caused by a non-numeric value in the column, often a missing value encoded in a special way like <code>.</code> or <code>-</code>. To remedy the situation, coerce the vector from a factor to a character vector, and then from a character to a double vector. (Be sure to check for missing values after this process.) Of course, a much better plan is to discover what caused the problem in the first place and fix that; using the <code>na.strings</code> argument to <code>read.csv()</code> is often a good place to start.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Reading in &quot;text&quot; instead of from a file here:</span><br><span class="line">z &lt;- read.csv(text = &quot;value\n12\n1\n.\n9&quot;)</span><br><span class="line">typeof(z$value)</span><br><span class="line">as.double(z$value)</span><br><span class="line"># Oops, that&apos;s not right: 3 2 1 4 are the levels of a factor,</span><br><span class="line"># not the values we read in!</span><br><span class="line">class(z$value)</span><br><span class="line"># We can fix it now:</span><br><span class="line">as.double(as.character(z$value))</span><br><span class="line"># Or change how we read it in:</span><br><span class="line">z &lt;- read.csv(text = &quot;value\n12\n1\n.\n9&quot;, na.strings=&quot;.&quot;)</span><br><span class="line">typeof(z$value)</span><br><span class="line">class(z$value)</span><br><span class="line">z$value</span><br><span class="line"># Perfect! :)</span><br></pre></td></tr></table></figure>
<p>Unfortunately, most data loading functions in R automatically convert character vectors to factors. This is suboptimal, because thereâs no way for those functions to know the set of all possible levels or their optimal order. Instead, use the argument <code>stringsAsFactors = FALSE</code> to suppress this behaviour, and then manually convert character vectors to factors using your knowledge of the data. A global option, <code>options(stringsAsFactors = FALSE)</code>, is available to control this behaviour, but I donât recommend using it. Changing a global option may have unexpected consequences when combined with other code (either from packages, or code that youâre <code>source()</code>ing), and global options make code harder to understand because they increase the number of lines you need to read to understand how a single line of code will behave.</p>
<p>While factors look (and often behave) like character vectors, they are actually integers. Be careful when treating them like strings. Some string methods (like <code>gsub()</code> and <code>grepl()</code>) will coerce factors to strings, while others (like <code>nchar()</code>) will throw an error, and still others (like <code>c()</code>) will use the underlying integer values. For this reason, itâs usually best to explicitly convert factors to character vectors if you need string-like behaviour. In early versions of R, there was a memory advantage to using factors instead of character vectors, but this is no longer the case.</p>
<h3 id="Exercises-1"><a href="#Exercises-1" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>An early draft used this code to illustrate <code>structure()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">structure(1:5, comment = &quot;my attribute&quot;)</span><br></pre></td></tr></table></figure>
<p>But when you print that object you donât see the comment attribute.<br>Why? Is the attribute missing, or is there something else special about<br>it? (Hint: try using help.)</p>
</li>
<li><p>What happens to a factor when you modify its levels?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 &lt;- factor(letters)</span><br><span class="line">levels(f1) &lt;- rev(levels(f1))</span><br></pre></td></tr></table></figure>
</li>
<li><p>What does this code do? How do <code>f2</code> and <code>f3</code> differ from <code>f1</code>?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f2 &lt;- rev(factor(letters))</span><br><span class="line"></span><br><span class="line">f3 &lt;- factor(letters, levels = rev(letters))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Matrices-and-arrays"><a href="#Matrices-and-arrays" class="headerlink" title="Matrices and arrays"></a><a href="id=&quot;matrices-and-arrays&quot;">Matrices and arrays</a></h2><p>Adding a <code>dim()</code> attribute to an atomic vector allows it to behave like a multi-dimensional <strong>array</strong>. A special case of the array is the <strong>matrix</strong>, which has two dimensions. Matrices are used commonly as part of the mathematical machinery of statistics. Arrays are much rarer, but worth being aware of.</p>
<p>Matrices and arrays are created with <code>matrix()</code> and <code>array()</code>, or by using the assignment form of <code>dim()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Two scalar arguments to specify rows and columns</span><br><span class="line">a &lt;- matrix(1:6, ncol = 3, nrow = 2)</span><br><span class="line"># One vector argument to describe all dimensions</span><br><span class="line">b &lt;- array(1:12, c(2, 3, 2))</span><br><span class="line"></span><br><span class="line"># You can also modify an object in place by setting dim()</span><br><span class="line">c &lt;- 1:6</span><br><span class="line">dim(c) &lt;- c(3, 2)</span><br><span class="line">c</span><br><span class="line">dim(c) &lt;- c(2, 3)</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p><code>length()</code> and <code>names()</code> have high-dimensional generalisations:</p>
<ul>
<li><code>length()</code> generalises to <code>nrow()</code> and <code>ncol()</code> for matrices, and <code>dim()</code>  for arrays.</li>
<li><code>names()</code> generalises to <code>rownames()</code> and <code>colnames()</code> for matrices, and  <code>dimnames()</code>, a list of character vectors, for arrays.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">length(a)</span><br><span class="line">nrow(a)</span><br><span class="line">ncol(a)</span><br><span class="line">rownames(a) &lt;- c(&quot;A&quot;, &quot;B&quot;)</span><br><span class="line">colnames(a) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">length(b)</span><br><span class="line">dim(b)</span><br><span class="line">dimnames(b) &lt;- list(c(&quot;one&quot;, &quot;two&quot;), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), c(&quot;A&quot;, &quot;B&quot;))</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<p><code>c()</code> generalises to <code>cbind()</code> and <code>rbind()</code> for matrices, and to <code>abind()</code> (provided by the <code>abind</code> package) for arrays. You can transpose a matrix with <code>t()</code>; the generalised equivalent for arrays is <code>aperm()</code>.</p>
<p>You can test if an object is a matrix or array using <code>is.matrix()</code> and <code>is.array()</code>, or by looking at the length of the <code>dim()</code>. <code>as.matrix()</code> and <code>as.array()</code> make it easy to turn an existing vector into a matrix or array.</p>
<p>Vectors are not the only 1-dimensional data structure. You can have matrices with a single row or single column, or arrays with a single dimension. They may print similarly, but will behave differently. The differences arenât too important, but itâs useful to know they exist in case you get strange output from a function (<code>tapply()</code> is a frequent offender). As always, use <code>str()</code> to reveal the differences.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str(1:3)                   # 1d vector</span><br><span class="line">str(matrix(1:3, ncol = 1)) # column vector</span><br><span class="line">str(matrix(1:3, nrow = 1)) # row vector</span><br><span class="line">str(array(1:3, 3))         # &quot;array&quot; vector</span><br></pre></td></tr></table></figure>
<p>While atomic vectors are most commonly turned into matrices, the dimension attribute can also be set on lists to make list-matrices or list-arrays:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l &lt;- list(1:3, &quot;a&quot;, TRUE, 1.0)</span><br><span class="line">dim(l) &lt;- c(2, 2)</span><br><span class="line">l</span><br></pre></td></tr></table></figure>
<p>These are relatively esoteric data structures, but can be useful if you want to arrange objects into a grid-like structure. For example, if youâre running models on a spatio-temporal grid, it might be natural to preserve the grid structure by storing the models in a 3d array.</p>
<h3 id="Exercises-2"><a href="#Exercises-2" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>What does <code>dim()</code> return when applied to a vector?</li>
<li>If <code>is.matrix(x)</code> is <code>TRUE</code>, what will <code>is.array(x)</code> return?</li>
<li><p>How would you describe the following three objects? What makes them    different to <code>1:5</code>?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x1 &lt;- array(1:5, c(1, 1, 5))</span><br><span class="line">x2 &lt;- array(1:5, c(1, 5, 1))</span><br><span class="line">x3 &lt;- array(1:5, c(5, 1, 1))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Data-frames"><a href="#Data-frames" class="headerlink" title="Data frames"></a><a href="id=&quot;data-frames&quot;">Data frames</a></h2><p>A data frame is the most common way of storing data in R, and if <a href="http://vita.had.co.nz/papers/tidy-data.pdf" target="_blank" rel="external">used systematically</a> makes data analysis easier. Under the hood, a data frame is a list of equal-length vectors. This makes it a 2-dimensional structure, so it shares properties of both the matrix and the list.  This means that a data frame has <code>names()</code>, <code>colnames()</code>, and <code>rownames()</code>, although <code>names()</code> and <code>colnames()</code> are the same thing. The <code>length()</code> of a data frame is the length of the underlying list and so is the same as <code>ncol()</code>; <code>nrow()</code> gives the number of rows.</p>
<p>As described in <a href="#subsetting">subsetting</a>, you can subset a data frame like a 1d structure (where it behaves like a list), or a 2d structure (where it behaves like a matrix).</p>
<h3 id="Creation"><a href="#Creation" class="headerlink" title="Creation"></a>Creation</h3><p>You create a data frame using <code>data.frame()</code>, which takes named vectors as input:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</span><br><span class="line">str(df)</span><br></pre></td></tr></table></figure>
<p>Beware <code>data.frame()</code>âs default behaviour which turns strings into factors. Use <code>stringAsFactors = FALSE</code> to suppress this behaviour:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(</span><br><span class="line">  x = 1:3,</span><br><span class="line">  y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;),</span><br><span class="line">  stringsAsFactors = FALSE)</span><br><span class="line">str(df)</span><br></pre></td></tr></table></figure>
<h3 id="Testing-and-coercion"><a href="#Testing-and-coercion" class="headerlink" title="Testing and coercion"></a>Testing and coercion</h3><p>Because a <code>data.frame</code> is an S3 class, its type reflects the underlying vector used to build it: the list. To check if an object is a data frame, use <code>class()</code> or test explicitly with <code>is.data.frame()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof(df)</span><br><span class="line">class(df)</span><br><span class="line">is.data.frame(df)</span><br></pre></td></tr></table></figure>
<p>You can coerce an object to a data frame with <code>as.data.frame()</code>:</p>
<ul>
<li>A vector will create a one-column data frame.</li>
<li>A list will create one column for each element; itâs an error if theyâre  not all the same length.</li>
<li>A matrix will create a data frame with the same number of columns and rows as the matrix.</li>
</ul>
<h3 id="Combining-data-frames"><a href="#Combining-data-frames" class="headerlink" title="Combining data frames"></a>Combining data frames</h3><p>You can combine data frames using <code>cbind()</code> and <code>rbind()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cbind(df, data.frame(z = 3:1))</span><br><span class="line">rbind(df, data.frame(x = 10, y = &quot;z&quot;))</span><br></pre></td></tr></table></figure>
<p>When combining column-wise, the number of rows must match, but row names are ignored. When combining row-wise, both the number and names of columns must match. Use <code>plyr::rbind.fill()</code> to combine data frames that donât have the same columns.</p>
<p>Itâs a common mistake to try and create a data frame by <code>cbind()</code>ing vectors together. This doesnât work because <code>cbind()</code> will create a matrix unless one of the arguments is already a data frame. Instead use <code>data.frame()</code> directly:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bad &lt;- data.frame(cbind(a = 1:2, b = c(&quot;a&quot;, &quot;b&quot;)))</span><br><span class="line">str(bad)</span><br><span class="line">good &lt;- data.frame(a = 1:2, b = c(&quot;a&quot;, &quot;b&quot;),</span><br><span class="line">  stringsAsFactors = FALSE)</span><br><span class="line">str(good)</span><br></pre></td></tr></table></figure>
<p>The conversion rules for <code>cbind()</code> are complicated and best avoided by ensuring all inputs are of the same type.</p>
<h3 id="Special-columns"><a href="#Special-columns" class="headerlink" title="Special columns"></a>Special columns</h3><p>Since a data frame is a list of vectors, it is possible for a data frame to have a column that is a list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(x = 1:3)</span><br><span class="line">df$y &lt;- list(1:2, 1:3, 1:4)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p>However, when a list is given to <code>data.frame()</code>, it tries to put each item of the list into its own column, so this fails:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.frame(x = 1:3, y = list(1:2, 1:3, 1:4))</span><br></pre></td></tr></table></figure>
<p>A workaround is to use <code>I()</code>, which causes <code>data.frame()</code> to treat the list as one unit:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dfl &lt;- data.frame(x = 1:3, y = I(list(1:2, 1:3, 1:4)))</span><br><span class="line">str(dfl)</span><br><span class="line">dfl[2, &quot;y&quot;]</span><br></pre></td></tr></table></figure>
<p><code>I()</code> adds the <code>AsIs</code> class to its input, but this can usually be safely ignored.</p>
<p>Similarly, itâs also possible to have a column of a data frame thatâs a matrix or array, as long as the number of rows matches the data frame:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dfm &lt;- data.frame(x = 1:3, y = I(matrix(1:9, nrow = 3)))</span><br><span class="line">str(dfm)</span><br><span class="line">dfm[2, &quot;y&quot;]</span><br></pre></td></tr></table></figure>
<p>Use list and array columns with caution: many functions that work with data frames assume that all columns are atomic vectors.</p>
<h3 id="Exercises-3"><a href="#Exercises-3" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>What attributes does a data frame possess?</li>
<li>What does <code>as.matrix()</code> do when applied to a data frame with    columns of different types?</li>
<li>Can you have a data frame with 0 rows? What about 0 columns?</li>
</ol>
<h2 id="Answers"><a href="#Answers" class="headerlink" title="Answers"></a><a href="id=&quot;data-structure-answers&quot;">Answers</a></h2><ol>
<li>The three properties of a vector are type, length, and attributes.</li>
<li>The four common types of atomic vector are logical, integer, double     (sometimes called numeric), and character. The two rarer types are    complex and raw.</li>
<li>Attributes allow you to associate arbitrary additional metadata to    any object. You can get and set individual attributes with <code>attr(x, &quot;y&quot;)</code>    and <code>attr(x, &quot;y&quot;) &lt;- value</code>; or get and set all attributes at once with    <code>attributes()</code>.</li>
<li>The elements of a list can be any type (even a list); the elements of     an atomic vector are all of the same type. Similarly, every element of     a matrix must be the same type; in a data frame, the different columns     can have different types.</li>
<li>You can make âlist-arrayâ by assuming dimensions to a list. You can    make a matrix a column of a data frame with <code>df$x &lt;- matrix()</code>, or    using <code>I()</code> when creating a new data frame <code>data.frame(x = I(matrix()))</code>.</li>
</ol>
<hr>
<h1 id="Subsetting"><a href="#Subsetting" class="headerlink" title="Subsetting"></a><a href="id=&quot;subsetting&quot;">Subsetting</a></h1><p>Râs subsetting operators are powerful and fast. Mastery of subsetting allows you to succinctly express complex operations in a way that few other languages can match. Subsetting is hard to learn because you need to master a number of interrelated concepts:</p>
<ul>
<li>The three subsetting operators.</li>
<li>The six types of subsetting.</li>
<li>Important differences in behaviour for different objects (e.g., vectors,  lists, factors, matrices, and data frames).</li>
<li>The use of subsetting in conjunction with assignment.</li>
</ul>
<p>This chapter helps you master subsetting by starting with the simplest type of subsetting: subsetting an atomic vector with <code>[</code>. It then gradually extends your knowledge, first to more complicated data types (like arrays and lists), and then to the other subsetting operators, <code>[[</code> and <code>$</code>. Youâll then learn how subsetting and assignment can be combined to modify parts of an object, and, finally, youâll see a large number of useful applications.</p>
<p>Subsetting is a natural complement to <code>str()</code>. <code>str()</code> shows you the structure of any object, and subsetting allows you to pull out the pieces that youâre interested in.</p>
<h5 id="Quiz-1"><a href="#Quiz-1" class="headerlink" title="Quiz"></a>Quiz</h5><p>Take this short quiz to determine if you need to read this chapter. If the answers quickly come to mind, you can comfortably skip this chapter. Check your answers in <a href="#subsetting-answers">answers</a>.</p>
<ol>
<li>What is the result of subsetting a vector with positive integers,    negative integers, a logical vector, or a character vector?</li>
<li>Whatâs the difference between <code>[</code>, <code>[[</code>, and <code>$</code> when applied to a list?</li>
<li>When should you use <code>drop = FALSE</code>?</li>
<li>If <code>x</code> is a matrix, what does <code>x[] &lt;- 0</code> do? How is it different to    <code>x &lt;- 0</code>?</li>
<li>How can you use a named vector to relabel categorical variables?</li>
</ol>
<h5 id="Outline-1"><a href="#Outline-1" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#data-types">Data types</a> starts by teaching you about <code>[</code>. Youâll start  by learning the six types of data that you can use to subset atomic vectors.  Youâll then learn how those six data types act when used to subset lists,  matrices, data frames, and S3 objects.</li>
<li><a href="#subsetting-operators">Subsetting operators</a> expands your knowledge of  subsetting operators to include <code>[[</code> and <code>$</code>, focussing on the important  principles of simplifying vs. preserving.</li>
<li>In <a href="#subassignment">Subsetting and assignment</a> youâll learn the  art of subassignment, combining subsetting and assignment to modify parts  of an object.</li>
<li><a href="#applications">Applications</a> leads you through eight important, but  not obvious, applications of subsetting to solve problems that you  often encounter in a data analysis.</li>
</ul>
<h2 id="Data-types"><a href="#Data-types" class="headerlink" title="Data types"></a><a href="id=&quot;data-types&quot;">Data types</a></h2><p>Itâs easiest to learn how subsetting works for atomic vectors, and then how it generalises to higher dimensions and other more complicated objects. Weâll start with <code>[</code>, the most commonly used operator. <a href="#subsetting-operators">Subsetting operators</a> will cover <code>[[</code> and <code>$</code>, the two other main subsetting operators.</p>
<h3 id="Atomic-vectors-1"><a href="#Atomic-vectors-1" class="headerlink" title="Atomic vectors"></a>Atomic vectors</h3><p>Letâs explore the different types of subsetting with a simple vector, <code>x</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(2.1, 4.2, 3.3, 5.4)</span><br></pre></td></tr></table></figure>
<p>Note that the number after the decimal point gives the original position in the vector.</p>
<p>There are five things that you can use to subset a vector:</p>
<ul>
<li><p><strong>Positive integers</strong> return elements at the specified positions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x[c(3, 1)]</span><br><span class="line">x[order(x)]</span><br><span class="line"></span><br><span class="line"># Duplicated indices yield duplicated values</span><br><span class="line">x[c(1, 1)]</span><br><span class="line"></span><br><span class="line"># Real numbers are silently truncated to integers</span><br><span class="line">x[c(2.1, 2.9)]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Negative integers</strong> omit elements at the specified positions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[-c(3, 1)]</span><br></pre></td></tr></table></figure>
<p>You canât mix positive and negative integers in a single subset:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[c(-1, 2)]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Logical vectors</strong> select elements where the corresponding logical    value is <code>TRUE</code>. This is probably the most useful type of subsetting    because you write the expression that creates the logical vector:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[c(TRUE, TRUE, FALSE, FALSE)]</span><br><span class="line">x[x &gt; 3]</span><br></pre></td></tr></table></figure>
<p>If the logical vector is shorter than the vector being subsetted, it<br>will be <em>recycled</em> to be the same length.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x[c(TRUE, FALSE)]</span><br><span class="line"># Equivalent to</span><br><span class="line">x[c(TRUE, FALSE, TRUE, FALSE)]</span><br></pre></td></tr></table></figure>
<p>A missing value in the index always yields a missing value in the output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[c(TRUE, TRUE, NA, FALSE)]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Nothing</strong> returns the original vector. This is not useful   for vectors but is very useful for matrices, data frames, and arrays. It   can also be useful in conjunction with assignment.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Zero</strong> returns a zero-length vector. This is not something you    usually do on purpose, but it can be helpful for generating test data.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[0]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>If the vector is named, you can also use:</p>
<ul>
<li><p><strong>Character vectors</strong> to return elements with matching names.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(y &lt;- setNames(x, letters[1:4]))</span><br><span class="line">y[c(&quot;d&quot;, &quot;c&quot;, &quot;a&quot;)]</span><br><span class="line"></span><br><span class="line"># Like integer indices, you can repeat indices</span><br><span class="line">y[c(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;)]</span><br><span class="line"></span><br><span class="line"># When subsetting with [ names are always matched exactly</span><br><span class="line">z &lt;- c(abc = 1, def = 2)</span><br><span class="line">z[c(&quot;a&quot;, &quot;d&quot;)]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Lists-1"><a href="#Lists-1" class="headerlink" title="Lists"></a>Lists</h3><p>Subsetting a list works in the same way as subsetting an atomic vector. Using <code>[</code> will always return a list; <code>[[</code> and <code>$</code>, as described below, let you pull out the components of the list.</p>
<h3 id="Matrices-and-arrays-1"><a href="#Matrices-and-arrays-1" class="headerlink" title="Matrices and arrays"></a><a href="id=&quot;matrix-subsetting&quot;">Matrices and arrays</a></h3><p>You can subset higher-dimensional structures in three ways:</p>
<ul>
<li>With multiple vectors.</li>
<li>With a single vector.</li>
<li>With a matrix.</li>
</ul>
<p>The most common way of subsetting matrices (2d) and arrays (&gt;2d) is a simple generalisation of 1d subsetting: you supply a 1d index for each dimension, separated by a comma. Blank subsetting is now useful because it lets you keep all rows or all columns.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- matrix(1:9, nrow = 3)</span><br><span class="line">colnames(a) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">a[1:2, ]</span><br><span class="line">a[c(T, F, T), c(&quot;B&quot;, &quot;A&quot;)]</span><br><span class="line">a[0, -2]</span><br></pre></td></tr></table></figure>
<p>By default, <code>[</code> will simplify the results to the lowest possible dimensionality. See <a href="#simplify-preserve">simplifying vs. preserving</a> to learn how to avoid this.</p>
<p>Because matrices and arrays are implemented as vectors with special attributes, you can subset them with a single vector. In that case, they will behave like a vector. Arrays in R are stored in column-major order:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(vals &lt;- outer(1:5, 1:5, FUN = &quot;paste&quot;, sep = &quot;,&quot;))</span><br><span class="line">vals[c(4, 15)]</span><br></pre></td></tr></table></figure>
<p>You can also subset higher-dimensional data structures with an integer matrix (or, if named, a character matrix). Each row in the matrix specifies the location of one value, where each column corresponds to a dimension in the array being subsetted. This means that you use a 2 column matrix to subset a matrix, a 3 column matrix to subset a 3d array, and so on. The result is a vector of values:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vals &lt;- outer(1:5, 1:5, FUN = &quot;paste&quot;, sep = &quot;,&quot;)</span><br><span class="line">select &lt;- matrix(ncol = 2, byrow = TRUE, c(</span><br><span class="line">  1, 1,</span><br><span class="line">  3, 1,</span><br><span class="line">  2, 4</span><br><span class="line">))</span><br><span class="line">vals[select]</span><br></pre></td></tr></table></figure>
<h3 id="Data-frames-1"><a href="#Data-frames-1" class="headerlink" title="Data frames"></a><a href="id=&quot;df-subsetting&quot;">Data frames</a></h3><p>Data frames possess the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists; if you subset with two vectors, they behave like matrices.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])</span><br><span class="line"></span><br><span class="line">df[df$x == 2, ]</span><br><span class="line">df[c(1, 3), ]</span><br><span class="line"></span><br><span class="line"># There are two ways to select columns from a data frame</span><br><span class="line"># Like a list:</span><br><span class="line">df[c(&quot;x&quot;, &quot;z&quot;)]</span><br><span class="line"># Like a matrix</span><br><span class="line">df[, c(&quot;x&quot;, &quot;z&quot;)]</span><br><span class="line"></span><br><span class="line"># There&apos;s an important difference if you select a single</span><br><span class="line"># column: matrix subsetting simplifies by default, list</span><br><span class="line"># subsetting does not.</span><br><span class="line">str(df[&quot;x&quot;])</span><br><span class="line">str(df[, &quot;x&quot;])</span><br></pre></td></tr></table></figure>
<h3 id="S3-objects"><a href="#S3-objects" class="headerlink" title="S3 objects"></a>S3 objects</h3><p>S3 objects are made up of atomic vectors, arrays, and lists, so you can always pull apart an S3 object using the techniques described above and the knowledge you gain from <code>str()</code>.</p>
<h3 id="S4-objects"><a href="#S4-objects" class="headerlink" title="S4 objects"></a>S4 objects</h3><p>There are also two additional subsetting operators that are needed for S4 objects: <code>@</code> (equivalent to <code>$</code>), and <code>slot()</code> (equivalent to <code>[[</code>). <code>@</code> is more restrictive than <code>$</code> in that it will return an error if the slot does not exist. These are described in more detail in <a href="#s4">the OO field guide</a>.</p>
<h3 id="Exercises-4"><a href="#Exercises-4" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>Fix each of the following common data frame subsetting errors:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mtcars[mtcars$cyl = 4, ]</span><br><span class="line">mtcars[-1:4, ]</span><br><span class="line">mtcars[mtcars$cyl &lt;= 5]</span><br><span class="line">mtcars[mtcars$cyl == 4 | 6, ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Why does <code>x &lt;- 1:5; x[NA]</code> yield five missing values? (Hint: why is    it different from <code>x[NA_real_]</code>?)</p>
</li>
<li><p>What does <code>upper.tri()</code> return? How does subsetting a matrix with it    work? Do we need any additional subsetting rules to describe its behaviour?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- outer(1:5, 1:5, FUN = &quot;*&quot;)</span><br><span class="line">x[upper.tri(x)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Why does <code>mtcars[1:20]</code> return an error? How does it differ from the    similar <code>mtcars[1:20, ]</code>?</p>
</li>
<li>Implement your own function that extracts the diagonal entries from a    matrix (it should behave like <code>diag(x)</code> where <code>x</code> is a matrix).</li>
<li>What does <code>df[is.na(df)] &lt;- 0</code> do? How does it work?</li>
</ol>
<h2 id="Subsetting-operators"><a href="#Subsetting-operators" class="headerlink" title="Subsetting operators"></a><a href="id=&quot;subsetting-operators&quot;">Subsetting operators</a></h2><p>There are two other subsetting operators: <code>[[</code> and <code>$</code>. <code>[[</code> is similar to <code>[</code>, except it can only return a single value and it allows you to pull pieces out of a list. <code>$</code> is a useful shorthand for <code>[[</code> combined with character subsetting.</p>
<p>You need <code>[[</code> when working with lists. This is because when <code>[</code> is applied to a list it always returns a list: it never gives you the contents of the list. To get the contents, you need <code>[[</code>:</p>
<blockquote>
<p> âIf list <code>x</code> is a train carrying objects, then <code>x[[5]]</code> is<br>the object in car 5; <code>x[4:6]</code> is a train of cars 4-6.â</p>
<p>â @RLangTip</p>
</blockquote>
<p>Because it can return only a single value, you must use <code>[[</code> with either a single positive integer or a string:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- list(a = 1, b = 2)</span><br><span class="line">a[[1]]</span><br><span class="line">a[[&quot;a&quot;]]</span><br><span class="line"></span><br><span class="line"># If you do supply a vector it indexes recursively</span><br><span class="line">b &lt;- list(a = list(b = list(c = list(d = 1))))</span><br><span class="line">b[[c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)]]</span><br><span class="line"># Same as</span><br><span class="line">b[[&quot;a&quot;]][[&quot;b&quot;]][[&quot;c&quot;]][[&quot;d&quot;]]</span><br></pre></td></tr></table></figure>
<p>Because data frames are lists of columns, you can use <code>[[</code> to extract a column from data frames: <code>mtcars[[1]]</code>, <code>mtcars[[&quot;cyl&quot;]]</code>.</p>
<p>S3 and S4 objects can override the standard behaviour of <code>[</code> and <code>[[</code> so they behave differently for different types of objects. The key difference is usually how you select between simplifying or preserving behaviours, and what the default is.</p>
<h3 id="Simplifying-vs-preserving-subsetting"><a href="#Simplifying-vs-preserving-subsetting" class="headerlink" title="Simplifying vs. preserving subsetting"></a><a href="id=&quot;simplify-preserve&quot;">Simplifying vs. preserving subsetting</a></h3><p>Itâs important to understand the distinction between simplifying and preserving subsetting. Simplifying subsets returns the simplest possible data structure that can represent the output, and is useful interactively because it usually gives you what you want. Preserving subsetting keeps the structure of the output the same as the input, and is generally better for programming because the result will always be the same type. Omitting <code>drop = FALSE</code> when subsetting matrices and data frames is one of the most common sources of programming errors. (It will work for your test cases, but then someone will pass in a single column data frame and it will fail in an unexpected and unclear way.)</p>
<p>Unfortunately, how you switch between simplifying and preserving differs for different data types, as summarised in the table below.</p>
<table>
<thead>
<tr>
<th></th>
<th>Simplifying</th>
<th>Preserving</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vector</td>
<td><code>x[[1]]</code></td>
<td><code>x[1]</code></td>
</tr>
<tr>
<td>List</td>
<td><code>x[[1]]</code></td>
<td><code>x[1]</code></td>
</tr>
<tr>
<td>Factor</td>
<td><code>x[1:4, drop = T]</code></td>
<td><code>x[1:4]</code></td>
</tr>
<tr>
<td>Array</td>
<td><code>x[1, ]</code> <strong>or</strong> <code>x[, 1]</code></td>
<td><code>x[1, , drop = F]</code> <strong>or</strong> <code>x[, 1, drop = F]</code></td>
</tr>
<tr>
<td>Data frame</td>
<td><code>x[, 1]</code> <strong>or</strong> <code>x[[1]]</code></td>
<td><code>x[, 1, drop = F]</code> <strong>or</strong> <code>x[1]</code></td>
</tr>
</tbody>
</table>
<p>Preserving is the same for all data types: you get the same type of output as input. Simplifying behaviour varies slightly between different data types, as described below:</p>
<ul>
<li><p><strong>Atomic vector</strong>: removes names.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(a = 1, b = 2)</span><br><span class="line">x[1]</span><br><span class="line">x[[1]]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>List</strong>: return the object inside the list, not a single element list.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y &lt;- list(a = 1, b = 2)</span><br><span class="line">str(y[1])</span><br><span class="line">str(y[[1]])</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Factor</strong>: drops any unused levels.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z &lt;- factor(c(&quot;a&quot;, &quot;b&quot;))</span><br><span class="line">z[1]</span><br><span class="line">z[1, drop = TRUE]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Matrix</strong> or <strong>array</strong>: if any of the dimensions has length 1,<br>drops that dimension.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- matrix(1:4, nrow = 2)</span><br><span class="line">a[1, , drop = FALSE]</span><br><span class="line">a[1, ]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Data frame</strong>: if output is a single column, returns a vector instead of<br>a data frame.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(a = 1:2, b = 1:2)</span><br><span class="line">str(df[1])</span><br><span class="line">str(df[[1]])</span><br><span class="line">str(df[, &quot;a&quot;, drop = FALSE])</span><br><span class="line">str(df[, &quot;a&quot;])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title="$"></a><code>$</code></h3><p><code>$</code> is a shorthand operator, where <code>x$y</code> is equivalent to <code>x[[&quot;y&quot;, exact = FALSE]]</code>.  Itâs often used to access variables in a data frame, as in <code>mtcars$cyl</code> or <code>diamonds$carat</code>.</p>
<p>One common mistake with <code>$</code> is to try and use it when you have the name of a column stored in a variable:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var &lt;- &quot;cyl&quot;</span><br><span class="line"># Doesn&apos;t work - mtcars$var translated to mtcars[[&quot;var&quot;]]</span><br><span class="line">mtcars$var</span><br><span class="line"></span><br><span class="line"># Instead use [[</span><br><span class="line">mtcars[[var]]</span><br></pre></td></tr></table></figure>
<p>Thereâs one important difference between <code>$</code> and <code>[[</code>. <code>$</code> does partial matching:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- list(abc = 1)</span><br><span class="line">x$a</span><br><span class="line">x[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>
<p>If you want to avoid this behaviour you can set the global option <code>warnPartialMatchDollar</code> to <code>TRUE</code>. Use with caution: it may affect behaviour in other code you have loaded (e.g., from a package).</p>
<h3 id="Missing-out-of-bounds-indices"><a href="#Missing-out-of-bounds-indices" class="headerlink" title="Missing/out of bounds indices"></a>Missing/out of bounds indices</h3><p><code>[</code> and <code>[[</code> differ slightly in their behaviour when the index is out of bounds (OOB), for example, when you try to extract the fifth element of a length four vector, or subset a vector with <code>NA</code> or <code>NULL</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1:4</span><br><span class="line">str(x[5])</span><br><span class="line">str(x[NA_real_])</span><br><span class="line">str(x[NULL])</span><br></pre></td></tr></table></figure>
<p>The following table summarises the results of subsetting atomic vectors and lists with <code>[</code> and <code>[[</code> and different types of OOB value.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Index</th>
<th>Atomic</th>
<th>List</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[</code></td>
<td>OOB</td>
<td><code>NA</code></td>
<td><code>list(NULL)</code></td>
</tr>
<tr>
<td><code>[</code></td>
<td><code>NA_real_</code></td>
<td><code>NA</code></td>
<td><code>list(NULL)</code></td>
</tr>
<tr>
<td><code>[</code></td>
<td><code>NULL</code></td>
<td><code>x[0]</code></td>
<td><code>list(NULL)</code></td>
</tr>
<tr>
<td><code>[[</code></td>
<td>OOB</td>
<td>Error</td>
<td>Error</td>
</tr>
<tr>
<td><code>[[</code></td>
<td><code>NA_real_</code></td>
<td>Error</td>
<td><code>NULL</code></td>
</tr>
<tr>
<td><code>[[</code></td>
<td><code>NULL</code></td>
<td>Error</td>
<td>Error</td>
</tr>
</tbody>
</table>
<p>If the input vector is named, then the names of OOB, missing, or <code>NULL</code> components will be <code>&quot;&lt;NA&gt;&quot;</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">numeric()[1]</span><br><span class="line">numeric()[NA_real_]</span><br><span class="line">numeric()[NULL]</span><br><span class="line">numeric()[[1]]</span><br><span class="line">numeric()[[NA_real_]]</span><br><span class="line">numeric()[[NULL]]</span><br><span class="line"></span><br><span class="line">list()[1]</span><br><span class="line">list()[NA_real_]</span><br><span class="line">list()[NULL]</span><br><span class="line">list()[[1]]</span><br><span class="line">list()[[NA_real_]]</span><br><span class="line">list()[[NULL]]</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-5"><a href="#Exercises-5" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Given a linear model, e.g., <code>mod &lt;- lm(mpg ~ wt, data = mtcars)</code>, extract<br>the residual degrees of freedom. Extract the R squared from the model<br>summary (<code>summary(mod)</code>)</li>
</ol>
<h2 id="Subsetting-and-assignment"><a href="#Subsetting-and-assignment" class="headerlink" title="Subsetting and assignment"></a><a href="id=&quot;subassignment&quot;">Subsetting and assignment</a></h2><p>All subsetting operators can be combined with assignment to modify selected values of the input vector.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1:5</span><br><span class="line">x[c(1, 2)] &lt;- 2:3</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"># The length of the LHS needs to match the RHS</span><br><span class="line">x[-1] &lt;- 4:1</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"># Note that there&apos;s no checking for duplicate indices</span><br><span class="line">x[c(1, 1)] &lt;- 2:3</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"># You can&apos;t combine integer indices with NA</span><br><span class="line">x[c(1, NA)] &lt;- c(1, 2)</span><br><span class="line"># But you can combine logical indices with NA</span><br><span class="line"># (where they&apos;re treated as false).</span><br><span class="line">x[c(T, F, NA)] &lt;- 1</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"># This is mostly useful when conditionally modifying vectors</span><br><span class="line">df &lt;- data.frame(a = c(1, 10, NA))</span><br><span class="line">df$a[df$a &lt; 5] &lt;- 0</span><br><span class="line">df$a</span><br></pre></td></tr></table></figure>
<p>Subsetting with nothing can be useful in conjunction with assignment because it will preserve the original object class and structure. Compare the following two expressions. In the first, <code>mtcars</code> will remain as a data frame. In the second, <code>mtcars</code> will become a list.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mtcars[] &lt;- lapply(mtcars, as.integer)</span><br><span class="line">mtcars &lt;- lapply(mtcars, as.integer)</span><br></pre></td></tr></table></figure>
<p>With lists, you can use subsetting + assignment + <code>NULL</code> to remove components from a list. To add a literal <code>NULL</code> to a list, use <code>[</code> and <code>list(NULL)</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- list(a = 1, b = 2)</span><br><span class="line">x[[&quot;b&quot;]] &lt;- NULL</span><br><span class="line">str(x)</span><br><span class="line"></span><br><span class="line">y &lt;- list(a = 1)</span><br><span class="line">y[&quot;b&quot;] &lt;- list(NULL)</span><br><span class="line">str(y)</span><br></pre></td></tr></table></figure>
<h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a><a href="id=&quot;applications&quot;">Applications</a></h2><p>The basic principles described above give rise to a wide variety of useful applications. Some of the most important are described below. Many of these basic techniques are wrapped up into more concise functions (e.g., <code>subset()</code>, <code>merge()</code>, <code>plyr::arrange()</code>), but it is useful to understand how they are implemented with basic subsetting. This will allow you to adapt to new situations that are not dealt with by existing functions.</p>
<h3 id="Lookup-tables"><a href="#Lookup-tables" class="headerlink" title="Lookup tables"></a><a href="id=&quot;lookup-tables&quot;">Lookup tables</a></h3><p>Character matching provides a powerful way to make lookup tables. Say you want to convert abbreviations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(&quot;m&quot;, &quot;f&quot;, &quot;u&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;)</span><br><span class="line">lookup &lt;- c(m = &quot;Male&quot;, f = &quot;Female&quot;, u = NA)</span><br><span class="line">lookup[x]</span><br><span class="line">unname(lookup[x])</span><br><span class="line"></span><br><span class="line"># Or with fewer output values</span><br><span class="line">c(m = &quot;Known&quot;, f = &quot;Known&quot;, u = &quot;Unknown&quot;)[x]</span><br></pre></td></tr></table></figure>
<p>If you donât want names in the result, use <code>unname()</code> to remove them.</p>
<h3 id="Matching-and-merging-by-hand-integer-subsetting"><a href="#Matching-and-merging-by-hand-integer-subsetting" class="headerlink" title="Matching and merging by hand(integer subsetting)"></a><a href="id=&quot;matching-merging&quot;">Matching and merging by hand(integer subsetting)</a></h3><p>You may have a more complicated lookup table which has multiple columns of information. Suppose we have a vector of integer grades, and a table that describes their properties:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grades &lt;- c(1, 2, 2, 3, 1)</span><br><span class="line"></span><br><span class="line">info &lt;- data.frame(</span><br><span class="line">  grade = 3:1,</span><br><span class="line">  desc = c(&quot;Excellent&quot;, &quot;Good&quot;, &quot;Poor&quot;),</span><br><span class="line">  fail = c(F, F, T)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>We want to duplicate the info table so that we have a row for each value in <code>grades</code>. We can do this in two ways, either using <code>match()</code> and integer subsetting, or <code>rownames()</code> and character subsetting:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grades</span><br><span class="line"></span><br><span class="line"># Using match</span><br><span class="line">id &lt;- match(grades, info$grade)</span><br><span class="line">info[id, ]</span><br><span class="line"></span><br><span class="line"># Using rownames</span><br><span class="line">rownames(info) &lt;- info$grade</span><br><span class="line">info[as.character(grades), ]</span><br></pre></td></tr></table></figure>
<p>If you have multiple columns to match on, youâll need to first collapse them to a single column (with <code>interaction()</code>, <code>paste()</code>, or <code>plyr::id()</code>).  You can also use <code>merge()</code> or <code>plyr::join()</code>, which do the same thing for you â read the source code to see how.</p>
<h3 id="Random-samples-bootstrap-integer-subsetting"><a href="#Random-samples-bootstrap-integer-subsetting" class="headerlink" title="Random samples/bootstrap (integer subsetting)"></a>Random samples/bootstrap (integer subsetting)</h3><p>You can use integer indices to perform random sampling or bootstrapping of a vector or data frame. <code>sample()</code> generates a vector of indices, then subsetting to access the values:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(x = rep(1:3, each = 2), y = 6:1, z = letters[1:6])</span><br><span class="line"></span><br><span class="line"># Set seed for reproducibility</span><br><span class="line">set.seed(10)</span><br><span class="line"></span><br><span class="line"># Randomly reorder</span><br><span class="line">df[sample(nrow(df)), ]</span><br><span class="line"># Select 3 random rows</span><br><span class="line">df[sample(nrow(df), 3), ]</span><br><span class="line"># Select 6 bootstrap replicates</span><br><span class="line">df[sample(nrow(df), 6, rep = T), ]</span><br></pre></td></tr></table></figure>
<p>The arguments of <code>sample()</code> control the number of samples to extract, and whether sampling is performed with or without replacement.</p>
<h3 id="Ordering-integer-subsetting"><a href="#Ordering-integer-subsetting" class="headerlink" title="Ordering (integer subsetting)"></a>Ordering (integer subsetting)</h3><p><code>order()</code> takes a vector as input and returns an integer vector describing how the subsetted vector should be ordered:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(&quot;b&quot;, &quot;c&quot;, &quot;a&quot;)</span><br><span class="line">order(x)</span><br><span class="line">x[order(x)]</span><br></pre></td></tr></table></figure>
<p>To break ties, you can supply additional variables to <code>order()</code>, and you can change from ascending to descending order using <code>decreasing = TRUE</code>.  By default, any missing values will be put at the end of the vector; however, you can remove them with <code>na.last = NA</code> or put at the front with <code>na.last = FALSE</code>.</p>
<p>For two or more dimensions, <code>order()</code> and integer subsetting makes it easy to order either the rows or columns of an object:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Randomly reorder df</span><br><span class="line">df2 &lt;- df[sample(nrow(df)), 3:1]</span><br><span class="line">df2</span><br><span class="line"></span><br><span class="line">df2[order(df2$x), ]</span><br><span class="line">df2[, order(names(df2))]</span><br></pre></td></tr></table></figure>
<p>More concise, but less flexible, functions are available for sorting vectors, <code>sort()</code>, and data frames, <code>plyr::arrange()</code>.</p>
<h3 id="Expanding-aggregated-counts-integer-subsetting"><a href="#Expanding-aggregated-counts-integer-subsetting" class="headerlink" title="Expanding aggregated counts (integer subsetting)"></a>Expanding aggregated counts (integer subsetting)</h3><p>Sometimes you get a data frame where identical rows have been collapsed into one and a count column has been added. <code>rep()</code> and integer subsetting make it easy to uncollapse the data by subsetting with a repeated row index:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))</span><br><span class="line">rep(1:nrow(df), df$n)</span><br><span class="line">df[rep(1:nrow(df), df$n), ]</span><br></pre></td></tr></table></figure>
<h3 id="Removing-columns-from-data-frames-character-subsetting"><a href="#Removing-columns-from-data-frames-character-subsetting" class="headerlink" title="Removing columns from data frames (character subsetting)"></a>Removing columns from data frames (character subsetting)</h3><p>There are two ways to remove columns from a data frame. You can set individual columns to NULL:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])</span><br><span class="line">df$z &lt;- NULL</span><br></pre></td></tr></table></figure>
<p>Or you can subset to return only the columns you want:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])</span><br><span class="line">df[c(&quot;x&quot;, &quot;y&quot;)]</span><br></pre></td></tr></table></figure>
<p>If you know the columns you donât want, use set operations to work out which colums to keep:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[setdiff(names(df), &quot;z&quot;)]</span><br></pre></td></tr></table></figure>
<h3 id="Selecting-rows-based-on-a-condition-logical-subsetting"><a href="#Selecting-rows-based-on-a-condition-logical-subsetting" class="headerlink" title="Selecting rows based on a condition (logical subsetting)"></a>Selecting rows based on a condition (logical subsetting)</h3><p>Because it allows you to easily combine conditions from multiple columns, logical subsetting is probably the most commonly used technique for extracting rows out of a data frame.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mtcars[mtcars$gear == 5, ]</span><br><span class="line">mtcars[mtcars$gear == 5 &amp; mtcars$cyl == 4, ]</span><br></pre></td></tr></table></figure>
<p>Remember to use the vector boolean operators <code>&amp;</code> and <code>|</code>, not the short-circuiting scalar operators <code>&amp;&amp;</code> and <code>||</code> which are more useful inside if statements. Donât forget <a href="http://en.wikipedia.org/wiki/De_Morgan&#39;s_laws" target="_blank" rel="external">De Morganâs laws</a>, which can be useful to simplify negations:</p>
<ul>
<li><code>!(X &amp; Y)</code> is the same as <code>!X | !Y</code></li>
<li><code>!(X | Y)</code> is the same as <code>!X &amp; !Y</code></li>
</ul>
<p>For example, <code>!(X &amp; !(Y | Z))</code> simplifies to <code>!X | !!(Y|Z)</code>, and then to <code>!X | Y | Z</code>.</p>
<p><code>subset()</code> is a specialised shorthand function for subsetting data frames, and saves some typing because you donât need to repeat the name of the data frame. Youâll learn how it works in <a href="#nse">non-standard evaluation</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subset(mtcars, gear == 5)</span><br><span class="line">subset(mtcars, gear == 5 &amp; cyl == 4)</span><br></pre></td></tr></table></figure>
<h3 id="Boolean-algebra-vs-sets-logical-amp-integer-subsetting"><a href="#Boolean-algebra-vs-sets-logical-amp-integer-subsetting" class="headerlink" title="Boolean algebra vs. sets (logical &amp; integer subsetting)"></a>Boolean algebra vs. sets (logical &amp; integer subsetting)</h3><p>Itâs useful to be aware of the natural equivalence between set operations (integer subsetting) and boolean algebra (logical subsetting). Using set operations is more effective when:</p>
<ul>
<li><p>You want to find the first (or last) <code>TRUE</code>.</p>
</li>
<li><p>You have very few <code>TRUE</code>s and very many <code>FALSE</code>s; a set representation<br>may be faster and require less storage.</p>
</li>
</ul>
<p><code>which()</code> allows you to convert a boolean representation to an integer representation. Thereâs no reverse operation in base R but we can easily create one:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- sample(10) &lt; 4</span><br><span class="line">which(x)</span><br><span class="line"></span><br><span class="line">unwhich &lt;- function(x, n) &#123;</span><br><span class="line">  out &lt;- rep_len(FALSE, n)</span><br><span class="line">  out[x] &lt;- TRUE</span><br><span class="line">  out</span><br><span class="line">&#125;</span><br><span class="line">unwhich(which(x), 10)</span><br></pre></td></tr></table></figure>
<p>Letâs create two logical vectors and their integer equivalents and then explore the relationship between boolean and set operations.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(x1 &lt;- 1:10 %% 2 == 0)</span><br><span class="line">(x2 &lt;- which(x1))</span><br><span class="line">(y1 &lt;- 1:10 %% 5 == 0)</span><br><span class="line">(y2 &lt;- which(y1))</span><br><span class="line"></span><br><span class="line"># X &amp; Y &lt;-&gt; intersect(x, y)</span><br><span class="line">x1 &amp; y1</span><br><span class="line">intersect(x2, y2)</span><br><span class="line"></span><br><span class="line"># X | Y &lt;-&gt; union(x, y)</span><br><span class="line">x1 | y1</span><br><span class="line">union(x2, y2)</span><br><span class="line"></span><br><span class="line"># X &amp; !Y &lt;-&gt; setdiff(x, y)</span><br><span class="line">x1 &amp; !y1</span><br><span class="line">setdiff(x2, y2)</span><br><span class="line"></span><br><span class="line"># xor(X, Y) &lt;-&gt; setdiff(union(x, y), intersect(x, y))</span><br><span class="line">xor(x1, y1)</span><br><span class="line">setdiff(union(x2, y2), intersect(x2, y2))</span><br></pre></td></tr></table></figure>
<p>When first learning subsetting, a common mistake is to use <code>x[which(y)]</code> instead of <code>x[y]</code>.  Here the <code>which()</code> achieves nothing: it switches from logical to integer subsetting but the result will be exactly the same. Also beware that <code>x[-which(y)]</code> is <strong>not</strong> equivalent to <code>x[!y]</code>: if <code>y</code> is all FALSE, <code>which(y)</code> will be <code>integer(0)</code> and <code>-integer(0)</code> is still <code>integer(0)</code>, so youâll get no values, instead of all values. In general, avoid switching from logical to integer subsetting unless you want, for example, the first or last <code>TRUE</code> value.</p>
<h3 id="Exercises-6"><a href="#Exercises-6" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>How would you randomly permute the columns of a data frame? (This is an    important technique in random forests.) Can you simultaneously permute    the rows and columns in one step?</li>
<li>How would you select a random sample of <code>m</code> rows from a data frame?    What if the sample had to be contiguous (i.e., with an initial row, a    final row, and every row in between)?</li>
<li>How could you put the columns in a data frame in alphabetical order?</li>
</ol>
<h2 id="Answers-1"><a href="#Answers-1" class="headerlink" title="Answers"></a>Answers</h2><ol>
<li>Positive integers select elements at specific positions, negative integers    drop elements; logical vectors keep elements at positions corresponding to    <code>TRUE</code>; character vectors select elements with matching names.</li>
<li><code>[</code> selects sub-lists. It always returns a list; if you use it with a    single positive integer, it returns a list of length one. <code>[[</code> selects    an element within a list. <code>$</code> is a convenient shorthand: <code>x$y</code> is    equivalent to <code>x[[&quot;y&quot;]]</code>.</li>
<li>Use <code>drop = FALSE</code> if you are subsetting a matrix, array, or data frame    and you want to preserve the original dimensions. You should almost    always use it when subsetting inside a function.</li>
<li>If <code>x</code> is a matrix, <code>x[] &lt;- 0</code> will replace every element with 0,    keeping the same number of rows and columns. <code>x &lt;- 0</code> completely    replaces the matrix with the value 0.</li>
<li>A named character vector can act as a simple lookup table:    <code>c(x = 1, y = 2, z = 3)[c(&quot;y&quot;, &quot;z&quot;, &quot;x&quot;)]</code></li>
</ol>
<hr>
<h1 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary"></a><a href="id=&quot;vocabulary&quot;">Vocabulary</a></h1><p>An important part of being fluent in R is having a good working vocabulary. Below, I have listed the functions that I believe constitute such a vocabulary. You donât need to be intimately familiar with the details of every function, but you should at least be aware that they all exist. If there are functions in this list that youâve never heard of, I strongly recommend that you read their documentation.</p>
<p>I came up with this list by looking through all the functions in the base, stats, and utils packages, and extracting those that I think are most useful. The list also includes a few pointers to particularly important functions in other packages, and some of the more important <code>options()</code>.</p>
<h2 id="The-basics"><a href="#The-basics" class="headerlink" title="The basics"></a>The basics</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"># The first functions to learn</span><br><span class="line">?</span><br><span class="line">str</span><br><span class="line"></span><br><span class="line"># Important operators and assignment</span><br><span class="line">%in%, match</span><br><span class="line">=, &lt;-, &lt;&lt;-</span><br><span class="line">$, [, [[, head, tail, subset</span><br><span class="line">with</span><br><span class="line">assign, get</span><br><span class="line"></span><br><span class="line"># Comparison</span><br><span class="line">all.equal, identical</span><br><span class="line">!=, ==, &gt;, &gt;=, &lt;, &lt;=</span><br><span class="line">is.na, complete.cases</span><br><span class="line">is.finite</span><br><span class="line"></span><br><span class="line"># Basic math</span><br><span class="line">*, +, -, /, ^, %%, %/%</span><br><span class="line">abs, sign</span><br><span class="line">acos, asin, atan, atan2</span><br><span class="line">sin, cos, tan</span><br><span class="line">ceiling, floor, round, trunc, signif</span><br><span class="line">exp, log, log10, log2, sqrt</span><br><span class="line"></span><br><span class="line">max, min, prod, sum</span><br><span class="line">cummax, cummin, cumprod, cumsum, diff</span><br><span class="line">pmax, pmin</span><br><span class="line">range</span><br><span class="line">mean, median, cor, sd, var</span><br><span class="line">rle</span><br><span class="line"></span><br><span class="line"># Functions to do with functions</span><br><span class="line">function</span><br><span class="line">missing</span><br><span class="line">on.exit</span><br><span class="line">return, invisible</span><br><span class="line"></span><br><span class="line"># Logical &amp; sets</span><br><span class="line">&amp;, |, !, xor</span><br><span class="line">all, any</span><br><span class="line">intersect, union, setdiff, setequal</span><br><span class="line">which</span><br><span class="line"></span><br><span class="line"># Vectors and matrices</span><br><span class="line">c, matrix</span><br><span class="line"># automatic coercion rules character &gt; numeric &gt; logical</span><br><span class="line">length, dim, ncol, nrow</span><br><span class="line">cbind, rbind</span><br><span class="line">names, colnames, rownames</span><br><span class="line">t</span><br><span class="line">diag</span><br><span class="line">sweep</span><br><span class="line">as.matrix, data.matrix</span><br><span class="line"></span><br><span class="line"># Making vectors</span><br><span class="line">c</span><br><span class="line">rep, rep_len</span><br><span class="line">seq, seq_len, seq_along</span><br><span class="line">rev</span><br><span class="line">sample</span><br><span class="line">choose, factorial, combn</span><br><span class="line">(is/as).(character/numeric/logical/...)</span><br><span class="line"></span><br><span class="line"># Lists &amp; data.frames</span><br><span class="line">list, unlist</span><br><span class="line">data.frame, as.data.frame</span><br><span class="line">split</span><br><span class="line">expand.grid</span><br><span class="line"></span><br><span class="line"># Control flow</span><br><span class="line">if, &amp;&amp;, || (short circuiting)</span><br><span class="line">for, while</span><br><span class="line">next, break</span><br><span class="line">switch</span><br><span class="line">ifelse</span><br><span class="line"></span><br><span class="line"># Apply &amp; friends</span><br><span class="line">lapply, sapply, vapply</span><br><span class="line">apply</span><br><span class="line">tapply</span><br><span class="line">replicate</span><br></pre></td></tr></table></figure>
<h2 id="Common-data-structures"><a href="#Common-data-structures" class="headerlink" title="Common data structures"></a>Common data structures</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Date time</span><br><span class="line">ISOdate, ISOdatetime, strftime, strptime, date</span><br><span class="line">difftime</span><br><span class="line">julian, months, quarters, weekdays</span><br><span class="line">library(lubridate)</span><br><span class="line"></span><br><span class="line"># Character manipulation</span><br><span class="line">grep, agrep</span><br><span class="line">gsub</span><br><span class="line">strsplit</span><br><span class="line">chartr</span><br><span class="line">nchar</span><br><span class="line">tolower, toupper</span><br><span class="line">substr</span><br><span class="line">paste</span><br><span class="line">library(stringr)</span><br><span class="line"></span><br><span class="line"># Factors</span><br><span class="line">factor, levels, nlevels</span><br><span class="line">reorder, relevel</span><br><span class="line">cut, findInterval</span><br><span class="line">interaction</span><br><span class="line">options(stringsAsFactors = FALSE)</span><br><span class="line"></span><br><span class="line"># Array manipulation</span><br><span class="line">array</span><br><span class="line">dim</span><br><span class="line">dimnames</span><br><span class="line">aperm</span><br><span class="line">library(abind)</span><br></pre></td></tr></table></figure>
<h2 id="Statistics"><a href="#Statistics" class="headerlink" title="Statistics"></a>Statistics</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Ordering and tabulating</span><br><span class="line">duplicated, unique</span><br><span class="line">merge</span><br><span class="line">order, rank, quantile</span><br><span class="line">sort</span><br><span class="line">table, ftable</span><br><span class="line"></span><br><span class="line"># Linear models</span><br><span class="line">fitted, predict, resid, rstandard</span><br><span class="line">lm, glm</span><br><span class="line">hat, influence.measures</span><br><span class="line">logLik, df, deviance</span><br><span class="line">formula, ~, I</span><br><span class="line">anova, coef, confint, vcov</span><br><span class="line">contrasts</span><br><span class="line"></span><br><span class="line"># Miscellaneous tests</span><br><span class="line">apropos(&quot;\\.test$&quot;)</span><br><span class="line"></span><br><span class="line"># Random variables</span><br><span class="line">(q, p, d, r) * (beta, binom, cauchy, chisq, exp, f, gamma, geom,</span><br><span class="line">  hyper, lnorm, logis, multinom, nbinom, norm, pois, signrank, t,</span><br><span class="line">  unif, weibull, wilcox, birthday, tukey)</span><br><span class="line"></span><br><span class="line"># Matrix algebra</span><br><span class="line">crossprod, tcrossprod</span><br><span class="line">eigen, qr, svd</span><br><span class="line">%*%, %o%, outer</span><br><span class="line">rcond</span><br><span class="line">solve</span><br></pre></td></tr></table></figure>
<h2 id="Working-with-R"><a href="#Working-with-R" class="headerlink" title="Working with R"></a>Working with R</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Workspace</span><br><span class="line">ls, exists, rm</span><br><span class="line">getwd, setwd</span><br><span class="line">q</span><br><span class="line">source</span><br><span class="line">install.packages, library, require</span><br><span class="line"></span><br><span class="line"># Help</span><br><span class="line">help, ?</span><br><span class="line">help.search</span><br><span class="line">apropos</span><br><span class="line">RSiteSearch</span><br><span class="line">citation</span><br><span class="line">demo</span><br><span class="line">example</span><br><span class="line">vignette</span><br><span class="line"></span><br><span class="line"># Debugging</span><br><span class="line">traceback</span><br><span class="line">browser</span><br><span class="line">recover</span><br><span class="line">options(error = )</span><br><span class="line">stop, warning, message</span><br><span class="line">tryCatch, try</span><br></pre></td></tr></table></figure>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Output</span><br><span class="line">print, cat</span><br><span class="line">message, warning</span><br><span class="line">dput</span><br><span class="line">format</span><br><span class="line">sink, capture.output</span><br><span class="line"></span><br><span class="line"># Reading and writing data</span><br><span class="line">data</span><br><span class="line">count.fields</span><br><span class="line">read.csv, write.csv</span><br><span class="line">read.delim, write.delim</span><br><span class="line">read.fwf</span><br><span class="line">readLines, writeLines</span><br><span class="line">readRDS, saveRDS</span><br><span class="line">load, save</span><br><span class="line">library(foreign)</span><br><span class="line"></span><br><span class="line"># Files and directories</span><br><span class="line">dir</span><br><span class="line">basename, dirname, tools::file_ext</span><br><span class="line">file.path</span><br><span class="line">path.expand, normalizePath</span><br><span class="line">file.choose</span><br><span class="line">file.copy, file.create, file.remove, file.rename, dir.create</span><br><span class="line">file.exists, file.info</span><br><span class="line">tempdir, tempfile</span><br><span class="line">download.file, library(downloader)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Style-guide"><a href="#Style-guide" class="headerlink" title="Style guide"></a><a href="id=&quot;style&quot;">Style guide</a></h1><p>Good coding style is like using correct punctuation. You can manage without it, but it sure makes things easier to read. As with styles of punctuation, there are many possible variations. The following guide describes the style that I use (in this book and elsewhere). It is based on Googleâs <a href="http://google-styleguide.googlecode.com/svn/trunk/google-r-style.html" target="_blank" rel="external">R style guide</a>, with a few tweaks. You donât have to use my style, but you really should use a consistent style.</p>
<p>Good style is important because while your code only has one author, itâll usually have multiple readers. This is especially true when youâre writing code with others. In that case, itâs a good idea to agree on a common style up-front. Since no style is strictly better than another, working with others may mean that youâll need to sacrifice some preferred aspects of your style.</p>
<p>The formatR package, by Yihui Xie, makes it easier to clean up poorly formatted code. It canât do everything, but it can quickly get your code from terrible to pretty good. Make sure to read <a href="http://yihui.name/formatR/" target="_blank" rel="external">the introduction</a> before using it.</p>
<h2 id="Notation-and-naming"><a href="#Notation-and-naming" class="headerlink" title="Notation and naming"></a>Notation and naming</h2><h3 id="File-names"><a href="#File-names" class="headerlink" title="File names"></a>File names</h3><p>File names should be meaningful and end in <code>.R</code>.</p>
<pre><code># Good
fit-models.R
utility-functions.R

# Bad
foo.r
stuff.r
</code></pre><p>If files need to be run in sequence, prefix them with numbers:</p>
<pre><code>0-download.R
1-parse.R
2-explore.R
</code></pre><h3 id="Object-names"><a href="#Object-names" class="headerlink" title="Object names"></a>Object names</h3><blockquote>
<p>âThere are only two hard things in Computer Science: cache invalidation and<br>naming things.â</p>
<p>â Phil Karlton</p>
</blockquote>
<p>Variable and function names should be lowercase. Use an underscore (<code>_</code>) to separate words within a name. Generally, variable names should be nouns and function names should be verbs. Strive for names that are concise and meaningful (this is not easy!).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Good</span><br><span class="line">day_one</span><br><span class="line">day_1</span><br><span class="line"></span><br><span class="line"># Bad</span><br><span class="line">first_day_of_the_month</span><br><span class="line">DayOne</span><br><span class="line">dayone</span><br><span class="line">djm1</span><br></pre></td></tr></table></figure>
<p>Where possible, avoid using names of existing functions and variables. This will cause confusion for the readers of your code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Bad</span><br><span class="line">T &lt;- FALSE</span><br><span class="line">c &lt;- 10</span><br><span class="line">mean &lt;- function(x) sum(x)</span><br></pre></td></tr></table></figure>
<h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><h3 id="Spacing"><a href="#Spacing" class="headerlink" title="Spacing"></a>Spacing</h3><p>Place spaces around all infix operators (<code>=</code>, <code>+</code>, <code>-</code>, <code>&lt;-</code>, etc.). The same rule applies when using <code>=</code> in function calls. Always put a space after a comma, and never before (just like in regular English).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Good</span><br><span class="line">average &lt;- mean(feet / 12 + inches, na.rm = TRUE)</span><br><span class="line"></span><br><span class="line"># Bad</span><br><span class="line">average&lt;-mean(feet/12+inches,na.rm=TRUE)</span><br></pre></td></tr></table></figure>
<p>Thereâs a small exception to this rule: <code>:</code>, <code>::</code> and <code>:::</code> donât need spaces around them.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Good</span><br><span class="line">x &lt;- 1:10</span><br><span class="line">base::get</span><br><span class="line"></span><br><span class="line"># Bad</span><br><span class="line">x &lt;- 1 : 10</span><br><span class="line">base :: get</span><br></pre></td></tr></table></figure>
<p>Place a space before left parentheses, except in a function call.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Good</span><br><span class="line">if (debug) do(x)</span><br><span class="line">plot(x, y)</span><br><span class="line"></span><br><span class="line"># Bad</span><br><span class="line">if(debug)do(x)</span><br><span class="line">plot (x, y)</span><br></pre></td></tr></table></figure>
<p>Extra spacing (i.e., more than one space in a row) is ok if it improves alignment of equal signs or assignments (<code>&lt;-</code>).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list(</span><br><span class="line">  total = a + b + c,</span><br><span class="line">  mean  = (a + b + c) / n</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Do not place spaces around code in parentheses or square brackets (unless thereâs a comma, in which case see above).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Good</span><br><span class="line">if (debug) do(x)</span><br><span class="line">diamonds[5, ]</span><br><span class="line"></span><br><span class="line"># Bad</span><br><span class="line">if ( debug ) do(x)  # No spaces around debug</span><br><span class="line">x[1,]   # Needs a space after the comma</span><br><span class="line">x[1 ,]  # Space goes after comma not before</span><br></pre></td></tr></table></figure>
<h3 id="Curly-braces"><a href="#Curly-braces" class="headerlink" title="Curly braces"></a>Curly braces</h3><p>An opening curly brace should never go on its own line and should always be followed by a new line. A closing curly brace should always go on its own line, unless itâs followed by <code>else</code>.</p>
<p>Always indent the code inside curly braces.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Good</span><br><span class="line"></span><br><span class="line">if (y &lt; 0 &amp;&amp; debug) &#123;</span><br><span class="line">  message(&quot;Y is negative&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (y == 0) &#123;</span><br><span class="line">  log(x)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  y ^ x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Bad</span><br><span class="line"></span><br><span class="line">if (y &lt; 0 &amp;&amp; debug)</span><br><span class="line">message(&quot;Y is negative&quot;)</span><br><span class="line"></span><br><span class="line">if (y == 0) &#123;</span><br><span class="line">  log(x)</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  y ^ x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Itâs ok to leave very short statements on the same line:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (y &lt; 0 &amp;&amp; debug) message(&quot;Y is negative&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="Line-length"><a href="#Line-length" class="headerlink" title="Line length"></a>Line length</h3><p>Strive to limit your code to 80 characters per line. This fits comfortably on a printed page with a reasonably sized font. If you find yourself running out of room, this is a good indication that you should encapsulate some of the work in a separate function.</p>
<h3 id="Indentation"><a href="#Indentation" class="headerlink" title="Indentation"></a>Indentation</h3><p>When indenting your code, use two spaces. Never use tabs or mix tabs and spaces.</p>
<p>The only exception is if a function definition runs over multiple lines. In that case, indent the second line to where the definition starts:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long_function_name &lt;- function(a = &quot;a long argument&quot;,</span><br><span class="line">                               b = &quot;another argument&quot;,</span><br><span class="line">                               c = &quot;another long argument&quot;) &#123;</span><br><span class="line">  # As usual code is indented by two spaces.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h3><p>Use <code>&lt;-</code>, not <code>=</code>, for assignment.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Good</span><br><span class="line">x &lt;- 5</span><br><span class="line"># Bad</span><br><span class="line">x = 5</span><br></pre></td></tr></table></figure>
<h2 id="Organisation"><a href="#Organisation" class="headerlink" title="Organisation"></a>Organisation</h2><h3 id="Commenting-guidelines"><a href="#Commenting-guidelines" class="headerlink" title="Commenting guidelines"></a>Commenting guidelines</h3><p>Comment your code. Each line of a comment should begin with the comment symbol and a single space: <code>#</code>. Comments should explain the why, not the what.</p>
<p>Use commented lines of <code>-</code> and <code>=</code> to break up your file into easily readable chunks.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Load data ---------------------------</span><br><span class="line"></span><br><span class="line"># Plot data ---------------------------</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><p>Functions are a fundamental building block of R: to master many of the more advanced techniques in this book, you need a solid foundation in how functions work. Youâve probably already created many R functions, and youâre familiar with the basics of how they work. The focus of this chapter is to turn your existing, informal knowledge of functions into a rigorous understanding of what functions are and how they work. Youâll see some interesting tricks and techniques in this chapter, but most of what youâll learn will be more important as the building blocks for more advanced techniques.</p>
<p>The most important thing to understand about R is that functions are objects in their own right. You can work with them exactly the same way you work with any other type of object. This theme will be explored in depth in <a href="#functional-programming">functional programming</a>.</p>
<h5 id="Quiz-2"><a href="#Quiz-2" class="headerlink" title="Quiz"></a>Quiz</h5><p>Answer the following questions to see if you can safely skip this chapter. You can find the answers at the end of the chapter in <a href="#function-answers">answers</a>.</p>
<ol>
<li>What are the three components of a function?</li>
<li><p>What does the following code return?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 10</span><br><span class="line">f1 &lt;- function(x) &#123;</span><br><span class="line">  function() &#123;</span><br><span class="line">    x + 10</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1(1)()</span><br></pre></td></tr></table></figure>
</li>
<li><p>How would you more typically write this code?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`+`(1, `*`(2, 3))</span><br></pre></td></tr></table></figure>
</li>
<li><p>How could you make this call easier to read?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mean(, TRUE, x = c(1:10, NA))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Does the following function throw an error when called? Why/why not?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f2 &lt;- function(a, b) &#123;</span><br><span class="line">  a * 10</span><br><span class="line">&#125;</span><br><span class="line">f2(10, stop(&quot;This is an error!&quot;))</span><br></pre></td></tr></table></figure>
</li>
<li><p>What is an infix function? How do you write it? Whatâs a replacement    function? How do you write it?</p>
</li>
<li>What function do you use to ensure that a cleanup action occurs    regardless of how a function terminates?</li>
</ol>
<h5 id="Outline-2"><a href="#Outline-2" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#function-components">Function components</a> describes the three main  components of a function.</li>
<li><a href="#lexical-scoping">Lexical scoping</a> teaches you how R finds values from  names, the process of lexical scoping.</li>
<li><a href="#all-calls">Every operation is a function call</a> shows you that everything  that happens in R is a result of a function call, even if it doesnât look  like it.</li>
<li><a href="#function-arguments">Function arguments</a> discusses the three ways of  supplying arguments to a function, how to call a function given a list of  arguments, and the impact of lazy evaluation.</li>
<li><a href="#special-calls">Special calls</a> describes two special types of function:  infix and replacement functions.</li>
<li><a href="#return-values">Return values</a> discusses how and when functions return  values, and how you can ensure that a function does something before it  exits.</li>
</ul>
<h5 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><p>The only package youâll need is <code>pryr</code>, which is used to explore what happens when modifying vectors in place. Install it with <code>install.packages(&quot;pryr&quot;)</code>.</p>
<h2 id="Function-components"><a href="#Function-components" class="headerlink" title="Function components"></a><a href="id=&quot;function-components&quot;">Function components</a></h2><p>All R functions have three parts:</p>
<ul>
<li>the <code>body()</code>, the code inside the function.</li>
<li>the <code>formals()</code>, the list of arguments which controls how you can call the function.</li>
<li>the <code>environment()</code>, the âmapâ of the location of the functionâs variables.</li>
</ul>
<p>When you print a function in R, it shows you these three important components. If the environment isnât displayed, it means that the function was created in the global environment.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) x^2</span><br><span class="line">f</span><br><span class="line">#&gt; function(x) x^2</span><br><span class="line"></span><br><span class="line">formals(f)</span><br><span class="line">#&gt; $x</span><br><span class="line">body(f)</span><br><span class="line">#&gt; x^2</span><br><span class="line">environment(f)</span><br><span class="line">#&gt; &lt;environment: R_GlobalEnv&gt;</span><br></pre></td></tr></table></figure>
<p>The assignment forms of <code>body()</code>, <code>formals()</code>, and <code>environment()</code> can also be used to modify functions.</p>
<p>Like all objects in R, functions can also possess any number of additional <code>attributes()</code>. One attribute used by base R is âsrcrefâ, short for source reference, which points to the source code used to create the function. Unlike <code>body()</code>, this contains code comments and other formatting. You can also add attributes to a function. For example, you can set the <code>class()</code> and add a custom <code>print()</code> method.</p>
<h3 id="Primitive-functions"><a href="#Primitive-functions" class="headerlink" title="Primitive functions"></a>Primitive functions</h3><p>There is one exception to the rule that functions have three components. Primitive functions, like <code>sum()</code>, call C code directly with <code>.Primitive()</code> and contain no R code. Therefore their <code>formals()</code>, <code>body()</code>, and <code>environment()</code> are all <code>NULL</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum</span><br><span class="line">formals(sum)</span><br><span class="line">body(sum)</span><br><span class="line">environment(sum)</span><br></pre></td></tr></table></figure>
<p>Primitive functions are only found in the <code>base</code> package, and since they operate at a low level, they can be more efficient (primitive replacement functions donât have to make copies), and can have different rules for argument matching (e.g., <code>switch</code> and <code>call</code>).  This, however, comes at a cost of behaving differently from all other functions in R. Hence the R core team generally avoids creating them unless there is no other option.</p>
<h3 id="Exercises-7"><a href="#Exercises-7" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>What function allows you to tell if an object is a function? What function    allows you to tell if a function is a primitive function?</li>
<li><p>This code makes a list of all functions in the base package.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objs &lt;- mget(ls(&quot;package:base&quot;), inherits = TRUE)</span><br><span class="line">funs &lt;- Filter(is.function, objs)</span><br></pre></td></tr></table></figure>
<p>Use it to answer the following questions:</p>
<p>a. Which base function has the most arguments?</p>
<p>a. How many base functions have no arguments? Whatâs special about those<br>   functions?</p>
<p>a. How could you adapt the code to find all primitive functions?</p>
</li>
<li><p>What are the three important components of a function?</p>
</li>
<li>When does printing a function not show what environment it was created in?</li>
</ol>
<h2 id="Lexical-scoping"><a href="#Lexical-scoping" class="headerlink" title="Lexical scoping"></a><a href="id=&quot;lexical-scoping&quot;">Lexical scoping</a></h2><p>Scoping is the set of rules that govern how R looks up the value of a symbol. In the example below, scoping is the set of rules that R applies to go from the symbol <code>x</code> to its value <code>10</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 10</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<p>Understanding scoping allows you to:</p>
<ul>
<li><p>build tools by composing functions, as described in  <a href="#functional-programming">functional programming</a>.</p>
</li>
<li><p>overrule the usual evaluation rules and do non-standard evaluation, as  described in <a href="#nse">non-standard evaluation</a>.</p>
</li>
</ul>
<p>R has two types of scoping: <strong>lexical scoping</strong>, implemented automatically at the language level, and <strong>dynamic scoping</strong>, used in select functions to save typing during interactive analysis. We discuss lexical scoping here because it is intimately tied to function creation. Dynamic scoping is described in more detail in <a href="#scoping-issues">scoping issues</a>.</p>
<p>Lexical scoping looks up symbol values based on how functions were nested when they were created, not how they are nested when they are called. With lexical scoping, you donât need to know how the function is called to figure out where the value of a variable will be looked up. You just need to look at the functionâs definition.</p>
<p>The âlexicalâ in lexical scoping doesnât correspond to the usual English definition (âof or relating to words or the vocabulary of a language as distinguished from its grammar and constructionâ) but comes from the computer science term âlexingâ, which is part of the process that converts code represented as text to meaningful pieces that the programming language understands.</p>
<p>There are four basic principles behind Râs implementation of lexical scoping:</p>
<ul>
<li>name masking</li>
<li>functions vs. variables</li>
<li>a fresh start</li>
<li>dynamic lookup</li>
</ul>
<p>You probably know many of these principles already, although you might not have thought about them explicitly. Test your knowledge by mentally running through the code in each block before looking at the answers.</p>
<h3 id="Name-masking"><a href="#Name-masking" class="headerlink" title="Name masking"></a>Name masking</h3><p>The following example illustrates the most basic principle of lexical scoping, and you should have no problem predicting the output.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function() &#123;</span><br><span class="line">  x &lt;- 1</span><br><span class="line">  y &lt;- 2</span><br><span class="line">  c(x, y)</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">rm(f)</span><br></pre></td></tr></table></figure>
<p>If a name isnât defined inside a function, R will look one level up.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 2</span><br><span class="line">g &lt;- function() &#123;</span><br><span class="line">  y &lt;- 1</span><br><span class="line">  c(x, y)</span><br><span class="line">&#125;</span><br><span class="line">g()</span><br><span class="line">rm(x, g)</span><br></pre></td></tr></table></figure>
<p>The same rules apply if a function is defined inside another function: look inside the current function, then where that function was defined, and so on, all the way up to the global environment, and then on to other loaded packages. Run the following code in your head, then confirm the output by running the R code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1</span><br><span class="line">h &lt;- function() &#123;</span><br><span class="line">  y &lt;- 2</span><br><span class="line">  i &lt;- function() &#123;</span><br><span class="line">    z &lt;- 3</span><br><span class="line">    c(x, y, z)</span><br><span class="line">  &#125;</span><br><span class="line">  i()</span><br><span class="line">&#125;</span><br><span class="line">h()</span><br><span class="line">rm(x, h)</span><br></pre></td></tr></table></figure>
<p>The same rules apply to closures, functions created by other functions. Closures will be described in more detail in <a href="#functional-programming">functional programming</a>; here weâll just look at how they interact with scoping. The following function, <code>j()</code>, returns a function.  What do you think this function will return when we call it?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">j &lt;- function(x) &#123;</span><br><span class="line">  y &lt;- 2</span><br><span class="line">  function() &#123;</span><br><span class="line">    c(x, y)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">k &lt;- j(1)</span><br><span class="line">k()</span><br><span class="line">rm(j, k)</span><br></pre></td></tr></table></figure>
<p>This seems a little magical (how does R know what the value of <code>y</code> is after the function has been called). It works because <code>k</code> preserves the environment in which it was defined and because the environment includes the value of <code>y</code>. <a href="#environments">Environments</a> gives some pointers on how you can dive in and figure out what values are stored in the environment associated with each function.</p>
<h3 id="Functions-vs-variables"><a href="#Functions-vs-variables" class="headerlink" title="Functions vs. variables"></a>Functions vs. variables</h3><p>The same principles apply regardless of the type of associated value â finding functions works exactly the same way as finding variables:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l &lt;- function(x) x + 1</span><br><span class="line">m &lt;- function() &#123;</span><br><span class="line">  l &lt;- function(x) x * 2</span><br><span class="line">  l(10)</span><br><span class="line">&#125;</span><br><span class="line">m()</span><br><span class="line">rm(l, m)</span><br></pre></td></tr></table></figure>
<p>For functions, there is one small tweak to the rule. If you are using a name in a context where itâs obvious that you want a function (e.g., <code>f(3)</code>), R will ignore objects that are not functions while it is searching. In the following example <code>n</code> takes on a different value depending on whether R is looking for a function or a variable.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n &lt;- function(x) x / 2</span><br><span class="line">o &lt;- function() &#123;</span><br><span class="line">  n &lt;- 10</span><br><span class="line">  n(n)</span><br><span class="line">&#125;</span><br><span class="line">o()</span><br><span class="line">rm(n, o)</span><br></pre></td></tr></table></figure>
<p>However, using the same name for functions and other objects will make for confusing code, and is generally best avoided.</p>
<h3 id="A-fresh-start"><a href="#A-fresh-start" class="headerlink" title="A fresh start"></a><a href="id=&quot;fresh-start&quot;">A fresh start</a></h3><p>What happens to the values in between invocations of a function? What will happen the first time you run this function? What will happen the second time? (If you havenât seen <code>exists()</code> before: it returns <code>TRUE</code> if thereâs a variable of that name, otherwise it returns <code>FALSE</code>.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">j &lt;- function() &#123;</span><br><span class="line">  if (!exists(&quot;a&quot;)) &#123;</span><br><span class="line">    a &lt;- 1</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    a &lt;- a + 1</span><br><span class="line">  &#125;</span><br><span class="line">  print(a)</span><br><span class="line">&#125;</span><br><span class="line">j()</span><br><span class="line">rm(j)</span><br></pre></td></tr></table></figure>
<p>You might be surprised that it returns the same value, <code>1</code>, every time. This is because every time a function is called, a new environment is created to host execution. A function has no way to tell what happened the last time it was run; each invocation is completely independent. (Weâll see some ways to get around this in <a href="#mutable-state">mutable state</a>.)</p>
<h3 id="Dynamic-lookup"><a href="#Dynamic-lookup" class="headerlink" title="Dynamic lookup"></a>Dynamic lookup</h3><p>Lexical scoping determines where to look for values, not when to look for them. R looks for values when the function is run, not when itâs created. This means that the output of a function can be different depending on objects outside its environment:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function() x</span><br><span class="line">x &lt;- 15</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line">x &lt;- 20</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>You generally want to avoid this behaviour because it means the function is no longer self-contained. This is a common error â if you make a spelling mistake in your code, you wonât get an error when you create the function, and you might not even get one when you run the function, depending on what variables are defined in the global environment.</p>
<p>One way to detect this problem is the <code>findGlobals()</code> function from <code>codetools</code>. This function lists all the external dependencies of a function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function() x + 1</span><br><span class="line">codetools::findGlobals(f)</span><br></pre></td></tr></table></figure>
<p>Another way to try and solve the problem would be to manually change the environment of the function to the <code>emptyenv()</code>, an environment which contains absolutely nothing:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">environment(f) &lt;- emptyenv()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>This doesnât work because R relies on lexical scoping to find <em>everything</em>, even the <code>+</code> operator. Itâs never possible to make a function completely self-contained because you must always rely on functions defined in base R or other packages.</p>
<p>You can use this same idea to do other things that are extremely ill-advised. For example, since all of the standard operators in R are functions, you can override them with your own alternatives.  If you ever are feeling particularly evil, run the following code while your friend is away from their computer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">`(` &lt;- function(e1) &#123;</span><br><span class="line">  if (is.numeric(e1) &amp;&amp; runif(1) &lt; 0.1) &#123;</span><br><span class="line">    e1 + 1</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    e1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">replicate(50, (1 + 2))</span><br><span class="line">rm(&quot;(&quot;)</span><br></pre></td></tr></table></figure>
<p>This will introduce a particularly pernicious bug: 10% of the time, 1 will be added to any numeric calculation inside parentheses. This is another good reason to regularly restart with a clean R session!</p>
<h3 id="Exercises-8"><a href="#Exercises-8" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>What does the following code return? Why? What does each of the three <code>c</code>âs mean?</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c &lt;- 10</span><br><span class="line">c(c = c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>What are the four principles that govern how R looks for values?</p>
</li>
<li><p>What does the following function return? Make a prediction before   running the code yourself.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) &#123;</span><br><span class="line">  f &lt;- function(x) &#123;</span><br><span class="line">    f &lt;- function(x) &#123;</span><br><span class="line">      x ^ 2</span><br><span class="line">    &#125;</span><br><span class="line">    f(x) + 1</span><br><span class="line">  &#125;</span><br><span class="line">  f(x) * 2</span><br><span class="line">&#125;</span><br><span class="line">f(10)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Every-operation-is-a-function-call"><a href="#Every-operation-is-a-function-call" class="headerlink" title="Every operation is a function call"></a><a href="id=&quot;all-calls&quot;">Every operation is a function call</a></h2><blockquote>
<p>âTo understand computations in R, two slogans are helpful:</p>
<ul>
<li>Everything that exists is an object.</li>
<li>Everything that happens is a function call.â</li>
</ul>
<p>â John Chambers</p>
</blockquote>
<p>The previous example of redefining <code>(</code> works because every operation in R is a function call, whether or not it looks like one. This includes infix operators like <code>+</code>, control flow operators like <code>for</code>, <code>if</code>, and <code>while</code>, subsetting operators like <code>[]</code> and <code>$</code>, and even the curly brace <code>{</code>. This means that each pair of statements in the following example is exactly equivalent.  Note that <code>` </code>, the backtick, lets you refer to functions or variables that have otherwise reserved or illegal names:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 10; y &lt;- 5</span><br><span class="line">x + y</span><br><span class="line">`+`(x, y)</span><br><span class="line"></span><br><span class="line">for (i in 1:2) print(i)</span><br><span class="line">`for`(i, 1:2, print(i))</span><br><span class="line"></span><br><span class="line">if (i == 1) print(&quot;yes!&quot;) else print(&quot;no.&quot;)</span><br><span class="line">`if`(i == 1, print(&quot;yes!&quot;), print(&quot;no.&quot;))</span><br><span class="line"></span><br><span class="line">x[3]</span><br><span class="line">`[`(x, 3)</span><br><span class="line"></span><br><span class="line">&#123; print(1); print(2); print(3) &#125;</span><br><span class="line">`&#123;`(print(1), print(2), print(3))</span><br></pre></td></tr></table></figure>
<p>It is possible to override the definitions of these special functions, but this is almost certainly a bad idea. However, there are occasions when it might be useful: it allows you to do something that would have otherwise been impossible. For example, this feature makes it possible for the <code>dplyr</code> package to translate R expressions into SQL expressions. <a href="#dsl">Domain specific languages</a> uses this idea to create domain specific languages that allow you to concisely express new concepts using existing R constructs.</p>
<p>Itâs more often useful to treat special functions as ordinary functions. For example, we could use <code>sapply()</code> to add 3 to every element of a list by first defining a function <code>add()</code>, like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add &lt;- function(x, y) x + y</span><br><span class="line">sapply(1:10, add, 3)</span><br></pre></td></tr></table></figure>
<p>But we can also get the same effect using the built-in <code>+</code> function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sapply(1:5, `+`, 3)</span><br><span class="line">sapply(1:5, &quot;+&quot;, 3)</span><br></pre></td></tr></table></figure>
<p>Note the difference between <code>`+` </code> and <code>&quot;+&quot;</code>.  The first one is the value of the object called <code>+</code>, and the second is a string containing the character <code>+</code>.  The second version works because <code>sapply</code> can be given the name of a function instead of the function itself: if you read the source of <code>sapply()</code>, youâll see the first line uses <code>match.fun()</code> to find functions given their names.</p>
<p>A more useful application is to combine <code>lapply()</code> or <code>sapply()</code> with subsetting:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- list(1:3, 4:9, 10:12)</span><br><span class="line">sapply(x, &quot;[&quot;, 2)</span><br><span class="line"></span><br><span class="line"># equivalent to</span><br><span class="line">sapply(x, function(x) x[2])</span><br></pre></td></tr></table></figure>
<p>Remembering that everything that happens in R is a function call will help you in <a href="#metaprogramming">metaprogramming</a>.</p>
<h2 id="Function-arguments"><a href="#Function-arguments" class="headerlink" title="Function arguments"></a><a href="id=&quot;function-arguments&quot;">Function arguments</a></h2><p>Itâs useful to distinguish between the formal arguments and the actual arguments of a function. The formal arguments are a property of the function, whereas the actual or calling arguments can vary each time you call the function. This section discusses how calling arguments are mapped to formal arguments, how you can call a function given a list of arguments, how default arguments work, and the impact of lazy evaluation.</p>
<h3 id="Calling-functions"><a href="#Calling-functions" class="headerlink" title="Calling functions"></a>Calling functions</h3><p>When calling a function you can specify arguments by position, by complete name, or by partial name. Arguments are matched first by exact name (perfect matching), then by prefix matching, and finally by position.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(abcdef, bcde1, bcde2) &#123;</span><br><span class="line">  list(a = abcdef, b1 = bcde1, b2 = bcde2)</span><br><span class="line">&#125;</span><br><span class="line">str(f(1, 2, 3))</span><br><span class="line">str(f(2, 3, abcdef = 1))</span><br><span class="line"></span><br><span class="line"># Can abbreviate long argument names:</span><br><span class="line">str(f(2, 3, a = 1))</span><br><span class="line"></span><br><span class="line"># But this doesn&apos;t work because abbreviation is ambiguous</span><br><span class="line">str(f(1, 3, b = 1))</span><br></pre></td></tr></table></figure>
<p>Generally, you only want to use positional matching for the first one or two arguments; they will be the most commonly used, and most readers will know what they are. Avoid using positional matching for less commonly used arguments, and only use readable abbreviations with partial matching. (If you are writing code for a package that you want to publish on CRAN you can not use partial matching, and must use complete names.) Named arguments should always come after unnamed arguments. If a function uses <code>...</code> (discussed in more detail below), you can only specify arguments listed after <code>...</code> with their full name.</p>
<p>These are good calls:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mean(1:10)</span><br><span class="line">mean(1:10, trim = 0.05)</span><br></pre></td></tr></table></figure>
<p>This is probably overkill:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mean(x = 1:10)</span><br></pre></td></tr></table></figure>
<p>And these are just confusing:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mean(1:10, n = T)</span><br><span class="line">mean(1:10, , FALSE)</span><br><span class="line">mean(1:10, 0.05)</span><br><span class="line">mean(, TRUE, x = c(1:10, NA))</span><br></pre></td></tr></table></figure>
<h3 id="Calling-a-function-given-a-list-of-arguments"><a href="#Calling-a-function-given-a-list-of-arguments" class="headerlink" title="Calling a function given a list of arguments"></a>Calling a function given a list of arguments</h3><p>Suppose you had a list of function arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args &lt;- list(1:10, na.rm = TRUE)</span><br></pre></td></tr></table></figure>
<p>How could you then send that list to <code>mean()</code>?  You need <code>do.call()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do.call(mean, list(1:10, na.rm = TRUE))</span><br><span class="line"># Equivalent to</span><br><span class="line">mean(1:10, na.rm = TRUE)</span><br></pre></td></tr></table></figure>
<h3 id="Default-and-missing-arguments"><a href="#Default-and-missing-arguments" class="headerlink" title="Default and missing arguments"></a>Default and missing arguments</h3><p>Function arguments in R can have default values.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(a = 1, b = 2) &#123;</span><br><span class="line">  c(a, b)</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>Since arguments in R are evaluated lazily (more on that below), the default value can be defined in terms of other arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g &lt;- function(a = 1, b = a * 2) &#123;</span><br><span class="line">  c(a, b)</span><br><span class="line">&#125;</span><br><span class="line">g()</span><br><span class="line">g(10)</span><br></pre></td></tr></table></figure>
<p>Default arguments can even be defined in terms of variables created within the function. This is used frequently in base R functions, but I think it is bad practice, because you canât understand what the default values will be without reading the complete source code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h &lt;- function(a = 1, b = d) &#123;</span><br><span class="line">  d &lt;- (a + 1) ^ 2</span><br><span class="line">  c(a, b)</span><br><span class="line">&#125;</span><br><span class="line">h()</span><br><span class="line">h(10)</span><br></pre></td></tr></table></figure>
<p>You can determine if an argument was supplied or not with the <code>missing()</code> function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i &lt;- function(a, b) &#123;</span><br><span class="line">  c(missing(a), missing(b))</span><br><span class="line">&#125;</span><br><span class="line">i()</span><br><span class="line">i(a = 1)</span><br><span class="line">i(b = 2)</span><br><span class="line">i(1, 2)</span><br></pre></td></tr></table></figure>
<p>Sometimes you want to add a non-trivial default value, which might take several lines of code to compute. Instead of inserting that code in the function definition, you could use <code>missing()</code> to conditionally compute it if needed. However, this makes it hard to know which arguments are required and which are optional without carefully reading the documentation. Instead, I usually set the default value to <code>NULL</code> and use <code>is.null()</code> to check if the argument was supplied.</p>
<h3 id="Lazy-evaluation"><a href="#Lazy-evaluation" class="headerlink" title="Lazy evaluation"></a><a href="id=&quot;lazy-evaluation&quot;">Lazy evaluation</a></h3><p>By default, R function arguments are lazy â theyâre only evaluated if theyâre actually used:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) &#123;</span><br><span class="line">  10</span><br><span class="line">&#125;</span><br><span class="line">f(stop(&quot;This is an error!&quot;))</span><br></pre></td></tr></table></figure>
<p>If you want to ensure that an argument is evaluated you can use <code>force()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) &#123;</span><br><span class="line">  force(x)</span><br><span class="line">  10</span><br><span class="line">&#125;</span><br><span class="line">f(stop(&quot;This is an error!&quot;))</span><br></pre></td></tr></table></figure>
<p>This is important when creating closures with <code>lapply()</code> or a loop:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add &lt;- function(x) &#123;</span><br><span class="line">  function(y) x + y</span><br><span class="line">&#125;</span><br><span class="line">adders &lt;- lapply(1:10, add)</span><br><span class="line">adders[[1]](10)</span><br><span class="line">adders[[10]](10)</span><br></pre></td></tr></table></figure>
<p><code>x</code> is lazily evaluated the first time that you call one of the adder functions. At this point, the loop is complete and the final value of <code>x</code> is 10.  Therefore all of the adder functions will add 10 on to their input, probably not what you wanted!  Manually forcing evaluation fixes the problem:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add &lt;- function(x) &#123;</span><br><span class="line">  force(x)</span><br><span class="line">  function(y) x + y</span><br><span class="line">&#125;</span><br><span class="line">adders2 &lt;- lapply(1:10, add)</span><br><span class="line">adders2[[1]](10)</span><br><span class="line">adders2[[10]](10)</span><br></pre></td></tr></table></figure>
<p>This code is exactly equivalent to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add &lt;- function(x) &#123;</span><br><span class="line">  x</span><br><span class="line">  function(y) x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>because the force function is defined as <code>force &lt;- function(x) x</code>. However, using this function clearly indicates that youâre forcing evaluation, not that youâve accidentally typed <code>x</code>.</p>
<p>Default arguments are evaluated inside the function. This means that if the expression depends on the current environment the results will differ depending on whether you use the default value or explicitly provide one.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x = ls()) &#123;</span><br><span class="line">  a &lt;- 1</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ls() evaluated inside f:</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"># ls() evaluated in global environment:</span><br><span class="line">f(ls())</span><br></pre></td></tr></table></figure>
<p>More technically, an unevaluated argument is called a <strong>promise</strong>, or (less commonly) a thunk. A promise is made up of two parts:</p>
<ul>
<li>The expression which gives rise to the delayed computation. (It can be  accessed with <code>substitute()</code>. See <a href="#nse">non-standard evaluation</a> for more  details.)</li>
<li>The environment where the expression was created and where it should be  evaluated.</li>
</ul>
<p>The first time a promise is accessed the expression is evaluated in the environment where it was created. This value is cached, so that subsequent access to the evaluated promise does not recompute the value (but the original expression is still associated with the value, so <code>substitute()</code> can continue to access it). You can find more information about a promise using <code>pryr::promise_info()</code>. This uses some C++ code to extract information about the promise without evaluating it, which is impossible to do in pure R code.</p>
<p>Laziness is useful in if statements â the second statement below will be evaluated only if the first is true. If it wasnât, the statement would return an error because <code>NULL &gt; 0</code> is a logical vector of length 0 and not a valid input to <code>if</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- NULL</span><br><span class="line">if (!is.null(x) &amp;&amp; x &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We could implement â&amp;&amp;â ourselves:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`&amp;&amp;` &lt;- function(x, y) &#123;</span><br><span class="line">  if (!x) return(FALSE)</span><br><span class="line">  if (!y) return(FALSE)</span><br><span class="line"></span><br><span class="line">  TRUE</span><br><span class="line">&#125;</span><br><span class="line">a &lt;- NULL</span><br><span class="line">!is.null(a) &amp;&amp; a &gt; 0</span><br></pre></td></tr></table></figure>
<p>This function would not work without lazy evaluation because both <code>x</code> and <code>y</code> would always be evaluated, testing <code>a &gt; 0</code> even when <code>a</code> was NULL.</p>
<p>Sometimes you can also use laziness to eliminate an if statement altogether. For example, instead of:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (is.null(a)) stop(&quot;a is null&quot;)</span><br></pre></td></tr></table></figure>
<p>You could write:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!is.null(a) || stop(&quot;a is null&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="-1"><a href="#-1" class="headerlink" title="..."></a><code>...</code></h3><p>There is a special argument called <code>...</code> .  This argument will match any arguments not otherwise matched, and can be easily passed on to other functions.  This is useful if you want to collect arguments to call another function, but you donât want to prespecify their possible names. <code>...</code> is often used in conjunction with S3 generic functions to allow individual methods to be more flexible.</p>
<p>One relatively sophisticated user of <code>...</code> is the base <code>plot()</code> function. <code>plot()</code> is a generic method with arguments <code>x</code>, <code>y</code> and <code>...</code> . To understand what <code>...</code> does for a given function we need to read the help: âArguments to be passed to methods, such as graphical parametersâ. Most simple invocations of <code>plot()</code> end up calling <code>plot.default()</code> which has many more arguments, but also has <code>...</code> .  Again, reading the documentation reveals that <code>...</code> accepts âother graphical parametersâ, which are listed in the help for <code>par()</code>.  This allows us to write code like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot(1:5, col = &quot;red&quot;)</span><br><span class="line">plot(1:5, cex = 5, pch = 20)</span><br></pre></td></tr></table></figure>
<p>This illustrates both the advantages and disadvantages of <code>...</code>: it makes <code>plot()</code> very flexible, but to understand how to use it, we have to carefully read the documentation. Additionally, if we read the source code for <code>plot.default</code>, we can discover undocumented features. Itâs possible to pass along other arguments to <code>Axis()</code> and <code>box()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot(1:5, bty = &quot;u&quot;)</span><br><span class="line">plot(1:5, labels = FALSE)</span><br></pre></td></tr></table></figure>
<p>To capture <code>...</code> in a form that is easier to work with, you can use <code>list(...)</code>. (See <a href="#capturing-dots">capturing unevaluated dots</a> for other ways to capture <code>...</code> without evaluating the arguments.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(...) &#123;</span><br><span class="line">  names(list(...))</span><br><span class="line">&#125;</span><br><span class="line">f(a = 1, b = 2)</span><br></pre></td></tr></table></figure>
<p>Using <code>...</code> comes at a price â any misspelled arguments will not raise an error, and any arguments after <code>...</code> must be fully named.  This makes it easy for typos to go unnoticed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(1, 2, NA, na.mr = TRUE)</span><br></pre></td></tr></table></figure>
<p>Itâs often better to be explicit rather than implicit, so you might instead ask users to supply a list of additional arguments. Thatâs certainly easier if youâre trying to use <code>...</code> with multiple additional functions.</p>
<h3 id="Exercises-9"><a href="#Exercises-9" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>Clarify the following list of odd function calls:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- sample(replace = TRUE, 20, x = c(1:10, NA))</span><br><span class="line">y &lt;- runif(min = 0, max = 1, 20)</span><br><span class="line">cor(m = &quot;k&quot;, y = y, u = &quot;p&quot;, x = x)</span><br></pre></td></tr></table></figure>
</li>
<li><p>What does this function return? Why? Which principle does it illustrate?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1 &lt;- function(x = &#123;y &lt;- 1; 2&#125;, y = 0) &#123;</span><br><span class="line">  x + y</span><br><span class="line">&#125;</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure>
</li>
<li><p>What does this function return? Why? Which principle does it illustrate?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f2 &lt;- function(x = z) &#123;</span><br><span class="line">  z &lt;- 100</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br><span class="line">f2()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Special-calls"><a href="#Special-calls" class="headerlink" title="Special calls"></a><a href="id=&quot;special-calls&quot;">Special calls</a></h2><p>R supports two additional syntaxes for calling special types of functions: infix and replacement functions.</p>
<h3 id="Infix-functions"><a href="#Infix-functions" class="headerlink" title="Infix functions"></a><a href="id=&quot;infix-functions&quot;">Infix functions</a></h3><p>Most functions in R are âprefixâ operators: the name of the function comes before the arguments. You can also create infix functions where the function name comes in between its arguments, like <code>+</code> or <code>-</code>.  All user-created infix functions must start and end with <code>%</code>. R comes with the following infix functions predefined: <code>%%</code>, <code>%*%</code>, <code>%/%</code>, <code>%in%</code>, <code>%o%</code>,  <code>%x%</code>. (The complete list of built-in infix operators that donât need <code>%</code> is: <code>::, :::, $, @, ^, *, /, +, -, &gt;, &gt;=, &lt;, &lt;=, ==, !=, !, &amp;, &amp;&amp;, |, ||, ~, &lt;-, &lt;&lt;-</code>)</p>
<p>For example, we could create a new operator that pastes together strings:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`%+%` &lt;- function(a, b) paste0(a, b)</span><br><span class="line">&quot;new&quot; %+% &quot; string&quot;</span><br></pre></td></tr></table></figure>
<p>Note that when creating the function, you have to put the name in backticks because itâs a special name. This is just a syntactic sugar for an ordinary function call; as far as R is concerned there is no difference between these two expressions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;new&quot; %+% &quot; string&quot;</span><br><span class="line">`%+%`(&quot;new&quot;, &quot; string&quot;)</span><br></pre></td></tr></table></figure>
<p>Or indeed between</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 + 5</span><br><span class="line">`+`(1, 5)</span><br></pre></td></tr></table></figure>
<p>The names of infix functions are more flexible than regular R functions: they can contain any sequence of characters (except â%â, of course). You will need to escape any special characters in the string used to define the function, but not when you call it:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`% %` &lt;- function(a, b) paste(a, b)</span><br><span class="line">`%&apos;%` &lt;- function(a, b) paste(a, b)</span><br><span class="line">`%/\\%` &lt;- function(a, b) paste(a, b)</span><br><span class="line"></span><br><span class="line">&quot;a&quot; % % &quot;b&quot;</span><br><span class="line">&quot;a&quot; %&apos;% &quot;b&quot;</span><br><span class="line">&quot;a&quot; %/\% &quot;b&quot;</span><br></pre></td></tr></table></figure>
<p>Râs default precedence rules mean that infix operators are composed from left to right:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`%-%` &lt;- function(a, b) paste0(&quot;(&quot;, a, &quot; %-% &quot;, b, &quot;)&quot;)</span><br><span class="line">&quot;a&quot; %-% &quot;b&quot; %-% &quot;c&quot;</span><br></pre></td></tr></table></figure>
<p>Thereâs one infix function that I use very often. Itâs inspired by Rubyâs <code>||</code> logical or operator, although it works a little differently in R because Ruby has a more flexible definition of what evaluates to <code>TRUE</code> in an if statement. Itâs useful as a way of providing a default value in case the output of another function is <code>NULL</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`%||%` &lt;- function(a, b) if (!is.null(a)) a else b</span><br><span class="line">function_that_might_return_null() %||% default value</span><br></pre></td></tr></table></figure>
<h3 id="Replacement-functions"><a href="#Replacement-functions" class="headerlink" title="Replacement functions"></a><a href="id=&quot;replacement-functions&quot;">Replacement functions</a></h3><p>Replacement functions act like they modify their arguments in place, and have the special name <code>xxx&lt;-</code>. They typically have two arguments (<code>x</code> and <code>value</code>), although they can have more, and they must return the modified object. For example, the following function allows you to modify the second element of a vector:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`second&lt;-` &lt;- function(x, value) &#123;</span><br><span class="line">  x[2] &lt;- value</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br><span class="line">x &lt;- 1:10</span><br><span class="line">second(x) &lt;- 5L</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<p>When R evaluates the assignment <code>second(x) &lt;- 5</code>, it notices that the left hand side of the <code>&lt;-</code> is not a simple name, so it looks for a function named <code>second&lt;-</code> to do the replacement.</p>
<p>I say they âactâ like they modify their arguments in place, because they actually create a modified copy. We can see that by using <code>pryr::address()</code> to find the memory address of the underlying object.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">library(pryr)</span><br><span class="line">x &lt;- 1:10</span><br><span class="line">address(x)</span><br><span class="line">second(x) &lt;- 6L</span><br><span class="line">address(x)</span><br></pre></td></tr></table></figure>
<p>Built-in functions that are implemented using <code>.Primitive()</code> will modify in place:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1:10</span><br><span class="line">address(x)</span><br><span class="line">#&gt; [1] &quot;0x103945110&quot;</span><br><span class="line"></span><br><span class="line">x[2] &lt;- 7L</span><br><span class="line">address(x)</span><br><span class="line">#&gt; [1] &quot;0x103945110&quot;</span><br></pre></td></tr></table></figure>
<p>Itâs important to be aware of this behaviour since it has important performance implications.</p>
<p>If you want to supply additional arguments, they go in between <code>x</code> and <code>value</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`modify&lt;-` &lt;- function(x, position, value) &#123;</span><br><span class="line">  x[position] &lt;- value</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br><span class="line">modify(x, 1) &lt;- 10</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<p>When you call <code>modify(x, 1) &lt;- 10</code>, behind the scenes R turns it into:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- `modify&lt;-`(x, 1, 10)</span><br></pre></td></tr></table></figure>
<p>This means you canât do things like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modify(get(&quot;x&quot;), 1) &lt;- 10</span><br></pre></td></tr></table></figure>
<p>because that gets turned into the invalid code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get(&quot;x&quot;) &lt;- `modify&lt;-`(get(&quot;x&quot;), 1, 10)</span><br></pre></td></tr></table></figure>
<p>Itâs often useful to combine replacement and subsetting:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(a = 1, b = 2, c = 3)</span><br><span class="line">names(x)</span><br><span class="line">names(x)[2] &lt;- &quot;two&quot;</span><br><span class="line">names(x)</span><br></pre></td></tr></table></figure>
<p>This works because the expression <code>names(x)[2] &lt;- &quot;two&quot;</code> is evaluated as if you had written:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`*tmp*` &lt;- names(x)</span><br><span class="line">`*tmp*`[2] &lt;- &quot;two&quot;</span><br><span class="line">names(x) &lt;- `*tmp*`</span><br></pre></td></tr></table></figure>
<p>(Yes, it really does create a local variable named <code>*tmp*</code>, which is removed afterwards.)</p>
<h3 id="Exercises-10"><a href="#Exercises-10" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Create a list of all the replacement functions found in the base package.   Which ones are primitive functions?</li>
<li>What are valid names for user-created infix functions?</li>
<li>Create an infix <code>xor()</code> operator.</li>
<li>Create infix versions of the set functions <code>intersect()</code>, <code>union()</code>, and   <code>setdiff()</code>.</li>
<li>Create a replacement function that modifies a random location in a vector.</li>
</ol>
<h2 id="Return-values"><a href="#Return-values" class="headerlink" title="Return values"></a><a href="id=&quot;return-values&quot;">Return values</a></h2><p>The last expression evaluated in a function becomes the return value, the result of invoking the function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) &#123;</span><br><span class="line">  if (x &lt; 10) &#123;</span><br><span class="line">    0</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    10</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(5)</span><br><span class="line">f(15)</span><br></pre></td></tr></table></figure>
<p>Generally, I think itâs good style to reserve the use of an explicit <code>return()</code> for when you are returning early, such as for an error, or a simple case of the function. This style of programming can also reduce the level of indentation, and generally make functions easier to understand because you can reason about them locally.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x, y) &#123;</span><br><span class="line">  if (!x) return(y)</span><br><span class="line"></span><br><span class="line">  # complicated processing here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Functions can return only a single object. But this is not a limitation because you can return a list containing any number of objects.</p>
<p>The functions that are the easiest to understand and reason about are pure functions: functions that always map the same input to the same output and have no other impact on the workspace. In other words, pure functions have no <strong>side effects</strong>: they donât affect the state of the world in any way apart from the value they return.</p>
<p>R protects you from one type of side effect: most R objects have copy-on-modify semantics. So modifying a function argument does not change the original value:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) &#123;</span><br><span class="line">  x$a &lt;- 2</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br><span class="line">x &lt;- list(a = 1)</span><br><span class="line">f(x)</span><br><span class="line">x$a</span><br></pre></td></tr></table></figure>
<p>(There are two important exceptions to the copy-on-modify rule: environments and reference classes. These can be modified in place, so extra care is needed when working with them.)</p>
<p>This is notably different to languages like Java where you can modify the inputs of a function. This copy-on-modify behaviour has important performance consequences which are discussed in depth in <a href="#profiling">profiling</a>. (Note that the performance consequences are a result of Râs implementation of copy-on-modify semantics; they are not true in general. Clojure is a new language that makes extensive use of copy-on-modify semantics with limited performance consequences.)</p>
<p>Most base R functions are pure, with a few notable exceptions:</p>
<ul>
<li><code>library()</code> which loads a package, and hence modifies the search path.</li>
<li><code>setwd()</code>, <code>Sys.setenv()</code>, <code>Sys.setlocale()</code> which change the working  directory, environment variables, and the locale, respectively.</li>
<li><code>plot()</code> and friends which produce graphical output.</li>
<li><code>write()</code>, <code>write.csv()</code>, <code>saveRDS()</code>, etc. which save output to disk.</li>
<li><code>options()</code> and <code>par()</code> which modify global settings.</li>
<li>S4 related functions which modify global tables of classes and methods.</li>
<li>Random number generators which produce different numbers each time you<br>run them.</li>
</ul>
<p>Itâs generally a good idea to minimise the use of side effects, and where possible, to minimise the footprint of side effects by separating pure from impure functions. Pure functions are easier to test (because all you need to worry about are the input values and the output), and are less likely to work differently on different versions of R or on different platforms. For example, this is one of the motivating principles of ggplot2: most operations work on an object that represents a plot, and only the final <code>print</code> or <code>plot</code> call has the side effect of actually drawing the plot.</p>
<p>Functions can return <code>invisible</code> values, which are not printed out by default when you call the function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f1 &lt;- function() 1</span><br><span class="line">f2 &lt;- function() invisible(1)</span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">f1() == 1</span><br><span class="line">f2() == 1</span><br></pre></td></tr></table></figure>
<p>You can force an invisible value to be displayed by wrapping it in parentheses:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(f2())</span><br></pre></td></tr></table></figure>
<p>The most common function that returns invisibly is <code>&lt;-</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- 2</span><br><span class="line">(a &lt;- 2)</span><br></pre></td></tr></table></figure>
<p>This is what makes it possible to assign one value to multiple variables:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- b &lt;- c &lt;- d &lt;- 2</span><br></pre></td></tr></table></figure>
<p>because this is parsed as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &lt;- (b &lt;- (c &lt;- (d &lt;- 2))))</span><br></pre></td></tr></table></figure>
<h3 id="On-exit"><a href="#On-exit" class="headerlink" title="On exit"></a><a href="id=&quot;on-exit&quot;">On exit</a></h3><p>As well as returning a value, functions can set up other triggers to occur when the function is finished using <code>on.exit()</code>. This is often used as a way to guarantee that changes to the global state are restored when the function exits. The code in <code>on.exit()</code> is run regardless of how the function exits, whether with an explicit (early) return, an error, or simply reaching the end of the function body.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">in_dir &lt;- function(dir, code) &#123;</span><br><span class="line">  old &lt;- setwd(dir)</span><br><span class="line">  on.exit(setwd(old))</span><br><span class="line"></span><br><span class="line">  force(code)</span><br><span class="line">&#125;</span><br><span class="line">getwd()</span><br><span class="line">in_dir(&quot;~&quot;, getwd())</span><br></pre></td></tr></table></figure>
<p>The basic pattern is simple:</p>
<ul>
<li>We first set the directory to a new location, capturing the current location  from the output of <code>setwd()</code>.</li>
<li>We then use <code>on.exit()</code> to ensure that the working directory is returned to  the previous value regardless of how the function exits.</li>
<li>Finally, we explicitly force evaluation of the code. (We donât actually need  <code>force()</code> here, but it makes it clear to readers what weâre doing.)</li>
</ul>
<p><strong>Caution</strong>: If youâre using multiple <code>on.exit()</code> calls within a function, make sure to set <code>add = TRUE</code>. Unfortunately, the default in <code>on.exit()</code> is <code>add = FALSE</code>, so that every time you run it, it overwrites existing exit expressions. Because of the way <code>on.exit()</code> is implemented, itâs not possible to create a variant with <code>add = TRUE</code>, so you must be careful when using it.</p>
<h3 id="Exercises-11"><a href="#Exercises-11" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>How does the <code>chdir</code> parameter of <code>source()</code> compare to <code>in_dir()</code>? Why    might you prefer one approach to the other?</li>
<li>What function undoes the action of <code>library()</code>? How do you save and restore    the values of <code>options()</code> and <code>par()</code>?</li>
<li>Write a function that opens a graphics device, runs the supplied code, and    closes the graphics device (always, regardless of whether or not the plotting    code worked).</li>
<li><p>We can use <code>on.exit()</code> to implement a simple version of <code>capture.output()</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">capture.output2 &lt;- function(code) &#123;</span><br><span class="line">  temp &lt;- tempfile()</span><br><span class="line">  on.exit(file.remove(temp), add = TRUE)</span><br><span class="line"></span><br><span class="line">  sink(temp)</span><br><span class="line">  on.exit(sink(), add = TRUE)</span><br><span class="line"></span><br><span class="line">  force(code)</span><br><span class="line">  readLines(temp)</span><br><span class="line">&#125;</span><br><span class="line">capture.output2(cat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;\n&quot;))</span><br></pre></td></tr></table></figure>
<p>Compare <code>capture.output()</code> to <code>capture.output2()</code>. How do the functions    differ? What features have I removed to make the key ideas easier to see?    How have I rewritten the key ideas to be easier to understand?</p>
</li>
</ol>
<h2 id="Quiz-answers"><a href="#Quiz-answers" class="headerlink" title="Quiz answers"></a><a href="id=&quot;function-answers&quot;">Quiz answers</a></h2><p>\enlargethispage*{\baselineskip}</p>
<ol>
<li>The three components of a function are its body, arguments, and environment.</li>
<li><code>f1(1)()</code> returns 11.</li>
<li>Youâd normally write it in infix style: <code>1 + (2 * 3)</code>.</li>
<li>Rewriting the call to <code>mean(c(1:10, NA), na.rm = TRUE)</code> is easier to    understand.</li>
<li>No, it does not throw an error because the second argument is never used    so itâs never evaluated.</li>
<li>See <a href="#infix-functions">infix</a> and    <a href="#replacement-functions">replacement functions</a>.</li>
<li>You use <code>on.exit()</code>; see <a href="#on-exit">on exit</a> for details.</li>
</ol>
<hr>
<h1 id="OO-field-guide"><a href="#OO-field-guide" class="headerlink" title="OO field guide"></a><a href="id=&quot;oo&quot;">OO field guide</a></h1><p>This chapter is a field guide for recognising and working with Râs objects in the wild. R has three object oriented systems (plus the base types), so it can be a bit intimidating. The goal of this guide is not to make you an expert in all four systems, but to help you identify which system youâre working with and to help you use it effectively.</p>
<p>Central to any object-oriented system are the concepts of class and method. A <strong>class</strong> defines the behaviour of <strong>objects</strong> by describing their attributes and their relationship to other classes. The class is also used when selecting <strong>methods</strong>, functions that behave differently depending on the class of their input. Classes are usually organised in a hierarchy: if a method does not exist for a child, then the parentâs method is used instead; the child <strong>inherits</strong> behaviour from the parent.</p>
<p>Râs three OO systems differ in how classes and methods are defined:</p>
<ul>
<li><strong>S3</strong> implements a style of OO programming called generic-function OO.  This is different from most programming languages, like Java, C++, and C#,  which implement message-passing OO. With message-passing, messages (methods)  are sent to objects and the object determines which function to call.  Typically, this object has a special appearance in the method call, usually<br>appearing before the name of the method/message: e.g.,  <code>canvas.drawRect(&quot;blue&quot;)</code>. S3 is different. While computations are still  carried out via methods, a special type of function called a  <strong>generic function</strong> decides which method to call, e.g.,  <code>drawRect(canvas, &quot;blue&quot;)</code>. S3 is a very casual system. It has no  formal definition of classes.</li>
<li><strong>S4</strong> works similarly to S3, but is more formal. There are two major  differences to S3. S4 has formal class definitions, which describe the  representation and inheritance for each class, and has special helper  functions for defining generics and methods. S4 also has multiple dispatch,  which means that generic functions can pick methods based on the class of<br>any number of arguments, not just one.</li>
<li><strong>Reference classes</strong>, called RC for short, are quite different from S3  and S4. RC implements message-passing OO, so methods belong to classes,  not functions. <code>$</code> is used to separate objects and methods, so method calls  look like <code>canvas$drawRect(&quot;blue&quot;)</code>. RC objects are also mutable: they donât  use Râs usual copy-on-modify semantics, but are modified in place. This  makes them harder to reason about, but allows them to solve problems that  are difficult to solve with S3 or S4.</li>
</ul>
<p>Thereâs also one other system thatâs not quite OO, but itâs important to mention here:</p>
<ul>
<li><strong>base types</strong>, the internal C-level types that underlie the other OO  systems. Base types are mostly manipulated using C code, but theyâre  important to know about because they provide the building blocks for the  other OO systems.</li>
</ul>
<p>The following sections describe each system in turn, starting with base types. Youâll learn how to recognise the OO system that an object belongs to, how method dispatch works, and how to create new objects, classes, generics, and methods for that system. The chapter concludes with a few remarks on when to use each system.</p>
<h5 id="Prerequisites-1"><a href="#Prerequisites-1" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><p>Youâll need the pryr package, <code>install.packages(&quot;pryr&quot;)</code>, to access useful functions for examining OO properties.</p>
<h5 id="Quiz-3"><a href="#Quiz-3" class="headerlink" title="Quiz"></a>Quiz</h5><p>Think you know this material already? If you can answer the following questions correctly, you can safely skip this chapter. Find the answers at the end of the chapter in <a href="#oo-answers">answers</a>.</p>
<ol>
<li>How do you tell what OO system (base, S3, S4, or RC) an object is   associated with?</li>
<li>How do you determine the base type (like integer or list) of an object?</li>
<li>What is a generic function?</li>
<li>What are the main differences between S3 and S4? What are the main   differences between S4 &amp; RC?</li>
</ol>
<h5 id="Outline-3"><a href="#Outline-3" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#base-types">Base types</a> teaches you about Râs base object system. Only  R-core can add new classes to this system, but itâs important to know about  because it underpins the three other systems.</li>
<li><a href="#s3">S3</a> shows you the basics of the S3 object system. Itâs the simplest  and most commonly used OO system.</li>
<li><a href="#s4">S4</a> discusses the more formal and rigorous S4 system.</li>
<li><a href="#rc">RC</a> teaches you about Râs newest OO system: reference classes, or  RC for short.</li>
<li><a href="#picking-a-system">Picking a system</a> advises on which OO system to  use if youâre starting a new project.</li>
</ul>
<h2 id="Base-types"><a href="#Base-types" class="headerlink" title="Base types"></a><a href="id=&quot;base-types&quot;">Base types</a></h2><p>Underlying every R object is a C structure (or struct) that describes how that object is stored in memory. The struct includes the contents of the object, the information needed for memory management, and, most importantly for this section, a <strong>type</strong>. This is the <strong>base type</strong> of an R object. Base types are not really an object system because only the R core team can create new types. As a result, new base types are added very rarely: the most recent change, in 2011, added two exotic types that you never see in R, but are useful for diagnosing memory problems (<code>NEWSXP</code> and <code>FREESXP</code>). Prior to that, the last type added was a special base type for S4 objects (<code>S4SXP</code>) in 2005.</p>
<p><a href="#data-structures">Data structures</a> explains the most common base types (atomic vectors and lists), but base types also encompass functions, environments, and other more exotic objects likes names, calls, and promises that youâll learn about later in the book. You can determine an objectâs base type with <code>typeof()</code>. Unfortunately the names of base types are not used consistently throughout R, and type and the corresponding âisâ function may use different names:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># The type of a function is &quot;closure&quot;</span><br><span class="line">f &lt;- function() &#123;&#125;</span><br><span class="line">typeof(f)</span><br><span class="line">is.function(f)</span><br><span class="line"></span><br><span class="line"># The type of a primitive function is &quot;builtin&quot;</span><br><span class="line">typeof(sum)</span><br><span class="line">is.primitive(sum)</span><br></pre></td></tr></table></figure>
<p>You may have heard of <code>mode()</code> and <code>storage.mode()</code>. I recommend ignoring these functions because theyâre just aliases of the names returned by <code>typeof()</code>, and exist solely for S compatibility. Read their source code if you want to understand exactly what they do.</p>
<p>Functions that behave differently for different base types are almost always written in C, where dispatch occurs using switch statements (e.g., <code>switch(TYPEOF(x))</code>). Even if you never write C code, itâs important to understand base types because everything else is built on top of them: S3 objects can be built on top of any base type, S4 objects use a special base type, and RC objects are a combination of S4 and environments (another base type). To see if an object is a pure base type, i.e., it doesnât also have S3, S4, or RC behaviour, check that <code>is.object(x)</code> returns <code>FALSE</code>.</p>
<h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a><a href="id=&quot;s3&quot;">S3</a></h2><p>S3 is Râs first and simplest OO system. It is the only OO system used in the base and stats packages, and itâs the most commonly used system in CRAN packages. S3 is informal and ad hoc, but it has a certain elegance in its minimalism: you canât take away any part of it and still have a useful OO system.</p>
<h3 id="Recognising-objects-generic-functions-and-methods"><a href="#Recognising-objects-generic-functions-and-methods" class="headerlink" title="Recognising objects, generic functions, and methods"></a>Recognising objects, generic functions, and methods</h3><p>Most objects that you encounter are S3 objects. But unfortunately thereâs no simple way to test if an object is an S3 object in base R. The closest you can come is <code>is.object(x) &amp; !isS4(x)</code>, i.e., itâs an object, but not S4. An easier way is to use <code>pryr::otype()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">library(pryr)</span><br><span class="line"></span><br><span class="line">df &lt;- data.frame(x = 1:10, y = letters[1:10])</span><br><span class="line">otype(df)    # A data frame is an S3 class</span><br><span class="line">otype(df$x)  # A numeric vector isn&apos;t</span><br><span class="line">otype(df$y)  # A factor is</span><br></pre></td></tr></table></figure>
<p>In S3, methods belong to functions, called <strong>generic functions</strong>, or generics for short. S3 methods do not belong to objects or classes. This is different from most other programming languages, but is a legitimate OO style.</p>
<p>To determine if a function is an S3 generic, you can inspect its source code for a call to <code>UseMethod()</code>: thatâs the function that figures out the correct method to call, the process of <strong>method dispatch</strong>. Similar to <code>otype()</code>, pryr also provides <code>ftype()</code> which describes the object system, if any, associated with a function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mean</span><br><span class="line">ftype(mean)</span><br></pre></td></tr></table></figure>
<p>Some S3 generics, like <code>[</code>, <code>sum()</code>, and <code>cbind()</code>, donât call <code>UseMethod()</code> because they are implemented in C. Instead, they call the C functions <code>DispatchGroup()</code> or <code>DispatchOrEval()</code>. Functions that do method dispatch in C code are called <strong>internal generics</strong> and are documented in <code>?&quot;internal generic&quot;</code>. <code>ftype()</code> knows about these special cases too.</p>
<p>Given a class, the job of an S3 generic is to call the right S3 method. You can recognise S3 methods by their names, which look like <code>generic.class()</code>. For example, the Date method for the <code>mean()</code> generic is called <code>mean.Date()</code>, and the factor method for <code>print()</code> is called <code>print.factor()</code>.</p>
<p>This is the reason that most modern style guides discourage the use of <code>.</code> in function names: it makes them look like S3 methods. For example, is <code>t.test()</code> the <code>t</code> method for <code>test</code> objects? Similarly, the use of <code>.</code> in class names can also be confusing: is <code>print.data.frame()</code> the <code>print()</code> method for <code>data.frames</code>, or the <code>print.data()</code> method for <code>frames</code>?  <code>pryr::ftype()</code> knows about these exceptions, so you can use it to figure out if a function is an S3 method or generic:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftype(t.data.frame) # data frame method for t()</span><br><span class="line">ftype(t.test)       # generic function for t tests</span><br></pre></td></tr></table></figure>
<p>You can see all the methods that belong to a generic with <code>methods()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">methods(&quot;mean&quot;)</span><br><span class="line">methods(&quot;t.test&quot;)</span><br></pre></td></tr></table></figure>
<p>(Apart from methods defined in the base package, most S3 methods will not be visible: use <code>getS3method()</code> to read their source code.)</p>
<p>You can also list all generics that have a method for a given class:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">methods(class = &quot;ts&quot;)</span><br></pre></td></tr></table></figure>
<p>Thereâs no way to list all S3 classes, as youâll learn in the following section.</p>
<h3 id="Defining-classes-and-creating-objects"><a href="#Defining-classes-and-creating-objects" class="headerlink" title="Defining classes and creating objects"></a>Defining classes and creating objects</h3><p>S3 is a simple and ad hoc system; it has no formal definition of a class. To make an object an instance of a class, you just take an existing base object and set the class attribute. You can do that during creation with <code>structure()</code>, or after the fact with <code>class&lt;-()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Create and assign class in one step</span><br><span class="line">foo &lt;- structure(list(), class = &quot;foo&quot;)</span><br><span class="line"></span><br><span class="line"># Create, then set class</span><br><span class="line">foo &lt;- list()</span><br><span class="line">class(foo) &lt;- &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<p>S3 objects are usually built on top of lists, or atomic vectors with attributes. (You can refresh your memory of attributes with <a href="#attributes">attributes</a>.) You can also turn functions into S3 objects. Other base types are either rarely seen in R, or have unusual semantics that donât work well with attributes.</p>
<p>You can determine the class of any object using <code>class(x)</code>, and see if an object inherits from a specific class using <code>inherits(x, &quot;classname&quot;)</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class(foo)</span><br><span class="line">inherits(foo, &quot;foo&quot;)</span><br></pre></td></tr></table></figure>
<p>The class of an S3 object can be a vector, which describes behaviour from most to least specific. For example, the class of the <code>glm()</code> object is <code>c(&quot;glm&quot;, &quot;lm&quot;)</code> indicating that generalised linear models inherit behaviour from linear models. Class names are usually lower case, and you should avoid <code>.</code>. Otherwise, opinion is mixed whether to use underscores (<code>my_class</code>) or CamelCase (<code>MyClass</code>) for multi-word class names.</p>
<p>Most S3 classes provide a constructor function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo &lt;- function(x) &#123;</span><br><span class="line">  if (!is.numeric(x)) stop(&quot;X must be numeric&quot;)</span><br><span class="line">  structure(list(x), class = &quot;foo&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You should use it if itâs available (like for <code>factor()</code> and <code>data.frame()</code>). This ensures that youâre creating the class with the correct components. Constructor functions usually have the same name as the class.</p>
<p>Apart from developer supplied constructor functions, S3 has no checks for correctness. This means you can change the class of existing objects:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Create a linear model</span><br><span class="line">mod &lt;- lm(log(mpg) ~ log(disp), data = mtcars)</span><br><span class="line">class(mod)</span><br><span class="line">print(mod)</span><br><span class="line"></span><br><span class="line"># Turn it into a data frame (?!)</span><br><span class="line">class(mod) &lt;- &quot;data.frame&quot;</span><br><span class="line"># But unsurprisingly this doesn&apos;t work very well</span><br><span class="line">print(mod)</span><br><span class="line"># However, the data is still there</span><br><span class="line">mod$coefficients</span><br></pre></td></tr></table></figure>
<p>If youâve used other OO languages, this might make you feel queasy. But surprisingly, this flexibility causes few problems: while you <em>can</em> change the type of an object, you never should. R doesnât protect you from yourself: you can easily shoot yourself in the foot. As long as you donât aim the gun at your foot and pull the trigger, you wonât have a problem.</p>
<h3 id="Creating-new-methods-and-generics"><a href="#Creating-new-methods-and-generics" class="headerlink" title="Creating new methods and generics"></a>Creating new methods and generics</h3><p>To add a new generic, create a function that calls <code>UseMethod()</code>. <code>UseMethod()</code> takes two arguments: the name of the generic function, and the argument to use for method dispatch. If you omit the second argument it will dispatch on the first argument to the function. Thereâs no need to pass any of the arguments of the generic to <code>UseMethod()</code> and you shouldnât do so. <code>UseMethod()</code> uses black magic to find them out for itself.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) UseMethod(&quot;f&quot;)</span><br></pre></td></tr></table></figure>
<p>A generic isnât useful without some methods. To add a method, you just create a regular function with the correct (<code>generic.class</code>) name:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f.a &lt;- function(x) &quot;Class a&quot;</span><br><span class="line"></span><br><span class="line">a &lt;- structure(list(), class = &quot;a&quot;)</span><br><span class="line">class(a)</span><br><span class="line">f(a)</span><br></pre></td></tr></table></figure>
<p>Adding a method to an existing generic works in the same way:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mean.a &lt;- function(x) &quot;a&quot;</span><br><span class="line">mean(a)</span><br></pre></td></tr></table></figure>
<p>As you can see, thereâs no check to make sure that the method returns the class compatible with the generic. Itâs up to you to make sure that your method doesnât violate the expectations of existing code.</p>
<h3 id="Method-dispatch"><a href="#Method-dispatch" class="headerlink" title="Method dispatch"></a>Method dispatch</h3><p>S3 method dispatch is relatively simple. <code>UseMethod()</code> creates a vector of function names, like <code>paste0(&quot;generic&quot;, &quot;.&quot;, c(class(x), &quot;default&quot;))</code> and looks for each in turn. The âdefaultâ class makes it possible to set up a fall back method for otherwise unknown classes.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) UseMethod(&quot;f&quot;)</span><br><span class="line">f.a &lt;- function(x) &quot;Class a&quot;</span><br><span class="line">f.default &lt;- function(x) &quot;Unknown class&quot;</span><br><span class="line"></span><br><span class="line">f(structure(list(), class = &quot;a&quot;))</span><br><span class="line"># No method for b class, so uses method for a class</span><br><span class="line">f(structure(list(), class = c(&quot;b&quot;, &quot;a&quot;)))</span><br><span class="line"># No method for c class, so falls back to default</span><br><span class="line">f(structure(list(), class = &quot;c&quot;))</span><br></pre></td></tr></table></figure>
<p>Group generic methods add a little more complexity. Group generics make it possible to implement methods for multiple generics with one function. The four group generics and the functions they include are:</p>
<ul>
<li>Math: <code>abs</code>, <code>sign</code>, <code>sqrt</code>, <code>floor</code>, <code>cos</code>, <code>sin</code>, <code>log</code>, <code>exp</code>, â¦</li>
<li>Ops: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>%%</code>, <code>%/%</code>, <code>&amp;</code>, <code>|</code>, <code>!</code>, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code></li>
<li>Summary: <code>all</code>, <code>any</code>, <code>sum</code>, <code>prod</code>, <code>min</code>, <code>max</code>, <code>range</code></li>
<li>Complex: <code>Arg</code>, <code>Conj</code>, <code>Im</code>, <code>Mod</code>, <code>Re</code></li>
</ul>
<p>Group generics are a relatively advanced technique and are beyond the scope of this chapter but you can find out more about them in <code>?groupGeneric</code>. The most important thing to take away from this is to recognise that <code>Math</code>, <code>Ops</code>, <code>Summary</code>, and <code>Complex</code> arenât real functions, but instead represent groups of functions. Note that inside a group generic function a special variable <code>.Generic</code> provides the actual generic function called.</p>
<p>If you have complex class hierarchies itâs sometimes useful to call the âparentâ method. Itâs a little bit tricky to define exactly what that means, but itâs basically the method that would have been called if the current method did not exist. Again, this is an advanced technique: you can read about it in <code>?NextMethod</code>.</p>
<p>Because methods are normal R functions, you can call them directly:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c &lt;- structure(list(), class = &quot;c&quot;)</span><br><span class="line"># Call the correct method:</span><br><span class="line">f.default(c)</span><br><span class="line"># Force R to call the wrong method:</span><br><span class="line">f.a(c)</span><br></pre></td></tr></table></figure>
<p>However, this is just as dangerous as changing the class of an object, so you shouldnât do it. Please donât point the loaded gun at your foot! The only reason to call the method directly is that sometimes you can get considerable performance improvements by skipping method dispatch. See <a href="#be-lazy">performance</a> for details.</p>
<p>You can also call an S3 generic with a non-S3 object. Non-internal S3 generics will dispatch on the <strong>implicit class</strong> of base types. (Internal generics donât do that for performance reasons.) The rules to determine the implicit class of a base type are somewhat complex, but are shown in the function below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">iclass &lt;- function(x) &#123;</span><br><span class="line">  if (is.object(x)) &#123;</span><br><span class="line">    stop(&quot;x is not a primitive type&quot;, call. = FALSE)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c(</span><br><span class="line">    if (is.matrix(x)) &quot;matrix&quot;,</span><br><span class="line">    if (is.array(x) &amp;&amp; !is.matrix(x)) &quot;array&quot;,</span><br><span class="line">    if (is.double(x)) &quot;double&quot;,</span><br><span class="line">    if (is.integer(x)) &quot;integer&quot;,</span><br><span class="line">    mode(x)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">iclass(matrix(1:5))</span><br><span class="line">iclass(array(1.5))</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-12"><a href="#Exercises-12" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Read the source code for <code>t()</code> and <code>t.test()</code> and confirm that    <code>t.test()</code> is an S3 generic and not an S3 method. What happens if    you create an object with class <code>test</code> and call <code>t()</code> with it?</li>
<li>What classes have a method for the <code>Math</code> group generic in base R? Read    the source code. How do the methods work?</li>
<li>R has two classes for representing date time data, <code>POSIXct</code> and    <code>POSIXlt</code>, which both inherit from <code>POSIXt</code>. Which generics have    different behaviours for the two classes? Which generics share the same    behaviour?</li>
<li>Which base generic has the greatest number of defined methods?</li>
<li><p><code>UseMethod()</code> calls methods in a special way. Predict what the following     code will return, then run it and read the help for <code>UseMethod()</code> to    figure out whatâs going on. Write down the rules in the simplest form    possible.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">y &lt;- 1</span><br><span class="line">g &lt;- function(x) &#123;</span><br><span class="line">  y &lt;- 2</span><br><span class="line">  UseMethod(&quot;g&quot;)</span><br><span class="line">&#125;</span><br><span class="line">g.numeric &lt;- function(x) y</span><br><span class="line">g(10)</span><br><span class="line"></span><br><span class="line">h &lt;- function(x) &#123;</span><br><span class="line">  x &lt;- 10</span><br><span class="line">  UseMethod(&quot;h&quot;)</span><br><span class="line">&#125;</span><br><span class="line">h.character &lt;- function(x) paste(&quot;char&quot;, x)</span><br><span class="line">h.numeric &lt;- function(x) paste(&quot;num&quot;, x)</span><br><span class="line"></span><br><span class="line">h(&quot;a&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Internal generics donât dispatch on the implicit class of base types.    Carefully read <code>?&quot;internal generic&quot;</code> to determine why the length of <code>f</code>    and <code>g</code> is different in the example below. What function helps    distinguish between the behaviour of <code>f</code> and <code>g</code>?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function() 1</span><br><span class="line">g &lt;- function() 2</span><br><span class="line">class(g) &lt;- &quot;function&quot;</span><br><span class="line"></span><br><span class="line">class(f)</span><br><span class="line">class(g)</span><br><span class="line"></span><br><span class="line">length.function &lt;- function(x) &quot;function&quot;</span><br><span class="line">length(f)</span><br><span class="line">length(g)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="S4"><a href="#S4" class="headerlink" title="S4"></a><a href="id=&quot;s4&quot;">S4</a></h2><p>S4 works in a similar way to S3, but it adds formality and rigour. Methods still belong to functions, not classes, but:</p>
<ul>
<li>Classes have formal definitions which describe their fields and  inheritance structures (parent classes).</li>
<li>Method dispatch can be based on multiple arguments to a generic function,  not just one.</li>
<li>There is a special operator, <code>@</code>, for extracting slots (aka fields)  from an S4 object.</li>
</ul>
<p>All S4 related code is stored in the <code>methods</code> package. This package is always available when youâre running R interactively, but may not be available when running R in batch mode. For this reason, itâs a good idea to include an explicit <code>library(methods)</code> whenever youâre using S4.</p>
<p>S4 is a rich and complex system. Thereâs no way to explain it fully in a few pages. Here Iâll focus on the key ideas underlying S4 so you can use existing S4 objects effectively. To learn more, some good references are:</p>
<ul>
<li><a href="http://www.bioconductor.org/help/course-materials/2010/AdvancedR/4InBioconductor.pdf" target="_blank" rel="external">S4 system development in Bioconductor</a></li>
<li>John Chambersâ <a href="http://amzn.com/0387759352?tag=devtools-20" target="_blank" rel="external"><em>Software for Data Analysis</em></a></li>
<li><a href="http://stackoverflow.com/search?tab=votes&amp;q=user%3a547331%20%5bs4%5d%20is%3aanswe" target="_blank" rel="external">Martin Morganâs answers to S4 questions on stackoverflow</a></li>
</ul>
<h3 id="Recognising-objects-generic-functions-and-methods-1"><a href="#Recognising-objects-generic-functions-and-methods-1" class="headerlink" title="Recognising objects, generic functions, and methods"></a>Recognising objects, generic functions, and methods</h3><p>Recognising S4 objects, generics, and methods is easy. You can identify an S4 object because <code>str()</code> describes it as a âformalâ class, <code>isS4()</code> returns <code>TRUE</code>, and <code>pryr::otype()</code> returns âS4â. S4 generics and methods are also easy to identify because they are S4 objects with well defined classes.</p>
<p>There arenât any S4 classes in the commonly used base packages (stats, graphics, utils, datasets, and base), so weâll start by creating an S4 object from the built-in stats4 package, which provides some S4 classes and methods associated with maximum likelihood estimation:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">library(stats4)</span><br><span class="line"></span><br><span class="line"># From example(mle)</span><br><span class="line">y &lt;- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)</span><br><span class="line">nLL &lt;- function(lambda) - sum(dpois(y, lambda, log = TRUE))</span><br><span class="line">fit &lt;- mle(nLL, start = list(lambda = 5), nobs = length(y))</span><br><span class="line"></span><br><span class="line"># An S4 object</span><br><span class="line">isS4(fit)</span><br><span class="line">otype(fit)</span><br><span class="line"></span><br><span class="line"># An S4 generic</span><br><span class="line">isS4(nobs)</span><br><span class="line">ftype(nobs)</span><br><span class="line"></span><br><span class="line"># Retrieve an S4 method, described later</span><br><span class="line">mle_nobs &lt;- method_from_call(nobs(fit))</span><br><span class="line">isS4(mle_nobs)</span><br><span class="line">ftype(mle_nobs)</span><br></pre></td></tr></table></figure>
<p>Use <code>is()</code> with one argument to list all classes that an object inherits from. Use <code>is()</code> with two arguments to test if an object inherits from a specific class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is(fit)</span><br><span class="line">is(fit, &quot;mle&quot;)</span><br></pre></td></tr></table></figure>
<p>You can get a list of all S4 generics with <code>getGenerics()</code>, and a list of all S4 classes with <code>getClasses()</code>. This list includes shim classes for S3 classes and base types. You can list all S4 methods with <code>showMethods()</code>, optionally restricting selection either by <code>generic</code> or by <code>class</code> (or both). Itâs also a good idea to supply <code>where = search()</code> to restrict the search to methods available in the global environment.</p>
<h3 id="Defining-classes-and-creating-objects-1"><a href="#Defining-classes-and-creating-objects-1" class="headerlink" title="Defining classes and creating objects"></a>Defining classes and creating objects</h3><p>In S3, you can turn any object into an object of a particular class just by setting the class attribute. S4 is much stricter: you must define the representation of a class with <code>setClass()</code>, and create a new object with <code>new()</code>. You can find the documentation for a class with a special syntax: <code>class?className</code>, e.g., <code>class?mle</code>.</p>
<p>An S4 class has three key properties:</p>
<ul>
<li>A <strong>name</strong>: an alpha-numeric class identifier. By convention, S4 class names  use UpperCamelCase.</li>
<li>A named list of <strong>slots</strong> (fields), which defines slot names and  permitted classes. For example, a person class might be represented by a  character name and a numeric age: <code>list(name = &quot;character&quot;, age = &quot;numeric&quot;)</code>.</li>
<li>A string giving the class it inherits from, or, in S4 terminology,  that it <strong>contains</strong>. You can provide multiple classes for multiple  inheritance, but this is an advanced technique which adds much  complexity.<br>In <code>slots</code> and <code>contains</code> you can use S4 classes, S3 classes registered  with <code>setOldClass()</code>, or the implicit class of a base type. In <code>slots</code>  you can also use the special class <code>ANY</code> which does not restrict the input.</li>
</ul>
<p>S4 classes have other optional properties like a <code>validity</code> method that tests if an object is valid, and a <code>prototype</code> object that defines default slot values. See <code>?setClass</code> for more details.</p>
<p>The following example creates a Person class with fields name and age, and an Employee class that inherits from Person. The Employee class inherits the slots and methods from the Person, and adds an additional slot, boss. To create objects we call <code>new()</code> with the name of the class, and name-value pairs of slot values.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setClass(&quot;Person&quot;,</span><br><span class="line">  slots = list(name = &quot;character&quot;, age = &quot;numeric&quot;))</span><br><span class="line">setClass(&quot;Employee&quot;,</span><br><span class="line">  slots = list(boss = &quot;Person&quot;),</span><br><span class="line">  contains = &quot;Person&quot;)</span><br><span class="line"></span><br><span class="line">alice &lt;- new(&quot;Person&quot;, name = &quot;Alice&quot;, age = 40)</span><br><span class="line">john &lt;- new(&quot;Employee&quot;, name = &quot;John&quot;, age = 20, boss = alice)</span><br></pre></td></tr></table></figure>
<p>Most S4 classes also come with a constructor function with the same name as the class: if that exists, use it instead of calling <code>new()</code> directly.</p>
<p>To access slots of an S4 object use <code>@</code> or <code>slot()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alice@age</span><br><span class="line">slot(john, &quot;boss&quot;)</span><br></pre></td></tr></table></figure>
<p>(<code>@</code> is equivalent to <code>$</code>, and <code>slot()</code> to <code>[[</code>.)</p>
<p>If an S4 object contains (inherits from) an S3 class or a base type, it will have a special <code>.Data</code> slot which contains the underlying base type or S3 object:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setClass(&quot;RangedNumeric&quot;,</span><br><span class="line">  contains = &quot;numeric&quot;,</span><br><span class="line">  slots = list(min = &quot;numeric&quot;, max = &quot;numeric&quot;))</span><br><span class="line">rn &lt;- new(&quot;RangedNumeric&quot;, 1:10, min = 1, max = 10)</span><br><span class="line">rn@min</span><br><span class="line">rn@.Data</span><br></pre></td></tr></table></figure>
<p>Since R is an interactive programming language, itâs possible to create new classes or redefine existing classes at any time. This can be a problem when youâre interactively experimenting with S4. If you modify a class, make sure you also recreate any objects of that class, otherwise youâll end up with invalid objects.</p>
<h3 id="Creating-new-methods-and-generics-1"><a href="#Creating-new-methods-and-generics-1" class="headerlink" title="Creating new methods and generics"></a>Creating new methods and generics</h3><p>S4 provides special functions for creating new generics and methods. <code>setGeneric()</code> creates a new generic or converts an existing function into a generic. <code>setMethod()</code> takes the name of the generic, the classes the method should be associated with, and a function that implements the method. For example, we could take <code>union()</code>, which usually just works on vectors, and make it work with data frames:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setGeneric(&quot;union&quot;)</span><br><span class="line">setMethod(&quot;union&quot;,</span><br><span class="line">  c(x = &quot;data.frame&quot;, y = &quot;data.frame&quot;),</span><br><span class="line">  function(x, y) &#123;</span><br><span class="line">    unique(rbind(x, y))</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>If you create a new generic from scratch, you need to supply a function that calls <code>standardGeneric()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setGeneric(&quot;myGeneric&quot;, function(x) &#123;</span><br><span class="line">  standardGeneric(&quot;myGeneric&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>standardGeneric()</code> is the S4 equivalent to <code>UseMethod()</code>.</p>
<h3 id="Method-dispatch-1"><a href="#Method-dispatch-1" class="headerlink" title="Method dispatch"></a>Method dispatch</h3><p>If an S4 generic dispatches on a single class with a single parent, then S4 method dispatch is the same as S3 dispatch. The main difference is how you set up default values: S4 uses the special class <code>ANY</code> to match any class and âmissingâ to match a missing argument. Like S3, S4 also has group generics, documented in <code>?S4groupGeneric</code>, and a way to call the âparentâ method, <code>callNextMethod()</code>.</p>
<p>Method dispatch becomes considerably more complicated if you dispatch on multiple arguments, or if your classes use multiple inheritance. The rules are described in <code>?Methods</code>, but they are complicated and itâs difficult to predict which method will be called. For this reason, I strongly recommend avoiding multiple inheritance and multiple dispatch unless absolutely necessary.</p>
<p>Finally, there are two methods that find which method gets called given the specification of a generic call:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># From methods: takes generic name and class names</span><br><span class="line">selectMethod(&quot;nobs&quot;, list(&quot;mle&quot;))</span><br><span class="line"></span><br><span class="line"># From pryr: takes an unevaluated function call</span><br><span class="line">method_from_call(nobs(fit))</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-13"><a href="#Exercises-13" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Which S4 generic has the most methods defined for it? Which S4 class    has the most methods associated with it?</li>
<li>What happens if you define a new S4 class that doesnât âcontainâ an    existing class?  (Hint: read about virtual classes in <code>?Classes</code>.)</li>
<li>What happens if you pass an S4 object to an S3 generic? What happens    if you pass an S3 object to an S4 generic? (Hint: read <code>?setOldClass</code>    for the second case.)</li>
</ol>
<h2 id="RC"><a href="#RC" class="headerlink" title="RC"></a><a href="id=&quot;rc&quot;">RC</a></h2><p>Reference classes (or RC for short) are the newest OO system in R. They were introduced in version 2.12. They are fundamentally different to S3 and S4 because:</p>
<ul>
<li>RC methods belong to objects, not functions</li>
<li>RC objects are mutable: the usual R copy-on-modify semantics do not apply</li>
</ul>
<p>These properties make RC objects behave more like objects do in most other programming languages, e.g., Python, Ruby, Java, and C#. Reference classes are implemented using R code: they are a special S4 class that wraps around an environment.</p>
<h3 id="Defining-classes-and-creating-objects-2"><a href="#Defining-classes-and-creating-objects-2" class="headerlink" title="Defining classes and creating objects"></a>Defining classes and creating objects</h3><p>Since there arenât any reference classes provided by the base R packages, weâll start by creating one. RC classes are best used for describing stateful objects, objects that change over time, so weâll create a simple class to model a bank account.</p>
<p>Creating a new RC class is similar to creating a new S4 class, but you use <code>setRefClass()</code> instead of <code>setClass()</code>. The first, and only required argument, is an alphanumeric <strong>name</strong>. While you can use <code>new()</code> to create new RC objects, itâs good style to use the object returned by <code>setRefClass()</code> to generate new objects. (You can also do that with S4 classes, but itâs less common.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Account &lt;- setRefClass(&quot;Account&quot;)</span><br><span class="line">Account$new()</span><br></pre></td></tr></table></figure>
<p><code>setRefClass()</code> also accepts a list of name-class pairs that define class <strong>fields</strong> (equivalent to S4 slots). Additional named arguments passed to <code>new()</code> will set initial values of the fields. You can get and set field values with <code>$</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Account &lt;- setRefClass(&quot;Account&quot;,</span><br><span class="line">  fields = list(balance = &quot;numeric&quot;))</span><br><span class="line"></span><br><span class="line">a &lt;- Account$new(balance = 100)</span><br><span class="line">a$balance</span><br><span class="line">a$balance &lt;- 200</span><br><span class="line">a$balance</span><br></pre></td></tr></table></figure>
<p>Instead of supplying a class name for the field, you can provide a single argument function which will act as an accessor method. This allows you to add custom behaviour when getting or setting a field. See <code>?setRefClass</code> for more details.</p>
<p>Note that RC objects are <strong>mutable</strong>, i.e., they have reference semantics, and are not copied-on-modify:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b &lt;- a</span><br><span class="line">b$balance</span><br><span class="line">a$balance &lt;- 0</span><br><span class="line">b$balance</span><br></pre></td></tr></table></figure>
<p>For this reason, RC objects come with a <code>copy()</code> method that allow you to make a copy of the object:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c &lt;- a$copy()</span><br><span class="line">c$balance</span><br><span class="line">a$balance &lt;- 100</span><br><span class="line">c$balance</span><br></pre></td></tr></table></figure>
<p>An object is not very useful without some behaviour defined by <strong>methods</strong>. RC methods are associated with a class and can modify its fields in place. In the following example, note that you access the value of fields with their name, and modify them with <code>&lt;&lt;-</code>. Youâll learn more about <code>&lt;&lt;-</code> in <a href="#binding">Environments</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Account &lt;- setRefClass(&quot;Account&quot;,</span><br><span class="line">  fields = list(balance = &quot;numeric&quot;),</span><br><span class="line">  methods = list(</span><br><span class="line">    withdraw = function(x) &#123;</span><br><span class="line">      balance &lt;&lt;- balance - x</span><br><span class="line">    &#125;,</span><br><span class="line">    deposit = function(x) &#123;</span><br><span class="line">      balance &lt;&lt;- balance + x</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>You call an RC method in the same way as you access a field:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- Account$new(balance = 100)</span><br><span class="line">a$deposit(100)</span><br><span class="line">a$balance</span><br></pre></td></tr></table></figure>
<p>The final important argument to <code>setRefClass()</code> is <code>contains</code>. This is the name of the parent RC class to inherit behaviour from. The following example creates a new type of bank account that returns an error preventing the balance from going below 0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NoOverdraft &lt;- setRefClass(&quot;NoOverdraft&quot;,</span><br><span class="line">  contains = &quot;Account&quot;,</span><br><span class="line">  methods = list(</span><br><span class="line">    withdraw = function(x) &#123;</span><br><span class="line">      if (balance &lt; x) stop(&quot;Not enough money&quot;)</span><br><span class="line">      balance &lt;&lt;- balance - x</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line">accountJohn &lt;- NoOverdraft$new(balance = 100)</span><br><span class="line">accountJohn$deposit(50)</span><br><span class="line">accountJohn$balance</span><br><span class="line">accountJohn$withdraw(200)</span><br></pre></td></tr></table></figure>
<p>All reference classes eventually inherit from <code>envRefClass</code>. It provides useful methods like <code>copy()</code> (shown above), <code>callSuper()</code> (to call the parent field), <code>field()</code> (to get the value of a field given its name), <code>export()</code> (equivalent to <code>as()</code>), and <code>show()</code> (overridden to control printing). See the inheritance section in <code>setRefClass()</code> for more details.</p>
<h3 id="Recognising-objects-and-methods"><a href="#Recognising-objects-and-methods" class="headerlink" title="Recognising objects and methods"></a>Recognising objects and methods</h3><p>You can recognise RC objects because they are S4 objects (<code>isS4(x)</code>) that inherit from ârefClassâ (<code>is(x, &quot;refClass&quot;)</code>). <code>pryr::otype()</code> will return âRCâ.  RC methods are also S4 objects, with class <code>refMethodDef</code>.</p>
<h3 id="Method-dispatch-2"><a href="#Method-dispatch-2" class="headerlink" title="Method dispatch"></a>Method dispatch</h3><p>Method dispatch is very simple in RC because methods are associated with classes, not functions. When you call <code>x$f()</code>, R will look for a method f in the class of x, then in its parent, then its parentâs parent, and so on. From within a method, you can call the parent method directly with <code>callSuper(...)</code>.</p>
<h3 id="Exercises-14"><a href="#Exercises-14" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Use a field function to prevent the account balance from being directly    manipulated. (Hint: create a âhiddenâ <code>.balance</code> field, and read the    help for the fields argument in <code>setRefClass()</code>.)</li>
<li>I claimed that there arenât any RC classes in base R, but that was a    bit of a simplification. Use <code>getClasses()</code> and find which classes    <code>extend()</code> from <code>envRefClass</code>. What are the classes used for? (Hint:    recall how to look up the documentation for a class.)</li>
</ol>
<h2 id="Picking-a-system"><a href="#Picking-a-system" class="headerlink" title="Picking a system"></a><a href="id=&quot;picking-a-system&quot;">Picking a system</a></h2><p>Three OO systems is a lot for one language, but for most R programming, S3 suffices. In R you usually create fairly simple objects and methods for pre-existing generic functions like <code>print()</code>, <code>summary()</code>, and <code>plot()</code>. S3 is well suited to this task, and the majority of OO code that I have written in R is S3. S3 is a little quirky, but it gets the job done with a minimum of code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">packageVersion(&quot;Matrix&quot;)</span><br><span class="line"></span><br><span class="line">library(Matrix)</span><br><span class="line">gs &lt;- getGenerics(&quot;package:Matrix&quot;)</span><br><span class="line">sum(gs@package == &quot;Matrix&quot;)</span><br><span class="line"></span><br><span class="line">length(getClasses(&quot;package:Matrix&quot;, FALSE))</span><br></pre></td></tr></table></figure>
<p>If you are creating more complicated systems of interrelated objects, S4 may be more appropriate. A good example is the <code>Matrix</code> package by Douglas Bates and Martin Maechler. It is designed to efficiently store and compute with many different types of sparse matrices. As of version 1.1.3, it defines 102 classes and 20 generic functions. The package is well written and well commented, and the accompanying vignette (<code>vignette(&quot;Intro2Matrix&quot;, package = &quot;Matrix&quot;)</code>) gives a good overview of the structure of the package. S4 is also used extensively by Bioconductor packages, which need to model complicated interrelationships between biological objects. Bioconductor provides many <a href="https://www.google.com/search?q=bioconductor+s4" target="_blank" rel="external">good resources</a> for learning S4. If youâve mastered S3, S4 is relatively easy to pick up; the ideas are all the same, it is just more formal, more strict, and more verbose.</p>
<p>If youâve programmed in a mainstream OO language, RC will seem very natural. But because they can introduce side effects through mutable state, they are harder to understand. For example, when you usually call <code>f(a, b)</code> in R you can assume that <code>a</code> and <code>b</code> will not be modified. But if <code>a</code> and <code>b</code> are RC objects, they might be modified in the place. Generally, when using RC objects you want to minimise side effects as much as possible, and use them only where mutable states are absolutely required. The majority of functions should still be âfunctionalâ, and free of side effects. This makes code easier to reason about and easier for other R programmers to understand.</p>
<h2 id="Quiz-answers-1"><a href="#Quiz-answers-1" class="headerlink" title="Quiz answers"></a><a href="id=&quot;oo-answers&quot;">Quiz answers</a></h2><ol>
<li>To determine the OO system of an object, you use a process of elimination.    If <code>!is.object(x)</code>, itâs a base object. If <code>!isS4(x)</code>, itâs S3. If    <code>!is(x, &quot;refClass&quot;)</code>, itâs S4; otherwise itâs RC.</li>
<li>Use <code>typeof()</code> to determine the base class of an object.</li>
<li>A generic function calls specific methods depending on the class of    it inputs. In S3 and S4 object systems, methods belong to generic    functions, not classes like in other programming languages.</li>
<li>S4 is more formal than S3, and supports multiple inheritance and    multiple dispatch. RC objects have reference semantics, and methods    belong to classes, not functions.</li>
</ol>
<hr>
<h1 id="Environments"><a href="#Environments" class="headerlink" title="Environments"></a><a href="id=&quot;environments&quot;">Environments</a></h1><p>The environment is the data structure that powers scoping. This chapter dives deep into environments, describing their structure in depth, and using them to improve your understanding of the four scoping rules described in <a href="#lexical-scoping">lexical scoping</a>.</p>
<p>Environments can also be useful data structures in their own right because they have reference semantics. When you modify a binding in an environment, the environment is not copied; itâs modified in place. Reference semantics are not often needed, but can be extremely useful.</p>
<h5 id="Quiz-4"><a href="#Quiz-4" class="headerlink" title="Quiz"></a>Quiz</h5><p>If you can answer the following questions correctly, you already know the most important topics in this chapter. You can find the answers at the end of the chapter in <a href="#env-answers">answers</a>.</p>
<ol>
<li>List at least three ways that an environment is different to a list.</li>
<li>What is the parent of the global environment? What is the only    environment that doesnât have a parent?</li>
<li>What is the enclosing environment of a function? Why is it    important?</li>
<li>How do you determine the environment from which a function was called?</li>
<li>How are <code>&lt;-</code> and <code>&lt;&lt;-</code> different?</li>
</ol>
<h5 id="Outline-4"><a href="#Outline-4" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#env-basics">Environment basics</a> introduces you to the basic properties  of an environment and shows you how to create your own.</li>
<li><a href="#env-recursion">Recursing over environments</a> provides a function template  for computing with environments, illustrating the idea with a useful  function.</li>
<li><a href="#function-envs">Function environments</a> revises Râs scoping rules in more  depth, showing how they correspond to four types of environment associated  with each function.</li>
<li><a href="#binding">Binding names to values</a> describes the rules that names must  follow (and how to bend them), and shows some variations on binding a  name to a value.</li>
<li><a href="#explicit-envs">Explicit environments</a> discusses three problems where  environments are useful data structures in their own right, independent  of the role they place in scoping.</li>
</ul>
<h5 id="Prerequisites-2"><a href="#Prerequisites-2" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><p>This chapter uses many functions from the <code>pryr</code> package to pry open R and look inside at the messy details. You can install <code>pryr</code> by running <code>install.packages(&quot;pryr&quot;)</code></p>
<h2 id="Environment-basics"><a href="#Environment-basics" class="headerlink" title="Environment basics"></a><a href="id=&quot;env-basics&quot;">Environment basics</a></h2><p>The job of an environment is to associate, or <strong>bind</strong>, a set of names to a set of values. You can think of an environment as a bag of names:</p>
<p><img src="diagrams/environments.png/bag-of-names.png" alt=""></p>
<p>Each name points to an object stored elsewhere in memory:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e &lt;- new.env()</span><br><span class="line">e$a &lt;- FALSE</span><br><span class="line">e$b &lt;- &quot;a&quot;</span><br><span class="line">e$c &lt;- 2.3</span><br><span class="line">e$d &lt;- 1:3</span><br></pre></td></tr></table></figure>
<p><img src="diagrams/environments.png/bindings.png" alt=""></p>
<p>The objects donât live in the environment so multiple names can point to the same object:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e$a &lt;- e$d</span><br></pre></td></tr></table></figure>
<p><img src="diagrams/environments.png/multiple-names.png" alt=""></p>
<p>Confusingly they can also point to different objects that have the same value:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e$a &lt;- 1:3</span><br></pre></td></tr></table></figure>
<p><img src="diagrams/environments.png/copies.png" alt=""></p>
<p>If an object has no names pointing to it, it gets automatically deleted by the garbage collector. This process is described in more detail in <a href="#gc">gc</a>.</p>
<p>Every environment has a parent, another environment. In diagrams, Iâll represent the pointer to parent with a small black circle. The parent is used to implement lexical scoping: if a name is not found in an environment, then R will look in its parent (and so on). Only one environment doesnât have a parent: the <strong>empty</strong> environment.</p>
<p><img src="diagrams/environments.png/parents.png" alt=""></p>
<p>We use the metaphor of a family to refer to environments. The grandparent of an environment is the parentâs parent, and the ancestors include all parent environments up to the empty environment. Itâs rare to talk about the children of an environment because there are no back links: given an environment we have no way to find its children.</p>
<p>Generally, an environment is similar to a list, with four important exceptions:</p>
<ul>
<li>Every object in an environment has a unique name.</li>
<li>The objects in an environment are not ordered (i.e., it doesnât make sense    to ask what the first object in an environment is).</li>
<li>An environment has a parent.</li>
<li>Environments have reference semantics.</li>
</ul>
<p>More technically, an environment is made up of two components, the <strong>frame</strong>, which contains the name-object bindings (and behaves much like a named list), and the parent environment. Unfortunately âframeâ is used inconsistently in R. For example, <code>parent.frame()</code> doesnât give you the parent frame of an environment. Instead, it gives you the <em>calling</em> environment. This is discussed in more detail in <a href="#calling-environments">calling environments</a>.</p>
<p>There are four special environments:</p>
<ul>
<li>The <code>globalenv()</code>, or global environment, is the interactive workspace.  This is the environment in which you normally work. The parent of the  global environment is the last package that you attached with <code>library()</code>  or <code>require()</code>.</li>
<li>The <code>baseenv()</code>, or base environment, is the environment of the base package.  Its parent is the empty environment.</li>
<li>The <code>emptyenv()</code>, or empty environment, is the ultimate ancestor of all  environments, and the only  environment without a parent.</li>
<li>The <code>environment()</code> is the current environment.</li>
</ul>
<p><code>search()</code> lists all parents of the global environment. This is called the search path because objects in these environments can be found from the top-level interactive workspace. It contains one environment for each attached package and any other objects that youâve <code>attach()</code>ed. It also contains a special environment called <code>Autoloads</code> which is used to save memory by only loading package objects (like big datasets) when needed.</p>
<p>You can access any environment on the search list using <code>as.environment()</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">search()</span><br><span class="line">#&gt; [1] &quot;.GlobalEnv&quot;        &quot;package:stats&quot;     &quot;package:graphics&quot;</span><br><span class="line">#&gt; [4] &quot;package:grDevices&quot; &quot;package:utils&quot;     &quot;package:datasets&quot;</span><br><span class="line">#&gt; [7] &quot;package:methods&quot;   &quot;Autoloads&quot;         &quot;package:base&quot;</span><br><span class="line"></span><br><span class="line">as.environment(&quot;package:stats&quot;)</span><br><span class="line">#&gt; &lt;environment: package:stats&gt;</span><br></pre></td></tr></table></figure>
<p><code>globalenv()</code>, <code>baseenv()</code>, the environments on the search path, and <code>emptyenv()</code> are connected as shown below. Each time you load a new package with <code>library()</code> it is inserted between the global environment and the package that was previously at the top of the search path.</p>
<p><img src="diagrams/environments.png/search-path.png" alt=""></p>
<p>To create an environment manually, use <code>new.env()</code>. You can list the bindings in the environmentâs frame with <code>ls()</code> and see its parent with <code>parent.env()</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e &lt;- new.env()</span><br><span class="line"># the default parent provided by new.env() is environment from</span><br><span class="line"># which it is called - in this case that&apos;s the global environment.</span><br><span class="line">parent.env(e)</span><br><span class="line">ls(e)</span><br></pre></td></tr></table></figure>
<p>The easiest way to modify the bindings in an environment is to treat it like a list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e$a &lt;- 1</span><br><span class="line">e$b &lt;- 2</span><br><span class="line">ls(e)</span><br><span class="line">e$a</span><br></pre></td></tr></table></figure>
<p>By default, <code>ls()</code> only shows names that donât begin with <code>.</code>. Use <code>all.names = TRUE</code> to show all bindings in an environment:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e$.a &lt;- 2</span><br><span class="line">ls(e)</span><br><span class="line">ls(e, all.names = TRUE)</span><br></pre></td></tr></table></figure>
<p>Another useful way to view an environment is <code>ls.str()</code>. It is more useful than <code>str()</code> because it shows each object in the environment. Like <code>ls()</code>, it also has an <code>all.names</code> argument.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str(e)</span><br><span class="line">ls.str(e)</span><br></pre></td></tr></table></figure>
<p>Given a name, you can extract the value to which it is bound with <code>$</code>, <code>[[</code>, or <code>get()</code>:</p>
<ul>
<li><code>$</code> and <code>[[</code> look only in one environment and return <code>NULL</code> if there is no  binding associated with the name.</li>
<li><code>get()</code> uses the regular scoping rules and throws an error if the binding is  not found.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e$c &lt;- 3</span><br><span class="line">e$c</span><br><span class="line">e[[&quot;c&quot;]]</span><br><span class="line">get(&quot;c&quot;, envir = e)</span><br></pre></td></tr></table></figure>
<p>Deleting objects from environments works a little differently from lists. With a list you can remove an entry by setting it to <code>NULL</code>. In environments, that will create a new binding to <code>NULL</code>. Instead, use <code>rm()</code> to remove the binding.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e &lt;- new.env()</span><br><span class="line"></span><br><span class="line">e$a &lt;- 1</span><br><span class="line">e$a &lt;- NULL</span><br><span class="line">ls(e)</span><br><span class="line"></span><br><span class="line">rm(&quot;a&quot;, envir = e)</span><br><span class="line">ls(e)</span><br></pre></td></tr></table></figure>
<p>You can determine if a binding exists in an environment with <code>exists()</code>. Like <code>get()</code>, its default behaviour is to follow the regular scoping rules and look in parent environments. If you donât want this behavior, use <code>inherits = FALSE</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 10</span><br><span class="line">exists(&quot;x&quot;, envir = e)</span><br><span class="line">exists(&quot;x&quot;, envir = e, inherits = FALSE)</span><br></pre></td></tr></table></figure>
<p>To compare environments, you must use <code>identical()</code> not <code>==</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">identical(globalenv(), environment())</span><br><span class="line">globalenv() == environment()</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-15"><a href="#Exercises-15" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>List three ways in which an environment differs from a list.</li>
<li>If you donât supply an explicit environment, where do <code>ls()</code> and <code>rm()</code>    look? Where does <code>&lt;-</code> make bindings?</li>
<li>Using <code>parent.env()</code> and a loop (or a recursive function), verify that the    ancestors of <code>globalenv()</code> include <code>baseenv()</code> and <code>emptyenv()</code>. Use the    same basic idea to implement your own version of <code>search()</code>.</li>
</ol>
<h2 id="Recursing-over-environments"><a href="#Recursing-over-environments" class="headerlink" title="Recursing over environments"></a><a href="id=&quot;env-recursion&quot;">Recursing over environments</a></h2><p>Environments form a tree, so itâs often convenient to write a recursive function. This section shows you how by applying your new knowledge of environments to understand the helpful <code>pryr::where()</code>. Given a name, <code>where()</code> finds the environment <em>where</em> that name is defined, using Râs regular scoping rules:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library(pryr)</span><br><span class="line">x &lt;- 5</span><br><span class="line">where(&quot;x&quot;)</span><br><span class="line">where(&quot;mean&quot;)</span><br></pre></td></tr></table></figure>
<p>The definition of <code>where()</code> is straightforward. It has two arguments: the name to look for (as a string), and the environment in which to start the search. (Weâll learn later why <code>parent.frame()</code> is a good default in <a href="#calling-environments">calling environments</a>.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">where &lt;- function(name, env = parent.frame()) &#123;</span><br><span class="line">  if (identical(env, emptyenv())) &#123;</span><br><span class="line">    # Base case</span><br><span class="line">    stop(&quot;Can&apos;t find &quot;, name, call. = FALSE)</span><br><span class="line"></span><br><span class="line">  &#125; else if (exists(name, envir = env, inherits = FALSE)) &#123;</span><br><span class="line">    # Success case</span><br><span class="line">    env</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    # Recursive case</span><br><span class="line">    where(name, parent.env(env))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There are three cases:</p>
<ul>
<li>The base case: weâve reached the empty environment and havenât found the  binding. We canât go any further, so we throw an error.</li>
<li>The successful case: the name exists in this environment, so we return the  environment.</li>
<li>The recursive case: the name was not found in this environment, so try the  parent.</li>
</ul>
<p>Itâs easier to see whatâs going on with an example. Imagine you have two environments as in the following diagram:</p>
<p><img src="diagrams/environments.png/where-ex.png" alt=""></p>
<ul>
<li>If youâre looking for <code>a</code>, <code>where()</code> will find it in the first environment.</li>
<li>If youâre looking for <code>b</code>, itâs not in the first environment,  so <code>where()</code> will look in its parent and find it there.</li>
<li>If youâre looking for <code>c</code>, itâs not in the first environment, or the  second environment, so <code>where()</code> reaches the empty environment  and throws an error.</li>
</ul>
<p>Itâs natural to work with environments recursively, so <code>where()</code> provides a useful template. Removing the specifics of <code>where()</code> shows the structure more clearly:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(..., env = parent.frame()) &#123;</span><br><span class="line">  if (identical(env, emptyenv())) &#123;</span><br><span class="line">    # base case</span><br><span class="line">  &#125; else if (success) &#123;</span><br><span class="line">    # success case</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    # recursive case</span><br><span class="line">    f(..., env = parent.env(env))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin_sidebar(&quot;Iteration vs. recursion&quot;)</span><br></pre></td></tr></table></figure>
<p>Itâs possible to use a loop instead of recursion. This might run slightly faster (because we eliminate some function calls), but I think itâs harder to understand. I include it because you might find it easier to see whatâs happening if youâre less familiar with recursive functions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">is_empty &lt;- function(x) identical(x, emptyenv())</span><br><span class="line"></span><br><span class="line">f2 &lt;- function(..., env = parent.frame()) &#123;</span><br><span class="line">  while(!is_empty(env)) &#123;</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      # success case</span><br><span class="line">      return()</span><br><span class="line">    &#125;</span><br><span class="line">    # inspect parent</span><br><span class="line">    env &lt;- parent.env(env)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # base case</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end_sidebar()</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-16"><a href="#Exercises-16" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Modify <code>where()</code> to find all environments that contain a binding for    <code>name</code>.</li>
<li>Write your own version of <code>get()</code> using a function written in the style    of <code>where()</code>.</li>
<li>Write a function called <code>fget()</code> that finds only function objects. It    should have two arguments, <code>name</code> and <code>env</code>, and should obey the regular    scoping rules for functions: if thereâs an object with a matching name    thatâs not a function, look in the parent. For an added challenge, also    add an <code>inherits</code> argument which controls whether the function recurses up<br>the parents or only looks in one environment.</li>
<li>Write your own version of <code>exists(inherits = FALSE)</code> (Hint: use <code>ls()</code>.)    Write a recursive version that behaves like <code>exists(inherits = TRUE)</code>.</li>
</ol>
<h2 id="Function-environments"><a href="#Function-environments" class="headerlink" title="Function environments"></a><a href="id=&quot;function-envs&quot;">Function environments</a></h2><p>Most environments are not created by you with <code>new.env()</code> but are created as a consequence of using functions. This section discusses the four types of environments associated with a function: enclosing, binding, execution, and calling.</p>
<p>The <strong>enclosing</strong> environment is the environment where the function was created. Every function has one and only one enclosing environment. For the three other types of environment, there may be 0, 1, or many environments associated with each function:</p>
<ul>
<li>Binding a function to a name with <code>&lt;-</code> defines a <strong>binding</strong> environment.</li>
<li>Calling a function creates an ephemeral <strong>execution</strong> environment  that stores variables created during execution.</li>
<li>Every execution environment is associated with a <strong>calling</strong> environment,  which tells you where the function was called.</li>
</ul>
<p>The following sections will explain why each of these environments is important, how to access them, and how you might use them.</p>
<h3 id="The-enclosing-environment"><a href="#The-enclosing-environment" class="headerlink" title="The enclosing environment"></a>The enclosing environment</h3><p>When a function is created, it gains a reference to the environment where it was made. This is the <strong>enclosing environment</strong> and is used for lexical scoping. You can determine the enclosing environment of a function by calling <code>environment()</code> with a function as its first argument:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y &lt;- 1</span><br><span class="line">f &lt;- function(x) x + y</span><br><span class="line">environment(f)</span><br><span class="line">#&gt; &lt;environment: R_GlobalEnv&gt;</span><br></pre></td></tr></table></figure>
<p>In diagrams, Iâll depict functions as rounded rectangles. The enclosing environment of a function is given by a small black circle:</p>
<p><img src="diagrams/environments.png/enclosing.png" alt=""></p>
<h3 id="Binding-environments"><a href="#Binding-environments" class="headerlink" title="Binding environments"></a>Binding environments</h3><p>The previous diagram is too simple because functions donât have names. Instead, the name of a function is defined by a binding. The binding environments of a function are all the environments which have a binding to it. The following diagram better reflects this relationship because the enclosing environment contains a binding from <code>f</code> to the function:</p>
<p><img src="diagrams/environments.png/binding.png" alt=""></p>
<p>In this case the enclosing and binding environments are the same.  They will be different if you assign a function into a different environment:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e &lt;- new.env()</span><br><span class="line">e$g &lt;- function() 1</span><br></pre></td></tr></table></figure>
<p><img src="diagrams/environments.png/binding-2.png" alt=""></p>
<p>The enclosing environment belongs to the function, and never changes, even if the function is moved to a different environment. The enclosing environment determines how the function finds values; the binding environments determine how we find the function.</p>
<p>The distinction between the binding environment and the enclosing environment is important for package namespaces. Package namespaces keep packages independent. For example, if package A uses the base <code>mean()</code> function, what happens if package B creates its own <code>mean()</code> function? Namespaces ensure that package A continues to use the base <code>mean()</code> function, and that package A is not affected by package B (unless explicitly asked for).</p>
<p>Namespaces are implemented using environments, taking advantage of the fact that functions donât have to live in their enclosing environments. For example, take the base function <code>sd()</code>. Itâs binding and enclosing environments are different:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">environment(sd)</span><br><span class="line">#&gt; &lt;environment: namespace:stats&gt;</span><br><span class="line">where(&quot;sd&quot;)</span><br><span class="line">#&gt; &lt;environment: package:stats&gt;</span><br></pre></td></tr></table></figure>
<p>The definition of <code>sd()</code> uses <code>var()</code>, but if we make our own version of <code>var()</code> it doesnât affect <code>sd()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1:10</span><br><span class="line">sd(x)</span><br><span class="line">var &lt;- function(x, na.rm = TRUE) 100</span><br><span class="line">sd(x)</span><br></pre></td></tr></table></figure>
<p>This works because every package has two environments associated with it: the <em>package</em> environment and the <em>namespace</em> environment. The package environment contains every publicly accessible function, and is placed on the search path. The namespace environment contains all functions (including internal functions), and its parent environment is a special imports environment that contains bindings to all the functions that the package needs. Every exported function in a package is bound into the <em>package</em> environment, but enclosed by the <em>namespace</em> environment. This complicated relationship is illustrated by the following diagram:</p>
<p><img src="diagrams/environments.png/namespace.png" alt=""></p>
<p>When we type <code>var</code> into the console, itâs found first in the global environment. When <code>sd()</code> looks for <code>var()</code> it finds it first in its namespace environment so never looks in the <code>globalenv()</code>.</p>
<h3 id="Execution-environments"><a href="#Execution-environments" class="headerlink" title="Execution environments"></a>Execution environments</h3><p>What will the following function return the first time itâs run? What about the second?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">g &lt;- function(x) &#123;</span><br><span class="line">  if (!exists(&quot;a&quot;, inherits = FALSE)) &#123;</span><br><span class="line">    message(&quot;Defining a&quot;)</span><br><span class="line">    a &lt;- 1</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    a &lt;- a + 1</span><br><span class="line">  &#125;</span><br><span class="line">  a</span><br><span class="line">&#125;</span><br><span class="line">g(10)</span><br><span class="line">g(10)</span><br></pre></td></tr></table></figure>
<p>This function returns the same value every time it is called because of the fresh start principle, described in <a href="#fresh-start">a fresh start</a>. Each time a function is called, a new environment is created to host execution. The parent of the execution environment is the enclosing environment of the function. Once the function has completed, this environment is thrown away.</p>
<p>Letâs depict that graphically with a simpler function. I draw execution environments around the function they belong to with a dotted border.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h &lt;- function(x) &#123;</span><br><span class="line">  a &lt;- 2</span><br><span class="line">  x + a</span><br><span class="line">&#125;</span><br><span class="line">y &lt;- h(1)</span><br></pre></td></tr></table></figure>
<p><img src="diagrams/environments.png/execution.png" alt=""></p>
<p>When you create a function inside another function, the enclosing environment of the child function is the execution environment of the parent, and the execution environment is no longer ephemeral. The following example illustrates that idea with a function factory, <code>plus()</code>. We use that factory to create a function called <code>plus_one()</code>. The enclosing environment of <code>plus_one()</code> is the execution environment of <code>plus()</code> where <code>x</code> is bound to the value 1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plus &lt;- function(x) &#123;</span><br><span class="line">  function(y) x + y</span><br><span class="line">&#125;</span><br><span class="line">plus_one &lt;- plus(1)</span><br><span class="line">identical(parent.env(environment(plus_one)), environment(plus))</span><br></pre></td></tr></table></figure>
<p><img src="diagrams/environments.png/closure-2.png" alt=""></p>
<p>Youâll learn more about function factories in <a href="#functional-programming">functional programming</a>.</p>
<h3 id="Calling-environments"><a href="#Calling-environments" class="headerlink" title="Calling environments"></a><a href="id=&quot;calling-environments&quot;">Calling environments</a></h3><p>Look at the following code. What do you expect <code>i()</code> to return when the code is run?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">h &lt;- function() &#123;</span><br><span class="line">  x &lt;- 10</span><br><span class="line">  function() &#123;</span><br><span class="line">    x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">i &lt;- h()</span><br><span class="line">x &lt;- 20</span><br><span class="line">i()</span><br></pre></td></tr></table></figure>
<p>The top-level <code>x</code> (bound to 20) is a red herring: using the regular scoping rules, <code>h()</code> looks first where it is defined and finds that the value associated with <code>x</code> is 10. However, itâs still meaningful to ask what value <code>x</code> is associated within the environment where <code>i()</code> is called: <code>x</code> is 10 in the environment where <code>h()</code> is defined, but it is 20 in the environment where <code>h()</code> is called.</p>
<p>We can access this environment using the unfortunately named <code>parent.frame()</code>. This function returns the <strong>environment</strong> where the function was called. We can also use this function to look up the value of names in that environment:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f2 &lt;- function() &#123;</span><br><span class="line">  x &lt;- 10</span><br><span class="line">  function() &#123;</span><br><span class="line">    def &lt;- get(&quot;x&quot;, environment())</span><br><span class="line">    cll &lt;- get(&quot;x&quot;, parent.frame())</span><br><span class="line">    list(defined = def, called = cll)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">g2 &lt;- f2()</span><br><span class="line">x &lt;- 20</span><br><span class="line">str(g2())</span><br></pre></td></tr></table></figure>
<p>In more complicated scenarios, thereâs not just one parent call, but a sequence of calls which lead all the way back to the initiating function, called from the top-level.  The following code generates a call stack three levels deep. The open-ended arrows represent the calling environment of each execution environment.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 0</span><br><span class="line">y &lt;- 10</span><br><span class="line">f &lt;- function() &#123;</span><br><span class="line">  x &lt;- 1</span><br><span class="line">  g()</span><br><span class="line">&#125;</span><br><span class="line">g &lt;- function() &#123;</span><br><span class="line">  x &lt;- 2</span><br><span class="line">  h()</span><br><span class="line">&#125;</span><br><span class="line">h &lt;- function() &#123;</span><br><span class="line">  x &lt;- 3</span><br><span class="line">  x + y</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p><img src="diagrams/environments.png/calling.png" alt=""></p>
<p>Note that each execution environment has two parents: a calling environment and an enclosing environment. Râs regular scoping rules only use the enclosing parent; <code>parent.frame()</code> allows you to access the calling parent.</p>
<p>Looking up variables in the calling environment rather than in the enclosing environment is called <strong>dynamic scoping</strong>. Few languages implement dynamic scoping (Emacs Lisp is a <a href="http://www.gnu.org/software/emacs/emacs-paper.html#SEC15" target="_blank" rel="external">notable exception</a>.) This is because dynamic scoping makes it much harder to reason about how a function operates: not only do you need to know how it was defined, you also need to know in what context it was called. Dynamic scoping is primarily useful for developing functions that aid interactive data analysis. It is one of the topics discussed in <a href="#nse">non-standard evaluation</a>.</p>
<h3 id="Exercises-17"><a href="#Exercises-17" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>List the four environments associated with a function. What does each one    do? Why is the distinction between enclosing and binding environments    particularly important?</li>
<li><p>Draw a diagram that shows the enclosing environments of this function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f1 &lt;- function(x1) &#123;</span><br><span class="line">  f2 &lt;- function(x2) &#123;</span><br><span class="line">    f3 &lt;- function(x3) &#123;</span><br><span class="line">      x1 + x2 + x3</span><br><span class="line">    &#125;</span><br><span class="line">    f3(3)</span><br><span class="line">  &#125;</span><br><span class="line">  f2(2)</span><br><span class="line">&#125;</span><br><span class="line">f1(1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Expand your previous diagram to show function bindings.</p>
</li>
<li>Expand it again to show the execution and calling environments.</li>
<li>Write an enhanced version of <code>str()</code> that provides more information    about functions. Show where the function was found and what environment    it was defined in.</li>
</ol>
<h2 id="Binding-names-to-values"><a href="#Binding-names-to-values" class="headerlink" title="Binding names to values"></a><a href="id=&quot;binding&quot;">Binding names to values</a></h2><p>Assignment is the act of binding (or rebinding) a name to a value in an environment. It is the counterpart to scoping, the set of rules that determines how to find the value associated with a name. Compared to most languages, R has extremely flexible tools for binding names to values. In fact, you can not only bind values to names, but you can also bind expressions (promises) or even functions, so that every time you access the value associated with a name, you get something different!</p>
<p>Youâve probably used regular assignment in R thousands of times. Regular assignment creates a binding between a name and an object in the current environment. Names usually consist of letters, digits, <code>.</code> and <code>_</code>, and canât begin with <code>_</code>.  If you try to use a name that doesnât follow these rules, you get an error:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_abc &lt;- 1</span><br><span class="line"># Error: unexpected input in &quot;_&quot;</span><br></pre></td></tr></table></figure>
<p>Reserved words (like <code>TRUE</code>, <code>NULL</code>, <code>if</code>, and <code>function</code>) follow the rules but are reserved by R for other purposes:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if &lt;- 10</span><br><span class="line">#&gt; Error: unexpected assignment in &quot;if &lt;-&quot;</span><br></pre></td></tr></table></figure>
<p>A complete list of reserved words can be found in <code>?Reserved</code>.</p>
<p>Itâs possible to override the usual rules and use a name with any sequence of characters by surrounding the name with backticks:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`a + b` &lt;- 3</span><br><span class="line">`:)` &lt;- &quot;smile&quot;</span><br><span class="line">`    ` &lt;- &quot;spaces&quot;</span><br><span class="line">ls()</span><br><span class="line">#  [1] &quot;    &quot;   &quot;:)&quot;     &quot;a + b&quot;</span><br><span class="line">`:)`</span><br><span class="line">#  [1] &quot;smile&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin_sidebar(&quot;Quotes&quot;)</span><br></pre></td></tr></table></figure>
<p>You can also create non-syntactic bindings using single and double quotes instead of backticks, but I donât recommend it. The ability to use strings on the left hand side of the assignment arrow is a historical artefact, used before R supported backticks.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end_sidebar()</span><br></pre></td></tr></table></figure>
<p>The regular assignment arrow, <code>&lt;-</code>, always creates a variable in the current environment. The deep assignment arrow, <code>&lt;&lt;-</code>, never creates a variable in the current environment, but instead modifies an existing variable found by walking up the parent environments. You can also do deep binding with <code>assign()</code>: <code>name &lt;&lt;- value</code> is equivalent to <code>assign(&quot;name&quot;, value, inherits = TRUE)</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 0</span><br><span class="line">f &lt;- function() &#123;</span><br><span class="line">  x &lt;&lt;- 1</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<p>If <code>&lt;&lt;-</code> doesnât find an existing variable, it will create one in the global environment. This is usually undesirable, because global variables introduce non-obvious dependencies between functions. <code>&lt;&lt;-</code> is most often used in conjunction with a closure, as described in <a href="#closures">Closures</a>.</p>
<p>There are two other special types of binding, delayed and active:</p>
<ul>
<li><p>Rather than assigning the result of an expression immediately, a    <strong>delayed binding</strong> creates and stores a promise to evaluate the expression    when needed. We can create delayed bindings with the special assignment    operator <code>%&lt;d-%</code>, provided by the pryr package.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(pryr)</span><br><span class="line">system.time(b %&lt;d-% &#123;Sys.sleep(1); 1&#125;)</span><br><span class="line">system.time(b)</span><br></pre></td></tr></table></figure>
<p><code>%&lt;d-%</code> is a wrapper around the base <code>delayedAssign()</code> function, which you    may need to use directly if you need more control. Delayed bindings are    used to implement <code>autoload()</code>, which makes R behave as if the package data    is in memory, even though itâs only loaded from disk when you ask for it.</p>
</li>
<li><p><strong>Active</strong> are not bound to a constant object. Instead, theyâre re-computed    every time theyâre accessed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x %&lt;a-% runif(1)</span><br><span class="line">x</span><br><span class="line">x</span><br><span class="line">rm(x)</span><br></pre></td></tr></table></figure>
<p><code>%&lt;a-%</code> is a wrapper for the base function <code>makeActiveBinding()</code>. You may    want to use this function directly if you want more control. Active    bindings are used to implement reference class fields.</p>
</li>
</ul>
<h3 id="Exercises-18"><a href="#Exercises-18" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>What does this function do? How does it differ from <code>&lt;&lt;-</code> and why    might you prefer it?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rebind &lt;- function(name, value, env = parent.frame()) &#123;</span><br><span class="line">  if (identical(env, emptyenv())) &#123;</span><br><span class="line">    stop(&quot;Can&apos;t find &quot;, name, call. = FALSE)</span><br><span class="line">  &#125; else if (exists(name, envir = env, inherits = FALSE)) &#123;</span><br><span class="line">    assign(name, value, envir = env)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    rebind(name, value, parent.env(env))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">rebind(&quot;a&quot;, 10)</span><br><span class="line">a &lt;- 5</span><br><span class="line">rebind(&quot;a&quot;, 10)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
</li>
<li><p>Create a version of <code>assign()</code> that will only bind new names, never    re-bind old names. Some programming languages only do this, and are known    as <a href="http://en.wikipedia.org/wiki/Assignment_(computer_science)#Single_assignment" target="_blank" rel="external">single assignment languages</a>.</p>
</li>
<li><p>Write an assignment function that can do active, delayed, and locked    bindings. What might you call it? What arguments should it take? Can you    guess which sort of assignment it should do based on the input?</p>
</li>
</ol>
<h2 id="Explicit-environments"><a href="#Explicit-environments" class="headerlink" title="Explicit environments"></a><a href="id=&quot;explicit-envs&quot;">Explicit environments</a></h2><p>As well as powering scoping, environments are also useful data structures in their own right because they have <strong>reference semantics</strong>.  Unlike most objects in R, when you modify an environment, it does not make a copy. For example, look at this <code>modify()</code> function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modify &lt;- function(x) &#123;</span><br><span class="line">  x$a &lt;- 2</span><br><span class="line">  invisible()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you apply it to a list, the original list is not changed because modifying a list actually creates and modifies a copy.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x_l &lt;- list()</span><br><span class="line">x_l$a &lt;- 1</span><br><span class="line">modify(x_l)</span><br><span class="line">x_l$a</span><br></pre></td></tr></table></figure>
<p>However, if you apply it to an environment, the original environment <em>is</em> modified:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x_e &lt;- new.env()</span><br><span class="line">x_e$a &lt;- 1</span><br><span class="line">modify(x_e)</span><br><span class="line">x_e$a</span><br></pre></td></tr></table></figure>
<p>Just as you can use a list to pass data between functions, you can also use an environment. When creating your own environment, note that you should set its parent environment to be the empty environment. This ensures you donât accidentally inherit objects from somewhere else:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1</span><br><span class="line">e1 &lt;- new.env()</span><br><span class="line">get(&quot;x&quot;, envir = e1)</span><br><span class="line"></span><br><span class="line">e2 &lt;- new.env(parent = emptyenv())</span><br><span class="line">get(&quot;x&quot;, envir = e2)</span><br></pre></td></tr></table></figure>
<p>Environments are data structures useful for solving three common problems:</p>
<ul>
<li>Avoiding copies of large data.</li>
<li>Managing state within a package.</li>
<li>Efficiently looking up values from names.</li>
</ul>
<p>These are described in turn below.</p>
<h3 id="Avoiding-copies"><a href="#Avoiding-copies" class="headerlink" title="Avoiding copies"></a>Avoiding copies</h3><p>Since environments have reference semantics, youâll never accidentally create a copy. This makes it a useful vessel for large objects. Itâs a common technique for bioconductor packages which often have to manage large genomic objects. Changes to R 3.1.0 have made this use substantially less important because modifying a list no longer makes a deep copy. Previously, modifying a single element of a list would cause every element to be copied, an expensive operation if some elements are large. Now, modifying a list efficiently reuses existing vectors, saving much time.</p>
<h3 id="Package-state"><a href="#Package-state" class="headerlink" title="Package state"></a>Package state</h3><p>Explicit environments are useful in packages because they allow you to maintain state across function calls. Normally, objects in a package are locked, so you canât modify them directly. Instead, you can do something like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my_env &lt;- new.env(parent = emptyenv())</span><br><span class="line">my_env$a &lt;- 1</span><br><span class="line"></span><br><span class="line">get_a &lt;- function() &#123;</span><br><span class="line">  my_env$a</span><br><span class="line">&#125;</span><br><span class="line">set_a &lt;- function(value) &#123;</span><br><span class="line">  old &lt;- my_env$a</span><br><span class="line">  my_env$a &lt;- value</span><br><span class="line">  invisible(old)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Returning the old value from setter functions is a good pattern because it makes it easier to reset the previous value in conjunction with <code>on.exit()</code> (see more in <a href="#on-exit">on exit</a>).</p>
<h3 id="As-a-hashmap"><a href="#As-a-hashmap" class="headerlink" title="As a hashmap"></a>As a hashmap</h3><p>A hashmap is a data structure that takes constant, O(1), time to find an object based on its name. Environments provide this behaviour by default, so can be used to simulate a hashmap. See the CRAN package <code>hash</code> for a complete development of this idea.</p>
<h2 id="Quiz-answers-2"><a href="#Quiz-answers-2" class="headerlink" title="Quiz answers"></a><a href="id=&quot;env-answers&quot;">Quiz answers</a></h2><ol>
<li>There are four ways: every object in an environment must have a name;    order doesnât matter; environments have parents; environments have    reference semantics.</li>
<li>The parent of the global environment is the last package that you    loaded. The only environment that doesnât have a parent is the empty    environment.</li>
<li>The enclosing environment of a function is the environment where it    was created. It determines where a function looks for variables.</li>
<li>Use <code>parent.frame()</code>.</li>
<li><code>&lt;-</code> always creates a binding in the current environment; <code>&lt;&lt;-</code>    rebinds an existing name in a parent of the current environment.</li>
</ol>
<hr>
<h1 id="Debugging-condition-handling-and-defensive-programming"><a href="#Debugging-condition-handling-and-defensive-programming" class="headerlink" title="Debugging, condition handling, and defensive programming"></a><a href="id=&quot;debugging&quot;">Debugging, condition handling, and defensive programming</a></h1><p>What happens when something goes wrong with your R code? What do you do? What tools do you have to address the problem? This chapter will teach you how to fix unanticipated problems (debugging), show you how functions can communicate problems and how you can take action based on those communications (condition handling), and teach you how to avoid common problems before they occur (defensive programming).</p>
<p>Debugging is the art and science of fixing unexpected problems in your code. In this section youâll learn the tools and techniques that help you get to the root cause of an error. Youâll learn general strategies for debugging, useful R functions like <code>traceback()</code> and <code>browser()</code>, and interactive tools in RStudio.</p>
<p>Not all problems are unexpected. When writing a function, you can often anticipate potential problems (like a non-existent file or the wrong type of input). Communicating these problems to the user is the job of <strong>conditions</strong>: errors, warnings, and messages.</p>
<ul>
<li>Fatal errors are raised by <code>stop()</code> and force all execution to terminate.  Errors are used when there is no way for a function to continue.</li>
<li>Warnings are generated by <code>warning()</code> and are used to display potential  problems, such as when some elements of a vectorised input are invalid,  like <code>log(-1:2)</code>.</li>
<li>Messages are generated by <code>message()</code> and are used to give informative output  in a way that can easily be suppressed by the user (<code>?suppressMessages()</code>).  I often use messages to let the user know what value the function has chosen  for an important missing argument.</li>
</ul>
<p>Conditions are usually displayed prominently, in a bold font or coloured red depending on your R interface. You can tell them apart because errors always start with âErrorâ and warnings with âWarning messageâ. Function authors can also communicate with their users with <code>print()</code> or <code>cat()</code>, but I think thatâs a bad idea because itâs hard to capture and selectively ignore this sort of output. Printed output is not a condition, so you canât use any of the useful condition handling tools youâll learn about below.</p>
<p>Condition handling tools, like <code>withCallingHandlers()</code>, <code>tryCatch()</code>, and <code>try()</code> allow you to take specific actions when a condition occurs. For example, if youâre fitting many models, you might want to continue fitting the others even if one fails to converge. R offers an exceptionally powerful condition handling system based on ideas from Common Lisp, but itâs currently not very well documented or often used. This chapter will introduce you to the most important basics, but if you want to learn more, I recommend the following two sources:</p>
<ul>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html" target="_blank" rel="external"><em>A prototype of a condition system for R</em></a> by Robert Gentleman and Luke Tierney.  This describes an early version of Râs condition system. While the  implementation has changed somewhat since this document was written, it  provides a good overview of how the pieces fit together, and some  motivation for its design.</li>
<li><a href="http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html" target="_blank" rel="external"><em>Beyond Exception Handling: Conditions and Restarts</em></a>  by Peter Seibel. This describes exception handling in Lisp, which happens  to be very similar to Râs approach. It provides useful motivation and  more sophisticated examples. I have provided an R translation of the  chapter at <a href="http://adv-r.had.co.nz/beyond-exception-handling.html" target="_blank" rel="external">http://adv-r.had.co.nz/beyond-exception-handling.html</a>.</li>
</ul>
<hr>
<h2 id="A-Prototype-of-a-Condition-System-for-R"><a href="#A-Prototype-of-a-Condition-System-for-R" class="headerlink" title="A Prototype of a Condition System for R"></a>A Prototype of a Condition System for R</h2><p>Robert Gentleman and Luke Tierney</p>
<h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>This note implements a prototype for a condition system with calling and exiting handlers. It is available as a <a href="http://www.stat.uiowa.edu/~luke/R/exceptions/simpcond.tar.gz" target="_blank" rel="external">package</a>. The package requires the <a href="http://www.stat.uiowa.edu/~luke/R/exceptions/dynvars.tar.gz" target="_blank" rel="external">dynamic variable package</a>.</p>
<p>Exiting handlers provide a structured exception handling mechanism much like the one in Java. Calling handlers allow the <code>error</code> option and the warning mechanism to be handled as part of the system, and also allow for the creation of programmable recovery mechanisms.</p>
<p>Once loaded, the code in this package will take over handling of errors, both those signaled with <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a> and internal ones. This is accomplished using some hooks that have been added to <code>errors.c</code> for this purpose. These hooks are temporary and will most likely be removed once a new error handling system has been finalized. So this code requires at least R 1.3, but may stop working (and no longer be needed) with later versions of R.</p>
<p>There are a couple of rough edges. One is that internal errors in this package could disable the new exception handling mechanism and return to the standard one. If this happens, evaluating the expression <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">EnableErrorHooks</a>() should reinstate the new system. To make it easier to identify when this has occurred, the new system pre-pends an underscore to the error message, as in</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">stop</span>(<span class="string">"A"</span>)</span><br><span class="line">_Error: A</span><br></pre></td></tr></table></figure>
<p>The underscore can be turned off by setting the <code>add.error.underscore</code> option to false:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; options(add.error.underscore=<span class="literal">FALSE</span>)</span><br><span class="line">&gt; <span class="keyword">stop</span>(<span class="string">"A"</span>)</span><br><span class="line">Error: A</span><br></pre></td></tr></table></figure>
<p>A proper internal implementation would avoid this issue, but it is too early for that. Adding another hook in the <code>longjmp</code> code would also prevent this, but that seemed excessive.</p>
<p>A second issue is the integration with <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> and <code>browser</code>. For the most part these should now behave as onemight expect, (to the extent that it is clear what is expected) since error-related jumps are set to stop at intervening frames that have had <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> called on them. But there may be some wrinkles here.</p>
<h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>Conditions are unusual situations that might occur and should be addressed in some way. Errors are one example, situations that require a warning are another.</p>
<p>A condition system allows handlers for different kids of conditions to be registered. When an unusual situation occurs, code can signal an appropriate condition. The condition system is then responsible for finding and invoking an appropriate handler for the condition.</p>
<p>Condition handlers come in two flavors: exiting and calling. Exiting handlers are like <code>catch</code> clauses in a Java <code>try</code>/<code>catch</code> block: dynamic state is unwound and control is transferred back to the context where the handler was established (the <code>try</code>/<code>catch</code> block). Thus a non-local transfer of control (a <code>longjmp</code> in C terms) occurs before the handler code is executed. Calling handlers are like UNIX signal handlers. They are called in the context of the code that signaled the condition, much like an ordinary function call.</p>
<p>Most errors will eventually need to be handled by an exiting handler, since continuing after an error is usually not a good idea. Warnings on the other hand are often benign and should therefore typically use a calling handler. But even for errors calling handlers are useful: If you want to use a handler to enter the browser at the point where an error occurs, then a calling handler is needed.</p>
<h4 id="Exiting-Handlers"><a href="#Exiting-Handlers" class="headerlink" title="Exiting Handlers"></a>Exiting Handlers</h4><p>Exiting handlers are primarily used for handling exceptions. The mechanism implemented here is quite similar in many ways to Javaâs mechanism. Exceptions are objects inheriting from the abstract class <code>exception</code>. The class <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.exception</a> is the class currently used by <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a> and all internal error signals. The constructor by the same name takes a string describing the exception as argument and an optional call and returns a <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.exception</a> object.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; simple.exception(<span class="string">"bad foo"</span>)</span><br><span class="line">&lt;simple.exception: bad foo&gt;</span><br><span class="line">&gt; simple.exception(<span class="string">"bad foo"</span>, quote(foo()))</span><br><span class="line">&lt;simple.exception <span class="keyword">in</span> foo(): bad foo&gt;</span><br></pre></td></tr></table></figure>
<p>The function <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a> has been modified to accept exception objects in addition to strings as its argument:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">stop</span>(simple.exception(<span class="string">"bad foo"</span>))</span><br><span class="line">_Error: bad foo</span><br><span class="line">&gt; <span class="keyword">stop</span>(simple.exception(<span class="string">"bad foo"</span>, quote(foo())))</span><br><span class="line">_Error <span class="keyword">in</span> foo() : bad foo</span><br></pre></td></tr></table></figure>
<p>The function <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a> is used to establish exiting handlers. Its usage is</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try.catch(expr, <span class="keyword">...</span>, finally = <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>
<p>It evaluates its expression argument in a context where the handlers provided in the <code>...</code> argument are available. Handlers are specified as</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = fun</span><br></pre></td></tr></table></figure>
<p>where <code>name</code> specifies an exception class and <code>fun</code> is a function of one argument, the condition that is to be handled. When an exception is signaled, the most recently established handler that matches the exception (for which the exception inherits from the specified class) is chosen, control transfers back to the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a> expression, the handler function is called, and the value returned by the handler function is returned by the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a> call.</p>
<p>As an example, here the handler catches the exception signaled with <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a> and returns it:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; try.catch(<span class="keyword">stop</span>(<span class="string">"A"</span>), exception = <span class="keyword">function</span>(e) e)</span><br><span class="line">&lt;simple.exception <span class="keyword">in</span> try.catch(<span class="keyword">stop</span>(<span class="string">"A"</span>), exception = <span class="keyword">function</span>(e) e): A&gt;</span><br></pre></td></tr></table></figure>
<p>A <code>finally</code> clause, if provided, will be evaluated before the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a> call returns:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;  try.catch(<span class="keyword">stop</span>(simple.exception(<span class="string">"A"</span>)), exception = <span class="keyword">function</span>(e) e,</span><br><span class="line">+            finally = print(<span class="string">"B"</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="string">"B"</span></span><br><span class="line">&lt;simple.exception: A&gt;</span><br><span class="line">&gt;  try.catch(<span class="string">"A"</span>, exception = <span class="keyword">function</span>(e) e, finally = print(<span class="string">"B"</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="string">"B"</span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"A"</span></span><br></pre></td></tr></table></figure>
<p>The handler calls and the <code>finally</code> expression are evaluated in the context in which <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a> was called; that is, the handlers supplied to the current <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a> call are <em>not</em> active during these evaluations.</p>
<p>Using <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a> we can define a function <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external">ignore.errors</a> that is essentially the equivalent of <code>try</code>:</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external"><code>&lt;establishing handlers&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U-&gt;</a>)</strong> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD3" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external">ignore.errors</a> &lt;- function(expr)<br> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a>(expr, exception = function(e) e)</p>
<p>  Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-ignore.errors" target="_blank" rel="external"><code>ignore.errors</code></a> (links are to index).</p>
<p>For example,</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ignore.errors(<span class="number">1</span>+<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br><span class="line">&gt; ignore.errors(ts(<span class="number">1</span>:<span class="number">2</span>) + <span class="number">1</span>:<span class="number">3</span>)</span><br><span class="line">&lt;simple.exception <span class="keyword">in</span> ts(<span class="number">1</span>:<span class="number">2</span>) + <span class="number">1</span>:<span class="number">3</span>: time-series/vector length mismatch&gt;</span><br></pre></td></tr></table></figure>
<p>Lazy evaluation is critical in making this simple definition work.</p>
<h4 id="Calling-Handlers"><a href="#Calling-Handlers" class="headerlink" title="Calling Handlers"></a>Calling Handlers</h4><p>The exception hierarchy is contained in the condition hierarchy, which also includes warnings:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                   condition</span><br><span class="line">                   /    |    \</span><br><span class="line">                  /     |     \</span><br><span class="line">                 /      |      \</span><br><span class="line">                /       |       \</span><br><span class="line">simple.condition    exception    warning</span><br><span class="line">                        |           |</span><br><span class="line">                  simple.exception  |</span><br><span class="line">                                    |</span><br><span class="line">                             simple.warning</span><br></pre></td></tr></table></figure>
<p>The <code>condition</code> class is analogous to the Java <code>Throwable</code> class.</p>
<p>Exiting handlers can also be used with non-exception throwables, but calling handlers are probably more useful there. The calling handlers system is very close to the Common Lisp approach. The Dylan approach seemed a bit cleaner at first but there are too many problems with it, at least for an interactive language like R.</p>
<p>Conditions are signaled by <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">signal.condition</a>, and calling handlers get established by <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">with.handlers</a>. A simple example:</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD2" target="_blank" rel="external"><code>&lt;example&gt;=</code></a> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD5" target="_blank" rel="external">-&gt;</a>]</strong><br>f &lt;- function() {<br>n &lt;- 0<br>h &lt;- function(c) {<br>n &lt;&lt;- n + 1<br>cat(âhandler callâ, n, â\nâ)<br>}<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">with.handlers</a>(for (i in 1:5)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">signal.condition</a>(âa conditionâ),<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.condition</a> = h)<br>}</p>
<p>produces</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; f()</span><br><span class="line">handler call <span class="number">1</span></span><br><span class="line">&lt;a name=<span class="string">"NWD3"</span>&gt;handler call <span class="number">2</span>&lt;/a&gt;</span><br><span class="line">handler call <span class="number">3</span></span><br><span class="line">handler call <span class="number">4</span></span><br><span class="line">handler call <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>The internal warning mechanism has been modified to signal a <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a> condition, so we can define a function to suppress warnings for a particular computation as</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external"><code>&lt;establishing handlers&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U-&gt;</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD3" target="_blank" rel="external">muffle.warnings</a> &lt;- function(expr)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">with.handlers</a>(expr, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a> = function(w) {})</p>
<p>  Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-muffle.warnings" target="_blank" rel="external"><code>muffle.warnings</code></a> (links are to index).</p>
<p>For example,</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="keyword">warning</span>(<span class="string">"A"</span>); <span class="number">1</span>+<span class="number">2</span> &#125;</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br><span class="line">Warning message:</span><br><span class="line">A</span><br><span class="line">&gt; muffle.warnings(&#123; <span class="keyword">warning</span>(<span class="string">"A"</span>); <span class="number">1</span>+<span class="number">2</span> &#125;)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>We could also use a calling handler to enter the browser on warnings:</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD4" target="_blank" rel="external"><code>&lt;dfn&gt;&lt;browse on warnings&gt;=</code></a><br>browse.on.warnings &lt;- function(expr)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">with.handlers</a>(expr, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a>=function(w) browser())</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Browse[<span class="number">1</span>]&gt; browse.on.warnings(&#123; <span class="keyword">warning</span>(<span class="string">"A"</span>); <span class="number">1</span>+<span class="number">2</span> &#125;)</span><br><span class="line">Called from: h$handler(c)</span><br><span class="line">Browse[<span class="number">2</span>]&gt; cont</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Calling handlers are pushed on a stack as they are established. When a calling handler is invoked, the handler stack for the call of the handler is the portion of the handler stack below where the handler was found. A handler can therefore pass control to another handler established below it by re-signaling the condition. If a calling handler returns, then the returned value is returned from the signal call.</p>
<h4 id="Recovery-Mechanisms"><a href="#Recovery-Mechanisms" class="headerlink" title="Recovery Mechanisms"></a>Recovery Mechanisms</h4><p>With calling handlers we can also make available a rich structure for programmable recovery mechanisms. These will be called <em>resets</em>. Dylan and Common Lisp use the term <em>restarts</em>, but for us that would cause some confusion. The mechanism described here is based on the Common Lisp mechanism.</p>
<p>One reset that will always be available is the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> reset. This reset can be invoked by calling <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a>(). The default handler does a jump to top level, but will stop at any intervening restarts. The default error handlers call <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a>; establishing a new <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> reset will therefore intercept their transfer of control.</p>
<p>The functions <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">find.reset</a> and <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">compute.resets</a> can be used to locate available resets. <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">find.reset</a> takes a reset name and an optional condition as arguments. The first reset matching the name and condition, if supplied, is returned. For example, we can find the first available <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> reset with</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; find.reset(<span class="string">"abort"</span>)</span><br><span class="line">&lt;reset: abort &gt;</span><br></pre></td></tr></table></figure>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">compute.resets</a> takes an optional condition and returns a list of resets applicable to the condition (or all resets if no condition is specified):</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD2" target="_blank" rel="external"><code>&lt;example&gt;+=</code></a> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD2" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD8" target="_blank" rel="external">-&gt;</a>]</strong><br><code>&gt;</code> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">compute.resets</a>()<br>[<a href="http://google-styleguide.googlecode.com/svn/trunk/google-r-style.html" target="_blank" rel="external">1</a>]<br><code>&lt;reset:</code> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> <code>&gt;</code></p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">compute.resets</a> could be used by browser or, in a GUI framework, by a menu for choosing a reset to invoke.</p>
<p>Resets can be invoked with <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">invoke.reset</a>. This takes a reset name or a reset object, as returned by <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">find.reset</a> for example, and any other arguments needed by the reset handler, transfers control to the point where the handler was established, and calls the handler with the specified arguments. Thus the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> function is just a convenient shorthand for</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke.reset(<span class="string">"abort"</span>)</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke.reset(find.reset(<span class="string">"abort"</span>))</span><br></pre></td></tr></table></figure>
<p>Resets are established using <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">with.resets</a>. This is called as</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with.resets(expr, name1 = spec1, name2 = spec2, <span class="keyword">...</span>)</span><br></pre></td></tr></table></figure>
<p>The <code>spec</code> values can take several forms. The can be a function of any number of arguments, which is used as the handler. They can be a string, which is used as a message along with a handler that ignores its arguments and returns <code>NULL</code>. Or they can be a list with any of the following named fields:</p>
<ul>
<li><code>handler</code> : a function of any number of arguments to be used as the handler.</li>
<li><code>test</code>: a function of one argument, a condition, that should return a logical value indicating whether this reset is applicable to the specified condition.</li>
<li><code>message</code>: a message that is stored in the <code>message</code> field of resets returned by <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">find.reset</a> and <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">compute.resets</a>. The default function returns <code>TRUE</code> for all conditions.</li>
<li><code>restarts.honored</code>: a logical indicating whether or not a transfer of control should stop at any intervening call frames that have had <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> called on them. The default is <code>FALSE</code>, but it is <code>TRUE</code> for the default <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> reset.</li>
<li><code>interactive</code>: a function of no arguments that returns a list of arguments to be used by <code>invoke</code>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>. This is used by <code>invoke</code>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>.<code>interactively</code> that could be called from a menu of available restarts in a GUI framework.</li>
</ul>
<p>Here is an an outline of how this framework might be used. Suppose we are writing a function maximizer. To allow for flexible recovery when the function causes an error we might do something like this:</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD6" target="_blank" rel="external"><code>&lt;resets example&gt;=</code></a><br>myopt &lt;- function(x, fun) {<br>repeat {<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">with.resets</a>(return(do.opt(x, fun)),<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>.opt = function(new.x) x &lt;&lt;- new.x)<br>}<br>}<br>do.opt &lt;- function(x, fun) {<br>â¦<br>fval &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">with.resets</a>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">with.handlers</a>(fun(x),<br>exception = function(e)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">signal.condition</a>(optfun.error(e, x))),<br>use.value = function(val) val)<br>â¦<br>}</p>
<p>With a call like</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with.handlers(myopt(x, fun), optfun.error = <span class="keyword">function</span>(e) browser())</span><br></pre></td></tr></table></figure>
<p>we would enter the browser when calling the function to be optimized creates an error. From the browser we could then interactively decide to return a particular value, say 3, from the call with</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke.reset(<span class="string">"use.value"</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>or we could restart the optimization at a new initial value with</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke.reset(<span class="string">"restart.opt"</span>, new.x = <span class="keyword">...</span>)</span><br></pre></td></tr></table></figure>
<p>Alternatively, this could be handled programatically with something like</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with.handlers(myopt(x, fun),</span><br><span class="line">              optfun.error = <span class="keyword">function</span>(e) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (e$x &lt; <span class="number">0</span>)</span><br><span class="line">                     invoke.reset(<span class="string">"use.value"</span>, <span class="number">3</span>)</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                     invoke.reset(<span class="string">"restart.opt"</span>, abs(rnorm(<span class="number">1</span>)))</span><br><span class="line">              &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Some-Issues"><a href="#Some-Issues" class="headerlink" title="Some Issues"></a>Some Issues</h3><h4 id="Minor-Issues"><a href="#Minor-Issues" class="headerlink" title="Minor Issues"></a>Minor Issues</h4><ul>
<li>The interface for resets may not be quite the right interface since it is a bit too string-based to work well with name spaces, but it should end up something along these lines.</li>
<li>One useful change would be to allow <code>browser</code> to take an optional condition argument that represents the condition, if any, that triggered the browser call.</li>
<li>Things like the <code>y/n/c</code> options given by <code>q()</code>, and the internal exit code, could be handled with resets and conditions as well.</li>
<li>The resets described here are all exiting. Common Lisp also allows for calling restarts (as they are called there). There are a few useful examples, but Iâm not sure we need them in R. Might not hurt though. Since they are rare, we could maybe use <code>with.calling.resets</code> as the interface.</li>
<li>Things like signal handling and process exiting could be changed to use this stuff.</li>
<li>Some language is probably needed someplace to make it clear that a handler for exceptions should always end by calling <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a>.</li>
<li>We need to improve the implementation so it is not possible to drop out of the system or get into a recursive error loop. Neither is very likely but both may be possible.</li>
<li>We need some test code for the non-local control transfers in R.</li>
</ul>
<h4 id="How-To-Integrate-The-restart-Function"><a href="#How-To-Integrate-The-restart-Function" class="headerlink" title="How To Integrate The restart Function"></a>How To Integrate The <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> Function</h4><p>The <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> function is currently the primitive building block for error handling mechanisms. When called, it marks the frame of its function for intercepting certain transfers of control. [Currently the frame that is restarted is the one where the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> expression is evaluated. This is probably not what we want when a <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> ends up in a promise.]</p>
<p>Conceptually there seem to be two ways to fit <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> into this condition system:</p>
<ul>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> inserts an exiting exception handler into the handler stack that swallows the exception. Thus every function can be viewed as having a body that looks like this:</li>
</ul>
<blockquote>
<p>try.catch(body, exception = function(e) if (! restart.called) stop(e))</p>
</blockquote>
<ul>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> inserts an <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> reset into the reset stack, so the body of a function looks like</li>
</ul>
<blockquote>
<p>with.resets(body, abort = function() if (! restart.called) abort())</p>
</blockquote>
<p>Currently, in both R and Splus the <code>error</code> option is called even if a <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> frame is on the stackâonly the jump to top level is affected. This seems consistent with the second approach. This package is kind of in between. Following either would require an internal implementation.</p>
<p>Implementing either approach will complicate fully integrating the condition mechanism. The existence of <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> in its current form also complicates the internal evaluation mechanism and makes byte code compilation harder. Since anything that can be done with <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> can be done (better) with exception handling, it seems like a good idea to consider eliminating <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> entirely.</p>
<p>To allow existing code using <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> to be easily converted, we could provide a mechanism something like</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD7" target="_blank" rel="external"><code>&lt;possible</code>restart<code>changes&gt;=</code></a> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD7" target="_blank" rel="external">restartable</a> &lt;- function(expr) {<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>.called &lt;- FALSE<br>assign(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>â, function() { <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>.called &lt;&lt;- TRUE },<br>env = parent.frame())<br>repeat<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">with.resets</a>(return(eval(substitute(expr), env = parent.frame())),<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> = function() if (! <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>.called) <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a>())<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-restartable" target="_blank" rel="external"><code>restartable</code></a> (links are to index).</p>
<p>An interpretation that makes <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> insert an exception handler would use <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a> instead of <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">with.resets</a>. The <code>eval(substitute(...</code> construct is needed since the expression is potentially evaluated more than once. Perhaps a test function should be added that only makes the abort reset visible if it is active.</p>
<p>Using this mechanism, a function with a body that uses <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> could then be re-written as</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="keyword">...</span>) restartable(body)</span><br></pre></td></tr></table></figure>
<p>For example,</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD2" target="_blank" rel="external"><code>&lt;example&gt;+=</code></a> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD5" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD9" target="_blank" rel="external">-&gt;</a>]</strong><br>f&lt;-function(x, y = TRUE) {<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>()<br>if (y) {<br>y &lt;- FALSE<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>(âAâ)<br>}<br>else x<br>}</p>
<p>would be rewritten as</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD2" target="_blank" rel="external"><code>&lt;example&gt;+=</code></a> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD8" target="_blank" rel="external">&lt;-</a>D]</strong><br>new.f&lt;-function(x, y = TRUE)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD7" target="_blank" rel="external">restartable</a>({<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>()<br>if (y) {<br>y &lt;- FALSE<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>(âAâ)<br>}<br>else x<br>})</p>
<p>To insure that code using <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> is changed, we could define <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> in the base package as</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD7" target="_blank" rel="external"><code>&lt;possible</code>restart<code>changes&gt;+=</code></a> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD7" target="_blank" rel="external">&lt;-</a>D]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> &lt;- function()<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>(paste(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> no longer supported.\nâ,<br>âconvert to using the exception handling system orâ,<br>âuse `restartableââ)</p>
<p> Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-restart" target="_blank" rel="external"><code>restart</code></a> (links are to index).</p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external"><code>&lt;simpcond.R&gt;=</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external"><code>&lt;global variables&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDH" target="_blank" rel="external"><code>&lt;call with current continuation&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external"><code>&lt;handler stack management&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external"><code>&lt;invoking handlers&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external"><code>&lt;signaling conditions&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external"><code>&lt;establishing handlers&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDS" target="_blank" rel="external"><code>&lt;condition objects&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external"><code>&lt;default handlers&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external"><code>&lt;internal error conversion&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external"><code>&lt;resets&gt;</code></a></p>
<p>.First.lib &lt;- function(lib, pkg) {<br>library.dynam(pkg, pkg, lib)<br>require(dynvars)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-1" target="_blank" rel="external"><code>&lt;global variable initialization&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">EnableErrorHooks</a>()<br>}</p>
<p>*</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external"><code>&lt;simpcond.c&gt;=</code></a><br><code>#include &quot;Rinternals.h&quot;</code><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external"><code>&lt;declarations for hooks in errors.c&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external"><code>&lt;</code>ReturnOrRestart<code>definition&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**JT-1" target="_blank" rel="external"><code>&lt;</code>JumpToToplevel<code>definition&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external"><code>&lt;</code>EnableExceptionHooks<code>definition&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**Pa-1" target="_blank" rel="external"><code>&lt;</code>PrintDeferredWarnings<code>definition&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**GR-1" target="_blank" rel="external"><code>&lt;</code>GetTraceback<code>definition&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**SS-1" target="_blank" rel="external"><code>&lt;</code>SetErrmessage<code>definition&gt;</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**IY-1" target="_blank" rel="external"><code>&lt;</code>InternalWarningCall<code>definition&gt;</code></a></p>
<p>*</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external"><code>&lt;NAMESPACE&gt;=</code></a><br>import(dynvars)<br>export(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDc" target="_blank" rel="external">,</a> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">.exception</a>)<br>export(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.exception</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.condition</a>, simple.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">)</a><br>export(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">signal.condition</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a>)<br>export(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">with.handlers</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD3" target="_blank" rel="external">muffle.warnings</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external">ignore.errors</a>)<br>export(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">with.resets</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">invoke.reset</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">find.reset</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">compute.resets</a>)</p>
<h4 id="Call-With-Current-Continuation"><a href="#Call-With-Current-Continuation" class="headerlink" title="Call With Current Continuation"></a>Call With Current Continuation</h4><p>For handling the transfer of control to exiting handlers we can use a simplified variant of Schemeâs call with current continuation, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a>. This function is called as <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a>(fun) where <code>fun</code> is a function of one argument. <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a> calls this function with one argument, an exit function. If the exit function is not used in the body of <code>fun</code>, then the result returned by <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a> is the result returned by <code>fun</code>. Calling the exit function has the effect of returning immediately from the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a> call with the argument to the exit function as the return value of the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a> call. This implementation only allows the exit function to be used within the body of <code>fun</code>, which makes it like a Dylan <code>block</code>; Schemeâs call with current continuation is quite a bit more general.</p>
<p>We can almost implement what we need in pure R code by using a combination of environments and lazy evaluation. A pure R implementation would look like this:</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external"><code>&lt;pure R implementation of call with current continuation&gt;=</code></a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a> &lt;- function(fun) {<br>make.thrower &lt;- function(expr) function() expr<br>value &lt;- NULL;<br>thrower &lt;- make.thrower(return(value))<br>k &lt;- function(v) {<br>value &lt;&lt;- v<br>thrower()<br>}<br>fun(k)<br>}</p>
<p> Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-callcc" target="_blank" rel="external"><code>callcc</code></a> (links are to index).</p>
<p>Some examples:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; callcc(<span class="keyword">function</span>(k) <span class="number">1</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line">&gt; callcc(<span class="keyword">function</span>(k) k(<span class="number">1</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line">&gt; callcc(<span class="keyword">function</span>(k) &#123;k(<span class="number">1</span>); <span class="number">2</span>&#125;)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line">&gt; callcc(<span class="keyword">function</span>(k) &#123;on.exit(cat(<span class="string">"A\n"</span>)); k(<span class="number">1</span>); <span class="number">2</span>&#125;)</span><br><span class="line">A</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line">&gt; callcc(<span class="keyword">function</span>(k) &#123;<span class="keyword">try</span>(k(<span class="number">1</span>)); <span class="number">2</span>&#125;)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>The final example illustrates a problem for using this pure R approach for error handling: <code>try</code> is implemented with <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>, and <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> is supposed to catch errors but nor <code>return</code>âs. Since we use <code>return</code> to implement the jump, we jump straight through the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> frame.</p>
<p>There does not seem to be a pure R solution to this, so there is now a hook available (at lest temporarily) that will handle this. The hook is provided by a C function declared as</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external"><code>&lt;declarations for hooks in errors.c&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-2" target="_blank" rel="external">-&gt;</a>]</strong><br>void <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external">R_ReturnOrRestart</a>(SEXP val, SEXP env, Rboolean <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>);</p>
<p> Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-R_ReturnOrRestart" target="_blank" rel="external"><code>R_ReturnOrRestart</code></a> (links are to index).</p>
<p>At the moment this declaration is not in any header files, so we need to add it to our sources. This function takes the value to return and the environment indicating the call to return from as arguments. If the third argument is true, then the jump will stop at a restarted call if there is one on the stack ahead of the target. Otherwise restarted calls are ignored, as by <code>return</code>. We can define <code>.Call</code> interfaces to these two settings:</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external"><code>&lt;</code>ReturnOrRestart<code>definition&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong><br>SEXP <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external">DoReturnOrRestart</a>(SEXP val, SEXP env)<br>{<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external">R_ReturnOrRestart</a>(val, env, TRUE);<br>return R_NilValue;<br>}<br>SEXP <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external">DoReturn</a>(SEXP val, SEXP env)<br>{<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external">R_ReturnOrRestart</a>(val, env, FALSE);<br>return R_NilValue;<br>}</p>
<p> Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-DoReturn" target="_blank" rel="external"><code>DoReturn</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-DoReturnOrRestart" target="_blank" rel="external"><code>DoReturnOrRestart</code></a> (links are to index).</p>
<p>Now we can modify <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a> to allow exit functions to take an additional argument that specifies whether restarts on the stack are to be honored or ignored:</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDH" target="_blank" rel="external"><code>&lt;call with current continuation&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a> &lt;- function(fun) {<br>env &lt;- environment()<br>k &lt;- function(v, restarts.honored = FALSE) {<br>if (restarts.honored)<br>.Call(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external">DoReturnOrRestart</a>â, v, env)<br>else<br>.Call(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external">DoReturn</a>â, v, env)<br>}<br>fun(k)<br>}</p>
<p> Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-callcc" target="_blank" rel="external"><code>callcc</code></a> (links are to index).</p>
<p>Some examples:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; callcc(<span class="keyword">function</span>(k) &#123;<span class="keyword">try</span>(k(<span class="number">1</span>)); <span class="number">2</span>&#125;)</span><br><span class="line">&lt;a name=<span class="string">"NWDI"</span>&gt;[<span class="number">1</span>] <span class="number">1</span>&lt;/a&gt;</span><br><span class="line">&gt; callcc(<span class="keyword">function</span>(k) &#123;<span class="keyword">try</span>(k(<span class="number">1</span>, <span class="literal">T</span>)); <span class="number">2</span>&#125;)</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="Handler-Stack-Management"><a href="#Handler-Stack-Management" class="headerlink" title="Handler Stack Management"></a>Handler Stack Management</h4><p>The handler stack is managed using a dynamic variable, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a>.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external"><code>&lt;global variables&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a> &lt;- NULL  ## place holder for .First.lib</p>
<p> Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-handler.stack" target="_blank" rel="external"><code>handler.stack</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-1" target="_blank" rel="external"><code>&lt;global variable initialization&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-2" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a> &lt;&lt;- dynamic.variable()</p>
<p> Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-handler.stack" target="_blank" rel="external"><code>handler.stack</code></a> (links are to index).</p>
<p>The handler stack is managed as a linked list. An internal implementation could use one cons cell per handler.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external"><code>&lt;handler stack management&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDK" target="_blank" rel="external">-&gt;</a>]</strong><br>add.to.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external">&lt;- function(handler, class, exit, stack) {</a><br>list(handler = handler, class = class, exit = exit,<br>next.handler = stack)<br>}</p>
<p> Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-add.to.handler.stack" target="_blank" rel="external"><code>add.to.handler.stack</code></a> (links are to index).</p>
<p>Default handlers can be added to the handler stack with add.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a>.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external"><code>&lt;handler stack management&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external">&lt;-</a>D]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDK" target="_blank" rel="external">add.</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDK" target="_blank" rel="external">&lt;- function(handler, class)</a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a>(add.to.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external">(handler, class, NULL,</a> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a>()))</p>
<p> Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-add.default.handler" target="_blank" rel="external"><code>add.default.handler</code></a> (links are to index).</p>
<h4 id="Handling-Conditions"><a href="#Handling-Conditions" class="headerlink" title="Handling Conditions"></a>Handling Conditions</h4><p>Invoking handlers is done one of two ways. If the exit function in <code>NULL</code> then the handler is a calling handler. It is called with the handler stack bound to the rest of the handler stack below the handler called. If the exit function is not <code>NULL</code> then the handler is exiting. The exit function is used to transfer control to the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a> call where the handlers was established. Restarts on the stack will be honored if the condition signaled is an exception (this also includes stopping the transfer at a browser). For calling handlers we must re-enable the internal error processing hooks just before calling the handler. For exiting handlers the hooks should ideally be re-enabled after the jump, but we need to do it here in case the jump is intercepted by a restarted call. This minimizes the chance of recursion; with an internal implementation this can be done to eliminate the chance of recursion entirely.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external"><code>&lt;invoking handlers&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDM" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external">handle.condition</a> &lt;- function(c) {<br>h &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a>()<br>if (is.null(h))<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDM" target="_blank" rel="external">FailsafeErrorHandler</a>(c)<br>while (! is.null(h))<br>if (inherits(c, h$class))<br>break<br>else h &lt;- h$next.handler<br>if (is.null(h)) {<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">EnableErrorHooks</a>()<br>my.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">(no.condition.handler.exception(c)) #<em>**</em></a><br>}<br>if (is.null(h$exit))<br>dynamic.bind({<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">EnableErrorHooks</a>()<br>h$handler(c)<br>}, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a> = h$next.handler)<br>else {<br>restarts.honored &lt;- inherits(c, âexceptionâ)<br>result &lt;- list(throw = TRUE, handler = h$handler, condition = c)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">EnableErrorHooks</a>()<br>h$exit(result, restarts.honored)<br>}<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-handle.condition" target="_blank" rel="external"><code>handle.condition</code></a> (links are to index).</p>
<p>The fail-safe error handler should ideally be implemented internally so that transfer of control via an internal call to <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> is guaranteed to happen. It will only be reached if the default exception handler fails.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external"><code>&lt;invoking handlers&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external">&lt;-</a>D]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDM" target="_blank" rel="external">FailsafeErrorHandler</a> &lt;- function(c) {<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external">errcat</a>(âError: error in default exception handler\nâ)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">EnableErrorHooks</a>()<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a>()<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-FailsafeErrorHandler" target="_blank" rel="external"><code>FailsafeErrorHandler</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external"><code>&lt;internal error conversion&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external">errcat</a>&lt;- function(s) cat(s, file=stderr())</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-errcat" target="_blank" rel="external"><code>errcat</code></a> (links are to index).</p>
<h4 id="Signaling-Conditions"><a href="#Signaling-Conditions" class="headerlink" title="Signaling Conditions"></a>Signaling Conditions</h4><p>Conditions are signaled by finding and calling a handler. As a convenience, non-condition arguments are converted to simple conditions.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external"><code>&lt;signaling conditions&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">signal.condition</a> &lt;- function(c) {<br>if (! inherits(c, âconditionâ))<br>c &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.condition</a>(c)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external">handle.condition</a>(c)<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-signal.condition" target="_blank" rel="external"><code>signal.condition</code></a> (links are to index).</p>
<p>The <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a> function needs to signal a condition but it must not return. If the condition handler returns, we call <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a>. For now weâll define an internal version <code>my</code>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a> as well as redefining <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external"><code>&lt;signaling conditions&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">-&gt;</a>]</strong><br>my.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">&lt;- function(e, call. = TRUE) {</a><br>if (! <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDS" target="_blank" rel="external">is.condition</a>(e))<br>e &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.exception</a>(e, if (call.) sys.call(1) else NULL)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">signal.condition</a>(e)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external">errcat</a>(âaborting â¦\nâ)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a>()<br>}<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a> &lt;- my.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a></p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-my.stop" target="_blank" rel="external"><code>my.stop</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-stop" target="_blank" rel="external"><code>stop</code></a> (links are to index).</p>
<p>The <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a> function currently does not include a <code>call.</code> argument (should it?) and seems to always include the call in its message. Again, weâll define an internal version <code>my</code>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a> and use it to redefine <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a>.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external"><code>&lt;signaling conditions&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">&lt;-</a>D]</strong><br>my.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">&lt;- function(w) {</a><br>if (! inherits(w, â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a>â))<br>w &lt;- simple.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">(w, sys.call(1))</a><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">signal.condition</a>(w)<br>}<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a> &lt;- my.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a></p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-my.warning" target="_blank" rel="external"><code>my.warning</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-warning" target="_blank" rel="external"><code>warning</code></a> (links are to index).</p>
<h4 id="Establishing-Handlers"><a href="#Establishing-Handlers" class="headerlink" title="Establishing Handlers"></a>Establishing Handlers</h4><p>Calling handlers are established using <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">with.handlers</a>. The definition is quite simple.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external"><code>&lt;establishing handlers&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD3" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">with.handlers</a> &lt;- function(expr, â¦) {<br>stack &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a>()<br>handlers &lt;- rev(list(â¦))<br>classes &lt;- names(handlers)<br>for (i in seq(along = handlers))<br>stack &lt;- add.to.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a>[(handlers[[i]], classes<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external">i], NULL, stack)</a><br>dynamic.bind(expr, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a> = stack)<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-with.handlers" target="_blank" rel="external"><code>with.handlers</code></a> (links are to index).</p>
<p>Exiting handlers are established by <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a>. A <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a> call is used to obtain an exit function that will transfer control back to the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a> call. Setting up the handlers is analogous to <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">with.handlers</a>. The result of the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a> call will always be wrapped in a list with a <code>throw</code> element to distinguish a normal return and a throw return. For an internal implementation this flag could be passed as a (thread-local) global, a field in the context structure, or the<code>setjmp</code> return value. The rest of the result listâs fields depends on whether the result represents a normal return or a throw to a handler. For a throw the result contains the handler to call and the condition to call it with. The handler is called in the handler context that exists outside the <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a> call. The <code>finally</code> clause is handled by an <code>on.exit</code> call (which will work properly with recent changes to the R internals.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external"><code>&lt;establishing handlers&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">&lt;-</a>D]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a> &lt;- function(expr, â¦, finally = NULL) {<br>on.exit(finally)<br>result &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a>(function(k) {<br>stack &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a>()<br>handlers &lt;- rev(list(â¦))<br>classes &lt;- names(handlers)<br>for (i in seq(along = handlers))<br>stack &lt;- add.to.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a>[(handlers[[i]], classes<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external">i], k, stack)</a><br>dynamic.bind(list(throw = FALSE, value = expr), <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a> = stack)<br>})<br>if (result$throw)<br>result$handler(result$condition)<br>else<br>result$value<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-try.catch" target="_blank" rel="external"><code>try.catch</code></a> (links are to index).</p>
<p>Perhaps the <code>finally</code> expression should be evaluated in a <code>try</code>.</p>
<h4 id="Condition-Objects"><a href="#Condition-Objects" class="headerlink" title="Condition Objects"></a>Condition Objects</h4><p>Conditions are objects that inherit from <code>&quot;condition&quot;</code>.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDS" target="_blank" rel="external"><code>&lt;condition objects&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDS" target="_blank" rel="external">is.condition</a> &lt;- function(c) inherits(c, âconditionâ)</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-is.condition" target="_blank" rel="external"><code>is.condition</code></a> (links are to index).</p>
<p>Two generic functions are defined on condition objects. <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.message</a> should return the message string associated with a condition. <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.call</a> should return the call associated with the condition, or <code>NULL</code> if there is none. The print method for conditions is defined in terms of these generic functions:</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDS" target="_blank" rel="external"><code>&lt;condition objects&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDS" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">print.condition</a> &lt;- function(c, â¦) {<br>msg &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.message</a>(c)<br>call &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.call</a>(c)<br>class &lt;- class(c)<a href="http://google-styleguide.googlecode.com/svn/trunk/google-r-style.html" target="_blank" rel="external">1</a><br>if (! is.null(call))<br>cat(â&lt;â, class, â in â, deparse(call), â: â, msg, â&gt;\nâ, sep=ââ)<br>else<br>cat(â&lt;â, class, â: â, msg, â&gt;\nâ, sep=ââ)<br>}</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.message</a> &lt;- function(c) UseMethod(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.message</a>â, c)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.call</a> &lt;- function(c) UseMethod(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.call</a>â, c)</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.message</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">.condition</a> &lt;- function(c) c$message<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.call</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">.condition</a> &lt;- function(c) c$call</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-condition.call" target="_blank" rel="external"><code>condition.call</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-condition.call.condition" target="_blank" rel="external"><code>condition.call.condition</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-condition.message" target="_blank" rel="external"><code>condition.message</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-condition.message.condition" target="_blank" rel="external"><code>condition.message.condition</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-print.condition" target="_blank" rel="external"><code>print.condition</code></a> (links are to index).</p>
<p>The <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">signal.condition</a> function will convert non-condition arguments to simple conditions by calling <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.condition</a>. Similarly, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a> converts non-condition arguments to simple exceptions and <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a> makes simple warnings.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDS" target="_blank" rel="external"><code>&lt;condition objects&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDV" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.condition</a> &lt;- function(message, call = NULL) {<br>class &lt;- c(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.condition</a>â, âconditionâ)<br>structure(list(message=as.character(message), call = call), class=class)<br>}</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.exception</a> &lt;- function(message, call = NULL) {<br>class &lt;- c(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.exception</a>â, âexceptionâ, âconditionâ)<br>structure(list(message=as.character(message), call = call), class=class)<br>}</p>
<p>simple.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">&lt;- function(message, call = NULL) {</a><br>class &lt;- c(âsimple.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">â, â</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a>â, âconditionâ)<br>structure(list(message=as.character(message), call = call), class=class)<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-simple.condition" target="_blank" rel="external"><code>simple.condition</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-simple.exception" target="_blank" rel="external"><code>simple.exception</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-simple.warning" target="_blank" rel="external"><code>simple.warning</code></a> (links are to index).</p>
<p>The condition system uses one condition of its own, an exception for signaling unhandled conditions. This contains a field for recording the condition that did not have a matching handler.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDS" target="_blank" rel="external"><code>&lt;condition objects&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">&lt;-</a>D]</strong><br>no.condition.handler.exception &lt;- function(c)<br>structure(list(message = paste(âno condition handler forâ, class(c)<a href="http://google-styleguide.googlecode.com/svn/trunk/google-r-style.html" target="_blank" rel="external">1</a>),<br>condition = c),<br>class = c(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDV" target="_blank" rel="external">âno.condition.handler.exceptionâ</a>,<br>âexceptionâ, âconditionâ))</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-&quot;no.condition.handler.exception&quot;" target="_blank" rel="external"><code>&quot;no.condition.handler.exception&quot;</code></a> (links are to index).</p>
<h4 id="Default-Handlers"><a href="#Default-Handlers" class="headerlink" title="Default Handlers"></a>Default Handlers</h4><p>Default calling handlers are provided for exceptions and warnings. Both are provided as methods on the generic function <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a>. Defining methods for subtypes of exceptions and warnings allows the default handling to be tuned somewhat.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external"><code>&lt;default handlers&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a> &lt;- function(e) {<br>UseMethod(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a>â, e)<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-default.handler" target="_blank" rel="external"><code>default.handler</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-1" target="_blank" rel="external"><code>&lt;global variable initialization&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-1" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-3" target="_blank" rel="external">-&gt;</a>]</strong><br>add.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDK" target="_blank" rel="external">(</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a>, âexceptionâ)<br>add.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDK" target="_blank" rel="external">(</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a>, â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a>â)</p>
<h5 id="Default-Handler-For-Exceptions"><a href="#Default-Handler-For-Exceptions" class="headerlink" title="Default Handler For Exceptions"></a>Default Handler For Exceptions</h5><p>The default handler for exceptions reproduces at the R level much of the functionality in the <code>errorcall</code> and <code>jump_to_toplevel</code> functions in <code>errors.c</code>.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external"><code>&lt;default handlers&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDY" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">.exception</a> &lt;- function(e) {<br>call &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.call</a>(e)<br>message &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.message</a>(e)<br>op &lt;- getOption(âadd.error.underscoreâ)<br>if (is.null(op) || op)<br>us &lt;- â_â<br>else<br>us &lt;- ââ<br>if (is.null(call))<br>emsg &lt;- paste(us, âError: â, message, â\nâ, sep = ââ)<br>else {<br>dcall &lt;- deparse(call)<br>if (nchar(dcall) &gt; 30)<br>emsg &lt;- paste(us, âError in â, dcall<a href="http://google-styleguide.googlecode.com/svn/trunk/google-r-style.html" target="_blank" rel="external">1</a>, â :\n\tâ, message, â\nâ,<br>sep = ââ)<br>else<br>emsg &lt;- paste(us, âError in â, dcall<a href="http://google-styleguide.googlecode.com/svn/trunk/google-r-style.html" target="_blank" rel="external">1</a>, â : â, message, â\nâ,<br>sep = ââ)<br>}</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDb" target="_blank" rel="external">seterrmessage</a>(emsg)<br>if (getOption(âerror.messagesâ)) {<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external">errcat</a>(emsg)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDZ" target="_blank" rel="external">PrintDeferredWarnings</a>()<br>}</p>
<p>handler &lt;- getOption(âerrorâ)<br>if (! is.null(handler))<br>eval(handler, R_GlobalEnv)<br>else if (! interactive()) {<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external">errcat</a>(âExecution halted\nâ)<br>q(ânoâ, 1, FALSE)  # quit, no save, no .Last, status=1<br>}</p>
<p>tb &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDa" target="_blank" rel="external">getTraceback</a>()<br>tb &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDY" target="_blank" rel="external">trim.traceback</a>(tb)<br>assign(â.Tracebackâ, tb, env = .GlobalEnv)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a>()<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-default.handler.exception" target="_blank" rel="external"><code>default.handler.exception</code></a> (links are to index).</p>
<p>To make the traceback result a little cleaner we trim off some of the leading stuff that represents the error handling code that is on the stack. We trim down at least to the leading <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">signal.condition</a> call. For calls generated by the internal error handling code we also trim off the next two frames.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external"><code>&lt;default handlers&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDZ" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDY" target="_blank" rel="external">trim.traceback</a> &lt;- function(t) {<br>n &lt;- length(t)<br>pos &lt;- NULL<br>for (i in seq(along=t))<br>if (pmatch(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">signal.condition</a>(â, t[[i]], 0)) {<br>pos &lt;- i<br>break<br>}<br>if (is.null(pos))<br>t<br>else {<br>if (pos &lt; n - 1 &amp;&amp;<br>pmatch(âmy.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">(â, t[[pos + 1]], 0) &amp;&amp;</a><br>pmatch(âerror.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">(â, t[[pos + 2]], 0))</a><br>pos &lt;- pos + 2<br>if (pos == n)<br>NULL<br>else<br>t[(pos+1):n]<br> }<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-trim.traceback" target="_blank" rel="external"><code>trim.traceback</code></a> (links are to index).</p>
<p>Deferred warnings are printed by a hook into the internals provided in <code>errors.c</code>. This hook is temporary and hence not declared in the header files, so we need to declare it here.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external"><code>&lt;default handlers&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDY" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDa" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDZ" target="_blank" rel="external">PrintDeferredWarnings</a> &lt;- function() .Call(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDZ" target="_blank" rel="external">PrintDeferredWarnings</a>â)</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-PrintDeferredWarnings" target="_blank" rel="external"><code>PrintDeferredWarnings</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external"><code>&lt;declarations for hooks in errors.c&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-3" target="_blank" rel="external">-&gt;</a>]</strong><br>void <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-2" target="_blank" rel="external">R_PrintDeferredWarnings</a>(void);</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-R_PrintDeferredWarnings" target="_blank" rel="external"><code>R_PrintDeferredWarnings</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**Pa-1" target="_blank" rel="external"><code>&lt;</code>PrintDeferredWarnings<code>definition&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong><br>SEXP <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDZ" target="_blank" rel="external">PrintDeferredWarnings</a>(void)<br>{<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-2" target="_blank" rel="external">R_PrintDeferredWarnings</a>();<br>return R_NilValue;<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-PrintDeferredWarnings" target="_blank" rel="external"><code>PrintDeferredWarnings</code></a> (links are to index).</p>
<p>The traceback is also generated by a hook function in <code>errors.c</code>. This hook allows us to exclude a specified number of frames on the top of the stack, but it isnât clear if this is useful.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external"><code>&lt;default handlers&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDZ" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDb" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDa" target="_blank" rel="external">getTraceback</a> &lt;- function(skip = 1)<br>.Call(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**GR-1" target="_blank" rel="external">GetTraceback</a>â, as.integer(skip))</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-getTraceback" target="_blank" rel="external"><code>getTraceback</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external"><code>&lt;declarations for hooks in errors.c&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-2" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-4" target="_blank" rel="external">-&gt;</a>]</strong><br>SEXP <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-3" target="_blank" rel="external">R_GetTraceback</a>(int);</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-R_GetTraceback" target="_blank" rel="external"><code>R_GetTraceback</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**GR-1" target="_blank" rel="external"><code>&lt;</code>GetTraceback<code>definition&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong><br>SEXP <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**GR-1" target="_blank" rel="external">GetTraceback</a>(SEXP skip)<br>{<br>if (TYPEOF(skip) != INTSXP || LENGTH(skip) != 1)<br> error(âbad skip argumentâ);<br>return <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-3" target="_blank" rel="external">R_GetTraceback</a>(INTEGER(skip)[0]);<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-GetTraceback" target="_blank" rel="external"><code>GetTraceback</code></a> (links are to index).</p>
<p>Finally, the default handler needs to be able to place the error message in the internal error buffer (just for consistency with existing codeâthis can probably be dropped eventually, or at least it would need to be made thread-safe).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external"><code>&lt;default handlers&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDa" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDc" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDb" target="_blank" rel="external">seterrmessage</a> &lt;- function(s)<br>.C(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**SS-1" target="_blank" rel="external">SetErrmessage</a>â, as.character(s))</p>
<p> Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-seterrmessage" target="_blank" rel="external"><code>seterrmessage</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external"><code>&lt;declarations for hooks in errors.c&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-3" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">-&gt;</a>]</strong><br>void <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-4" target="_blank" rel="external">R_SetErrmessage</a>(char *s);</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-R_SetErrmessage" target="_blank" rel="external"><code>R_SetErrmessage</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**SS-1" target="_blank" rel="external"><code>&lt;</code>SetErrmessage<code>definition&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong><br>void <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**SS-1" target="_blank" rel="external">SetErrmessage</a>(char <em>*s)<br>{<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-4" target="_blank" rel="external">R_SetErrmessage</a>(</em>s);<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-SetErrmessage" target="_blank" rel="external"><code>SetErrmessage</code></a> (links are to index).</p>
<h5 id="Default-Handler-For-Warnigs"><a href="#Default-Handler-For-Warnigs" class="headerlink" title="Default Handler For Warnigs"></a>Default Handler For Warnigs</h5><p>As a temporary hack, we can use the internal code for <code>warningcall</code> to implement the default warning handler. We need to turn the hook off around the call. If there is an error in the call, then the hooks will be reset along with the error hook by the calls to <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">EnableErrorHooks</a>. There may be a flaw in this, but for now it should do.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external"><code>&lt;default handlers&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDb" target="_blank" rel="external">&lt;-</a>D]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDc" target="_blank" rel="external">&lt;- function(w) {</a><br>.Call(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**IY-1" target="_blank" rel="external">InternalWarningCall</a>â, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.call</a>(w), <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.message</a>(w))<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-default.handler.warning" target="_blank" rel="external"><code>default.handler.warning</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**IY-1" target="_blank" rel="external"><code>&lt;</code>InternalWarningCall<code>definition&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong><br>SEXP <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**IY-1" target="_blank" rel="external">InternalWarningCall</a>(SEXP call, SEXP msg)<br>{<br>if (TYPEOF(msg) != STRSXP || LENGTH(msg) != 1)<br> error(âinvalid <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a> messageâ);<br> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">R_SetWarningHook</a>(NULL);<br> Rf_warningcall(call, â%sâ, CHAR(STRING_ELT(msg, 0)));<br> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">R_SetWarningHook</a>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">warnhook</a>);<br> return R_NilValue;<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-InternalWarningCall" target="_blank" rel="external"><code>InternalWarningCall</code></a> (links are to index).</p>
<h4 id="Internal-Error-Conversion"><a href="#Internal-Error-Conversion" class="headerlink" title="Internal Error Conversion"></a>Internal Error Conversion</h4><p>The error handling mechanism of this package is activated by installing some hook functions. The R interface for this is <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">EnableErrorHooks</a>.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external"><code>&lt;internal error conversion&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">EnableErrorHooks</a> &lt;- function() {<br>.Call(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">EnableExceptionHooks</a>â)<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-EnableErrorHooks" target="_blank" rel="external"><code>EnableErrorHooks</code></a> (links are to index).</p>
<p>The hooks provided in <code>errors.c</code> are declares as</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external"><code>&lt;declarations for hooks in errors.c&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-4" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDh" target="_blank" rel="external">-&gt;</a>]</strong><br>void <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">R_SetErrorHook</a>(void (<em><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a>)(SEXP, char </em>));<br>void <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">R_SetWarningHook</a>(void (<em><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a>)(SEXP, char </em>));</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-R_SetErrorHook" target="_blank" rel="external"><code>R_SetErrorHook</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-R_SetWarningHook" target="_blank" rel="external"><code>R_SetWarningHook</code></a> (links are to index).</p>
<p>Both hooks are installed by a common mechanism. They call back into R using R functions called <code>error</code>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a> and <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a>, respectively.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external"><code>&lt;</code>EnableExceptionHooks<code>definition&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">static void</a> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a>(SEXP fun, SEXP call, char *s)<br>{<br>SEXP expr, msg, qsym = install(âquoteâ);<br>PROTECT(msg = allocVector(STRSXP, 1));<br>SET_STRING_ELT(msg, 0, mkChar(s));<br>PROTECT(call = LCONS(qsym, LCONS(call, R_NilValue)));<br>expr = LCONS(msg, R_NilValue);<br>expr = LCONS(call, expr);<br>PROTECT(expr = LCONS(fun, expr));<br>eval(expr, R_GlobalEnv);<br>UNPROTECT(3);<br>}</p>
<p>static void <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">errhook</a>(SEXP call, char *s)<br>{<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a>(install(âerror.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">â), call, s);</a><br>}</p>
<p>static void <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">warnhook</a>(SEXP call, char *s)<br>{<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a>(install(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">â), call, s);</a><br>}</p>
<p>SEXP <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">EnableExceptionHooks</a>(void)<br>{<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">R_SetErrorHook</a>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">errhook</a>);<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">R_SetWarningHook</a>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">warnhook</a>);<br>return R_NilValue;<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-EnableExceptionHooks" target="_blank" rel="external"><code>EnableExceptionHooks</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-errhook" target="_blank" rel="external"><code>errhook</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-hook" target="_blank" rel="external"><code>hook</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-warnhook" target="_blank" rel="external"><code>warnhook</code></a> (links are to index).</p>
<p>The R hook functions in turn just call <code>my</code>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a> and <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">my.warn</a>. This is all quite a lot of overhead that could be avoided in an internal implementation, but the only real issue is that it might create problems if the error being signaled is about resource exhaustion of some kind.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external"><code>&lt;internal error conversion&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">&lt;-</a>D]</strong><br>error.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">&lt;- function(call, msg)</a><br> my.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">(</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.exception</a>(msg, call))</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">&lt;- function(call, msg)</a><br> my.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">(simple.</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">(msg, call))</a></p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-error.hook" target="_blank" rel="external"><code>error.hook</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-warning.hook" target="_blank" rel="external"><code>warning.hook</code></a> (links are to index).</p>
<p>The reset mechanism needs to be able to jump to top level. The <code>.Call</code> interface for this is provided by <code>JumpToToplevel</code>.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external"><code>&lt;declarations for hooks in errors.c&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">&lt;-</a>D]</strong><br>void <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDh" target="_blank" rel="external">R_JumpToToplevel</a>(Rboolean <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>);</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-R_JumpToToplevel" target="_blank" rel="external"><code>R_JumpToToplevel</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**JT-1" target="_blank" rel="external"><code>&lt;</code>JumpToToplevel<code>definition&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U-&gt;</a>)</strong><br>SEXP JumpToToplevel(SEXP <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>)<br>{<br>if (TYPEOF(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>) != LGLSXP || LENGTH(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>) != 1)<br> error(âbad restarts.honored argumentâ);<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDh" target="_blank" rel="external">R_JumpToToplevel</a>(LOGICAL(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>)[0]);<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-R_JumpToToplevel" target="_blank" rel="external"><code>R_JumpToToplevel</code></a> (links are to index).</p>
<h4 id="Resets"><a href="#Resets" class="headerlink" title="Resets"></a>Resets</h4><p>Resets are stored as objects of class <code>reset</code> with fields containing all the settings for the reset.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external"><code>&lt;resets&gt;=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDj" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">make.reset</a> &lt;- function(name = ââ,<br>handler = function(â¦) NULL,<br>message = NULL,<br>test = function(c) TRUE,<br>interactive = function() NULL,<br>restarts.honored = FALSE) {<br>structure(list(name = name, handler = handler, message = message,<br>test = test, interactive = interactive,<br>restarts.honored = restarts.honored),<br>class = âresetâ)<br>}</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">print.reset</a> &lt;- function(r)<br><code>cat(paste(&quot;&lt;reset:&quot;, r$name, &quot;&gt;\n&quot;))</code></p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">is.reset</a> &lt;- function(x) inherits(x, âresetâ)</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-is.reset" target="_blank" rel="external"><code>is.reset</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-make.reset" target="_blank" rel="external"><code>make.reset</code></a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-print.reset" target="_blank" rel="external"><code>print.reset</code></a> (links are to index).</p>
<p>Resets are maintained in a stack. The function <code>add.to</code>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">reset.stack</a> creates the reset object, adds a name field to it, and also adds an exit function. The reset is then linked on the front of the specified stack.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external"><code>&lt;resets&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDj" target="_blank" rel="external">add.to.</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">reset.stack</a> <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDj" target="_blank" rel="external">&lt;- function(spec, name, exit, stack) {</a><br>if (is.function(spec))<br>reset &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">make.reset</a>(handler = spec)<br>else if (is.character(spec))<br>reset &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">make.reset</a>(message = spec)<br>else if (is.list(spec))<br>reset &lt;- do.call(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">make.reset</a>â, spec)<br>else<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>(ânot a valid reset specificationâ)<br>reset$name &lt;- name<br>list(reset = reset, exit = exit, next.reset = stack)<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-add.to.reset.stack" target="_blank" rel="external"><code>add.to.reset.stack</code></a> (links are to index).</p>
<p>The reset stack is maintained as a dynamic variable. The initial stack contains a handler for <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> resets that jumps to top level, but honors any restarts that might be on the stack.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external"><code>&lt;global variables&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">&lt;-</a>D]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">reset.stack</a> &lt;- NULL  ## place holder for .First.lib</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-reset.stack" target="_blank" rel="external"><code>reset.stack</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-1" target="_blank" rel="external"><code>&lt;global variable initialization&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-2" target="_blank" rel="external">&lt;-</a>D]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">reset.stack</a> &lt;&lt;- dynamic.variable(<br>add.to.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">reset.stack</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDj" target="_blank" rel="external">(list(handler = function() {},</a><br>restarts.honored = TRUE),<br>â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a>â,<br>function(result, restarts.honored)<br>.Call(âJumpToToplevelâ, restarts.honored),<br>NULL))</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-reset.stack" target="_blank" rel="external"><code>reset.stack</code></a> (links are to index).</p>
<p>The function <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">with.resets</a> for establishing (exiting) resets is analogous to <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a>. Since the number of arguments to the handler is not known, we need to call it with <code>do.call</code>. We have to first store the handler in a variable, since <code>do.call</code> does not allow a computed function as its first argumentâit has to be a string.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external"><code>&lt;resets&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDj" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">with.resets</a> &lt;- function(expr, â¦) {<br>result &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a>(function(k) {<br>stack &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">reset.stack</a>()<br>specs &lt;- rev(list(â¦))<br>names &lt;- names(specs)<br>for (i in seq(along = specs))<br>stack &lt;- add.to.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">reset.stack</a>[(specs[[i]], names<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDj" target="_blank" rel="external">i], k, stack)</a><br>dynamic.bind(list(throw = FALSE, value = expr), <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">reset.stack</a> = stack)<br>})<br>if (result$throw) {<br>h &lt;- result$handler<br>do.call(âhâ, result$args)<br>}<br>else<br>result$value<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-with.resets" target="_blank" rel="external"><code>with.resets</code></a> (links are to index).</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">find.reset</a> walks down the reset stack looking for the first one that matches the name and accepts the condition, if one is specified.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external"><code>&lt;resets&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">find.reset</a> &lt;- function(name, cond = NULL) {<br>r &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">reset.stack</a>()<br>while (! is.null(r))<br>if (name == r$reset$name &amp;&amp; (is.null(cond) || r$reset$test(cond))) {<br>res &lt;- r$reset<br>res$exit &lt;- r$exit<br>return(res)<br>}<br>else<br>r &lt;- r$next.reset<br>NULL<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-find.reset" target="_blank" rel="external"><code>find.reset</code></a> (links are to index).</p>
<p>Similarly, <code>compute.restarts</code> walks down the sestart stack and accumulates all elligible restarts into a list.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external"><code>&lt;resets&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">compute.resets</a> &lt;- function(cond = NULL) {<br>r &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">reset.stack</a>()<br>val &lt;- NULL<br>while (! is.null(r)) {<br>if (is.null(cond) || r$reset$test(cond)) {<br>res &lt;- r$reset<br>res$exit &lt;- r$exit<br>val &lt;- c(val, list(res))<br>}<br>r &lt;- r$next.reset<br>}<br>val<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-compute.resets" target="_blank" rel="external"><code>compute.resets</code></a> (links are to index).</p>
<p><code>invoke</code>.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a> accpets either a string, which is passed to find.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>, or a reset as its first argument. The remaining arguments, if any, are packed up as a list, along with the resetâs handler and a <code>throw</code> flag, into a result list which is then passed to the exit function stored in the reset object. The reset objectâs <code>restarts.honored</code> field determines whether the transfer of control stops at intervening restarted call frames or not.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external"><code>&lt;resets&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">invoke.reset</a> &lt;- function(r, â¦) {<br>if (! <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">is.reset</a>(r))<br>r &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">find.reset</a>(r)<br>if (is.null(r$exit))<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>(âcalling resets not supported (yet)â)<br>result &lt;- list(throw = TRUE, handler = r$handler, args = list(â¦))<br>r$exit(result, r$restarts.honored)<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-invoke.reset" target="_blank" rel="external"><code>invoke.reset</code></a> (links are to index).</p>
<p>The <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> function is just a simple shorthand for invoking an <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> reset.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external"><code>&lt;resets&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">&lt;-</a>D<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDq" target="_blank" rel="external">-&gt;</a>]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a> &lt;- function()<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">invoke.reset</a>(â<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a>â)</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-abort" target="_blank" rel="external"><code>abort</code></a> (links are to index).</p>
<p>The <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">invoke.reset</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDq" target="_blank" rel="external">.interactively</a> function differs from <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">invoke.reset</a> only in the fact that it computes the arguments for the reset handler by calling the resetâs<code>interactive</code> function.</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external"><code>&lt;resets&gt;+=</code></a> <strong>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">&lt;-U</a>)</strong> <strong>[<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">&lt;-</a>D]</strong><br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">invoke.reset</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDq" target="_blank" rel="external">.interactively</a> &lt;- function(r) {<br>if (! <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">is.reset</a>(r))<br>r &lt;- <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">find.reset</a>(r)<br>if (is.null(r$exit))<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>(âcalling resets not supported (yet)â)<br>args &lt;- r$interactive()<br>result &lt;- list(throw = TRUE, handler = r$handler, args = args)<br>r$exit(result, r$restarts.honored)<br>}</p>
<p>Defines <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWI-invoke.reset.interactively" target="_blank" rel="external"><code>invoke.reset.interactively</code></a> (links are to index).</p>
<h4 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h4><p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDr" target="_blank" rel="external"><code>&lt;tests&gt;=</code></a><br>.lib.loc &lt;- c(âlibâ,.lib.loc)<br>library(simpcond)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a>(1, finally=print(âHelloâ))<br>e&lt;-<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.exception</a>(âtest exceptionâ)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>(e)<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>(e), finally=print(âHelloâ))<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>(âfredâ), finally=print(âHelloâ))<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>(e), exception = function(e) e, finally=print(âHelloâ))<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a>(<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>(âfredâ),  exception = function(e) e, finally=print(âHelloâ))<br><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD3" target="_blank" rel="external">muffle.warnings</a>({my.<a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">(âHelloâ); 1})</a></p>
<h3 id="Dylan-Condition-Handling"><a href="#Dylan-Condition-Handling" class="headerlink" title="Dylan Condition Handling"></a>Dylan Condition Handling</h3><p>Dylan was designed after Common Lisp and had the opportunity to make improvements. At first glance it seemed that their condition system was as powerfull but rather simpler than the CL one because it merged restarts and conditions into a single hierarchy. Unfortunately there seems to be a problem with this approach: For this to work the handler stack must not be unwound before a handler is called, otherwise restarts established after the handler wonât be available. But if the handler stack is not unwound, then it would seem that an error in the handler will cause the handler to be called again and again and â¦</p>
<p>Just to make sure I installed <code>mindy</code> and ran this Dylan program:</p>
<p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDs" target="_blank" rel="external"><code>&lt;hello.dyl&gt;=</code></a><br>module: dylan-user</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define method main(name :: &lt;string&gt;, <span class="comment">#rest arguments)</span></span><br><span class="line">  let handler &lt;error&gt; = method (c, <span class="keyword">next</span>)</span><br><span class="line">    puts(<span class="string">"handled the error\n"</span>);</span><br><span class="line">    error(c);</span><br><span class="line">  end;</span><br><span class="line">  error(<span class="string">"an error"</span>);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>Compile and run gives:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">luke@nokomis2 ~% mindycomp hello.dyl</span><br><span class="line">luke@nokomis2 ~% mindy -f hello.dbc</span><br><span class="line">handled the error</span><br><span class="line">handled the error</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&lt;a name=<span class="string">"NWDt"</span>&gt;handled the error&lt;/a&gt;</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>
<p>So their design really is hosed: if there is an error in a calling handler for <error> you blow out the top.</error></p>
<p>It looks like CL got this right (or at least more so than Dylan did).</p>
<ul>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD4" target="_blank" rel="external"><em><browse on="" warnings=""></browse></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD4" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDH" target="_blank" rel="external"><em><call with="" current="" continuation=""></call></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDH" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDS" target="_blank" rel="external"><em><condition objects=""></condition></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDS" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">D4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDV" target="_blank" rel="external">D5</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external"><em><declarations for="" hooks="" in="" errors.c=""></declarations></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-2" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-3" target="_blank" rel="external">D4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-4" target="_blank" rel="external">D5</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">D6</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDh" target="_blank" rel="external">D7</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external"><em><default handlers=""></default></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDY" target="_blank" rel="external">D4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDZ" target="_blank" rel="external">D5</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDa" target="_blank" rel="external">D6</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDb" target="_blank" rel="external">D7</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDc" target="_blank" rel="external">D8</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external"><em>&lt;<code>EnableExceptionHooks</code> definition&gt;</em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external"><em><establishing handlers=""></establishing></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD3" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">D4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">D5</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD2" target="_blank" rel="external"><em><example></example></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD2" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD5" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD8" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD9" target="_blank" rel="external">D4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**GR-1" target="_blank" rel="external"><em>&lt;<code>GetTraceback</code> definition&gt;</em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**GR-1" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-1" target="_blank" rel="external"><em><global variable="" initialization=""></global></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-1" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-2" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-3" target="_blank" rel="external">D4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external"><em><global variables=""></global></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">D3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external"><em><handler stack="" management=""></handler></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDK" target="_blank" rel="external">D3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDs" target="_blank" rel="external"><em><hello.dyl></hello.dyl></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDs" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external"><em><internal error="" conversion=""></internal></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">D4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**IY-1" target="_blank" rel="external"><em>&lt;<code>InternalWarningCall</code> definition&gt;</em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**IY-1" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external"><em><invoking handlers=""></invoking></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDM" target="_blank" rel="external">D3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**JT-1" target="_blank" rel="external"><em>&lt;<code>JumpToToplevel</code> definition&gt;</em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**JT-1" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external"><em><namespace></namespace></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD7" target="_blank" rel="external"><em><possible `restart`="" changes=""></possible></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD7" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**Pa-1" target="_blank" rel="external"><em>&lt;<code>PrintDeferredWarnings</code> definition&gt;</em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**Pa-1" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external"><em><pure r="" implementation="" of="" call="" with="" current="" continuation=""></pure></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external"><em><resets></resets></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDj" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">D4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">D5</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">D6</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">D7</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">D8</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDq" target="_blank" rel="external">D9</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD6" target="_blank" rel="external"><em><resets example=""></resets></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD6" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external"><em>&lt;<code>ReturnOrRestart</code> definition&gt;</em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**SS-1" target="_blank" rel="external"><em>&lt;<code>SetErrmessage</code> definition&gt;</em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**SS-1" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external"><em><signaling conditions=""></signaling></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">D4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external"><em><simpcond.c></simpcond.c></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDC" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external"><em><simpcond.r></simpcond.r></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">D1</a></li>
<li><p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDr" target="_blank" rel="external"><em><tests></tests></em></a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDr" target="_blank" rel="external">D1</a></p>
</li>
<li><p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">abort</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD5" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD7" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDM" target="_blank" rel="external">U4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">U5</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">U6</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-3" target="_blank" rel="external">U7</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">D8</a></p>
</li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDK" target="_blank" rel="external">add.default.handler</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDK" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-2" target="_blank" rel="external">U2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external">add.to.handler.stack</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDK" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">U4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDj" target="_blank" rel="external">add.to.reset.stack</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDj" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-3" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">U3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">callcc</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDE" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDH" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">U4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">compute.resets</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD5" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">D3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.call</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDc" target="_blank" rel="external">U3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.call.condition</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.message</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDc" target="_blank" rel="external">U3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">condition.message.condition</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">default.handler</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDK" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDW" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-2" target="_blank" rel="external">U4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">U5</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDc" target="_blank" rel="external">U6</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">default.handler.exception</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDc" target="_blank" rel="external">default.handler.warning</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDc" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external">DoReturn</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDH" target="_blank" rel="external">U2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external">DoReturnOrRestart</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDH" target="_blank" rel="external">U2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">EnableErrorHooks</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDB" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDM" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">D4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">EnableExceptionHooks</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDd" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external">errcat</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDM" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-intP-1" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">U4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">errhook</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">error.hook</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDY" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">D3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDM" target="_blank" rel="external">FailsafeErrorHandler</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDM" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">find.reset</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDq" target="_blank" rel="external">U4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDa" target="_blank" rel="external">getTraceback</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDa" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**GR-1" target="_blank" rel="external">GetTraceback</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDa" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**GR-1" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external">handle.condition</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">U2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">handler.stack</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDI" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-1" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDJ" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDK" target="_blank" rel="external">U4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external">U5</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">U6</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">U7</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">hook</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDY" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">U4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external">ignore.errors</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**IY-1" target="_blank" rel="external">InternalWarningCall</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDc" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**IY-1" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">invoke.reset</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDp" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDq" target="_blank" rel="external">U4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDq" target="_blank" rel="external">invoke.reset.interactively</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDq" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDS" target="_blank" rel="external">is.condition</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDS" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">is.reset</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDq" target="_blank" rel="external">U3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">make.reset</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDj" target="_blank" rel="external">U2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD3" target="_blank" rel="external">muffle.warnings</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD3" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDr" target="_blank" rel="external">U3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">my.stop</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDY" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">U4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">my.warning</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDr" target="_blank" rel="external">U3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDV" target="_blank" rel="external">âno.condition.handler.exceptionâ</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDV" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">print.condition</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDT" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDZ" target="_blank" rel="external">PrintDeferredWarnings</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDZ" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**Pa-1" target="_blank" rel="external">D3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">print.reset</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDi" target="_blank" rel="external">D1</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">reset.stack</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDj" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDk" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-3" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">U4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDm" target="_blank" rel="external">U5</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDn" target="_blank" rel="external">U6</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">restart</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD6" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD7" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD8" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD9" target="_blank" rel="external">U4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">D5</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external">U6</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDh" target="_blank" rel="external">U7</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**JT-1" target="_blank" rel="external">U8</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD7" target="_blank" rel="external">restartable</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD7" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD9" target="_blank" rel="external">U2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-3" target="_blank" rel="external">R_GetTraceback</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-3" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**GR-1" target="_blank" rel="external">U2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDh" target="_blank" rel="external">R_JumpToToplevel</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDh" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**JT-1" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-2" target="_blank" rel="external">R_PrintDeferredWarnings</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-2" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**Pa-1" target="_blank" rel="external">U2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external">R_ReturnOrRestart</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDF" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDG" target="_blank" rel="external">U2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-4" target="_blank" rel="external">R_SetErrmessage</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-decY-4" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**SS-1" target="_blank" rel="external">U2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">R_SetErrorHook</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">D1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">U2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">R_SetWarningHook</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**IY-1" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDe" target="_blank" rel="external">D2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">U3</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDb" target="_blank" rel="external">seterrmessage</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDb" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**SS-1" target="_blank" rel="external">SetErrmessage</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDb" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**SS-1" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">signal.condition</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD2" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD6" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">D4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">U5</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">U6</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDY" target="_blank" rel="external">U7</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.condition</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD2" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDN" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">D4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.exception</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">U4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDr" target="_blank" rel="external">U5</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">simple.warning</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">U4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">stop</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD8" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD9" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDA" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDL" target="_blank" rel="external">U5</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDO" target="_blank" rel="external">D6</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDY" target="_blank" rel="external">U7</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">U8</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDj" target="_blank" rel="external">U9</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDo" target="_blank" rel="external">U10</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDq" target="_blank" rel="external">U11</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDr" target="_blank" rel="external">U12</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDY" target="_blank" rel="external">trim.traceback</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDX" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDY" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">try.catch</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD1" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDR" target="_blank" rel="external">D3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDr" target="_blank" rel="external">U4</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">warnhook</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**IY-1" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">warning</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD3" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD4" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDP" target="_blank" rel="external">D4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDU" target="_blank" rel="external">U5</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-gloU-2" target="_blank" rel="external">U6</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDc" target="_blank" rel="external">U7</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWsimB-**IY-1" target="_blank" rel="external">U8</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">U9</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">U10</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDr" target="_blank" rel="external">U11</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">warning.hook</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDf" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDg" target="_blank" rel="external">D2</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">with.handlers</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD2" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD3" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD4" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD6" target="_blank" rel="external">U4</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U5</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDQ" target="_blank" rel="external">D6</a></li>
<li><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">with.resets</a>: <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD6" target="_blank" rel="external">U1</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWD7" target="_blank" rel="external">U2</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDD" target="_blank" rel="external">U3</a>, <a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html#NWDl" target="_blank" rel="external">D4</a></li>
</ul>
<hr>
<p>This is a translation of <a href="http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html" target="_blank" rel="external">Beyond exception handling: conditions and restarts</a> by Peter Seibel, from Lisp to R. The original document is copyright (c) 2003-2005, Peter Seibel; translated with permission.</p>
<p>The majority of the translation involves changing Lisp syntax to R syntax. There are few differences in the overall system.</p>
<h1 id="Beyond-Exception-Handling-Conditions-and-Restarts"><a href="#Beyond-Exception-Handling-Conditions-and-Restarts" class="headerlink" title="Beyond Exception Handling: Conditions and Restarts"></a>Beyond Exception Handling: Conditions and Restarts</h1><p>One of Râs great features is its <em>condition</em> system. It serves a similar purpose to the exception handling systems in Java, Python, and C++ but is more flexible. In fact, its flexibility extends beyond error handlingâconditions are more general than exceptions in that a condition can represent any occurrence during a programâs execution that may be of interest to code at different levels on the call stack. For example, in the section âOther Uses for Conditions,â youâll see that conditions can be used to emit warnings without disrupting execution of the code that emits the warning while allowing code higher on the call stack to control whether the warning message is printed. For the time being, however, Iâll focus on error handling.</p>
<p>The condition system is more flexible than exception systems because instead of providing a two-part division between the code that signals an error^1^ and the code that handles it,^2^ the condition system splits the responsibilities into three partsâ<em>signaling</em> a condition, <em>handling</em> it, and <em>restarting</em>. In this chapter, Iâll describe how you could use conditions in part of a hypothetical application for analyzing log files. Youâll see how you could use the condition system to allow a low-level function to detect a problem while parsing a log file and signal an error, to allow mid-level code to provide several possible ways of recovering from such an error, and to allow code at the highest level of the application to define a policy for choosing which recovery strategy to use.</p>
<p>To start, Iâll introduce some terminology: <em>errors</em>, as Iâll use the term, are the consequences of Murphyâs law. If something can go wrong, it will: a file that your program needs to read will be missing, a disk that you need to write to will be full, the server youâre talking to will crash, or the network will go down. If any of these things happen, it may stop a piece of code from doing what you want. But thereâs no bug; thereâs no place in the code that you can fix to make the nonexistent file exist or the disk not be full. However, if the rest of the program is depending on the actions that were going to be taken, then youâd better deal with the error somehow or you <em>will</em> have introduced a bug. So, errors arenât caused by bugs, but neglecting to handle an error is almost certainly a bug.</p>
<p>So, what does it mean to handle an error? In a well-written program, each function is a black box hiding its inner workings. Programs are then built out of layers of functions: high-level functions are built on top of the lower-level functions, and so on. This hierarchy of functionality manifests itself at runtime in the form of the call stack: if <code>high</code> calls <code>medium</code>, which calls <code>low</code>, when the flow of control is in <code>low</code>, itâs also still in <code>medium</code> and <code>high</code>, that is, theyâre still on the call stack.</p>
<p>Because each function is a black box, function boundaries are an excellent place to deal with errors. Each functionâ<code>low</code>, for exampleâhas a job to do. Its direct callerâ<code>medium</code> in this caseâis counting on it to do its job. However, an error that prevents it from doing its job puts all its callers at risk: <code>medium</code> called <code>low</code> because it needs the work done that <code>low</code> does; if that work doesnât get done, <code>medium</code> is in trouble. But this means that <code>medium</code>âs caller, <code>high</code>, is also in troubleâand so on up the call stack to the very top of the program. On the other hand, because each function is a black box, if any of the functions in the call stack can somehow do their job despite underlying errors, then none of the unctions above it needs to know there was a problemâall those functions care about is that the function they called somehow did the work expected of it.</p>
<p>In most languages, errors are handled by returning from a failing function and giving the caller the choice of either recovering or failing itself. Some languages use the normal function return mechanism, while languages with exceptions return control by <em>throwing</em> or <em>raising</em> an exception. Exceptions are a vast improvement over using normal function returns, but both schemes suffer from a common flaw: while searching for a function that can recover, the stack unwinds, which means code that might recover has to do so without the context of what the lower-level code was trying to do when the error actually occurred.</p>
<p>Consider the hypothetical call chain of <code>high</code>, <code>medium</code>, <code>low</code>. If <code>low</code> fails and <code>medium</code> canât recover, the ball is in <code>high</code>âs court. For <code>high</code> to handle the error, it must either do its job without any help from <code>medium</code> or somehow change things so calling <code>medium</code> will work and call it again. The first option is theoretically clean but implies a lot of extra codeâa whole extra implementation of whatever it was <code>medium</code> was supposed to do. And the further the stack unwinds, the more work that needs to be redone. The second optionâpatching things up and retryingâis tricky; for <code>high</code> to be able to change the state of the world so a second call into <code>medium</code> wonât end up causing an error in <code>low</code>, itâd need an unseemly knowledge of the inner workings of both <code>medium</code> and <code>low</code>, contrary to the notion that each function is a black box.</p>
<h2 id="The-R-Way"><a href="#The-R-Way" class="headerlink" title="The R Way"></a>The R Way</h2><p>Râs error handling system gives you a way out of this conundrum by letting you separate the code that actually recovers from an error from the code that decides how to recover. Thus, you can put recovery code in low-level functions without committing to actually using any particular recovery strategy, leaving that decision to code in high-level functions.</p>
<p>To get a sense of how this works, letâs suppose youâre writing an application that reads some sort of textual log file, such as a Web serverâs log. Somewhere in your application youâll have a function to parse the individual log entries. Letâs assume youâll write a function, <code>parse_log_entry()</code>, that will be passed a string containing the text of a single log entry and that is supposed to return a <code>log_entry()</code> object representing the entry. This function will be called from a function, <code>parse_log_file()</code>, that reads a complete log file and returns a list of objects representing all the entries in the file.</p>
<p>To keep things simple, the <code>parse_log_entry()</code> function will not be required to parse incorrectly formatted entries. It will, however, be able to detect when its input is malformed. But what should it do when it detects bad input? In C youâd return a special value to indicate there was a problem. In Java or Python youâd throw or raise an exception. In R, you signal a condition.</p>
<h2 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h2><p>A <em>condition</em> is an S3 object whose class indicates the general nature of the condition and whose instance data carries information about the details of the particular circumstances that lead to the condition being signaled.^3^ In this hypothetical log analysis program, you might define a condition class, <code>malformed_log_entry_error</code>, that <code>parse_log_entry()</code> will signal if itâs given data it canât parse.</p>
<p>Conditional classes are regular S3 classes, built up from a list with components <code>message</code> and <code>call</code>. There is no built in function to generate a new object of class condition, but we can add one:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">condition &lt;- function(subclass, message, call = sys.call(-1), ...) &#123;</span><br><span class="line">  structure(</span><br><span class="line">    class = c(subclass, &quot;condition&quot;),</span><br><span class="line">    list(message = message, call = call, ...)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When using the condition system for error handling, you should define your conditions as subclasses of <code>error</code>, a subclass of <code>condition</code>. Thus, you might define <code>malformed_log_entry_error</code>, with a slot to hold the argument that was passed to <code>parse_log_entry()</code>, like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">malformed_log_entry_error &lt;- function(text) &#123;</span><br><span class="line">  msg &lt;- paste0(&quot;Malformed log entry: &quot;, text)</span><br><span class="line">  condition(c(&quot;malformed_log_entry_entry&quot;, &quot;error&quot;),</span><br><span class="line">    message = msg,</span><br><span class="line">    text = text</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Condition-Handlers"><a href="#Condition-Handlers" class="headerlink" title="Condition Handlers"></a>Condition Handlers</h2><p>In <code>parse_log_entry()</code> youâll signal a <code>malformed_log_entry_error</code> if you canât parse the log entry. You signal errors with the function <code>stop()</code>. <code>stop()</code> is normally just called with a string, the error message, but you can also call it with a condition object. Thus, you could write <code>parse_log_entry()</code> like this, eliding the details of actually parsing a log entry:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parse_log_entry &lt;- function(text) &#123;</span><br><span class="line">  if (!well_formed_log_entry(text)) &#123;</span><br><span class="line">    stop(malformed_log_entry_error(text))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_log_entry(text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What happens when the error is signaled depends on the code above <code>parse_log_entry()</code> on the call stack. To avoid a top level error message, you must establish a <em>condition handler</em> in one of the functions leading to the call to <code>parse_log_entry</code>. When a condition is signaled, the signaling machinery looks through a list of active condition handlers, looking for a handler that can handle the condition being signaled based on the conditionâs class. Each condition handler consists of a type specifier indicating what types of conditions it can handle and a function that takes a single argument, the condition. At any given moment there can be many active condition handlers established at various levels of the call stack. When a condition is signaled, the signaling machinery finds the most recently established handler whose type specifier is compatible with the condition being signaled and calls its function, passing it the condition object.</p>
<p>The handler function can then choose whether to handle the condition. The function can decline to handle the condition by simply returning normally, in which case control returns to next most recently established handler with a compatible type specifier. To handle the condition, the function must transfer control out of the signaller via a <em>nonlocal exit</em>. In the next section, youâll see how a handler can choose where to transfer control. However, many condition handlers simply want to unwind the stack to the place where they were established and then run some code. The function <code>tryCatch()</code> establishes this kind of condition handler. The basic form of a <code>tryCatch</code> is as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tryCatch(expression,</span><br><span class="line">  condition_class_1 = function(var) ...,</span><br><span class="line">  condition_class_2 = function(var) ...,</span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>If the <em>expression</em> returns normally, then its value is returned by the <code>tryCatch()</code>. The body of a <code>tryCatch()</code> must be a single expression; but you can always use <code>{</code> to combine several expressions into a single form. If, however, the expression signals a condition thatâs an instance of any of the <em>condition class</em>s then the code in the appropriate error clause is executed and its value returned by the <code>tryCatch()</code>. The <em>var</em> is the name of the variable that will hold the condition object when the handler code is executed. If the code doesnât need to access the condition object, you can omit the variable name.</p>
<p>For instance, one way to handle the <code>malformed_log_entry_error</code> signaled by <code>parse_log_entry()</code> in its caller, <code>parse_log_file()</code>, would be to skip the malformed entry. In the following function, the <code>tryCatch()</code> expression will either return the value returned by <code>parse_log_entry()</code> or return <code>NULL</code> if a <code>malformed_log_entry_error</code> is signaled.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parse_log_file &lt;- function(file) &#123;</span><br><span class="line">  lines &lt;- readLines(file)</span><br><span class="line"></span><br><span class="line">  lapply(lines, function(text) &#123;</span><br><span class="line">    tryCatch(</span><br><span class="line">      malformed_log_entry = function(e) NULL,</span><br><span class="line">      parse_log_entry(text)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When <code>parse_log_entry()</code> returns normally, its value will be collected by the <code>lapply()</code>. But if <code>parse_log_entry</code> signals a <code>malformed_log_entry_error</code>, then the error clause will return <code>NULL</code>.</p>
<p>This version of <code>parse_log_file()</code> has one serious deficiency: itâs doing too much. As its name suggests, the job of <code>parse_log_file()</code> is to parse the file and produce a list of <code>log_entry</code> objects; if it canât, itâs not its place to decide what to do instead. What if you want to use <code>parse_log_file()</code> in an application that wants to tell the user that the log file is corrupted or one that wants to recover from malformed entries by fixing them up and re-parsing them? Or maybe an  application is fine with skipping them but only until a certain number of corrupted entries have been seen.</p>
<p>You could try to fix this problem by moving the <code>tryCatch()</code> to a higher-level function. However, then youâd have no way to implement the current policy of skipping individual entriesâwhen the error was signaled, the stack would be unwound all the way to the higher-level function, abandoning the parsing of the log file altogether. What you want is a way to provide the current recovery strategy without requiring that it always be used.</p>
<h3 id="Java-style-exception-handling"><a href="#Java-style-exception-handling" class="headerlink" title="Java style exception handling"></a>Java style exception handling</h3><p><code>tryCatch</code> is the nearest analog in R to Java- or Python-style exception handling. Where you might write this in Java:</p>
<pre><code>try {
  doStuff();
  doMoreStuff();
} catch (SomeException se) {
  recover(se);
}
</code></pre><p>or this in Python:</p>
<pre><code>try:
  doStuff()
  doMoreStuff()
except SomeException, se:
  recover(se)
</code></pre><p>in R youâd write this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tryCatch(&#123;</span><br><span class="line">  doStuff()</span><br><span class="line">  doMoreStuff()</span><br><span class="line">&#125;, some_exception = function(se) &#123;</span><br><span class="line">  recover(se)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Restarts"><a href="#Restarts" class="headerlink" title="Restarts"></a>Restarts</h2><p>The condition system lets you do this by splitting the error handling code into two parts. You place code that actually recovers from errors into <em>restarts</em>, and condition handlers can then handle a condition by invoking an appropriate restart. You can place restart code in mid- or low-level functions, such as <code>parse_log_file()</code> or <code>parse_log_entry()</code>, while moving the condition handlers into the upper levels of the application.</p>
<p>To change <code>parse_log_file()</code> so it establishes a restart instead of a condition handler, you can change the <code>tryCatch()</code> to a <code>withRestarts()</code>. The form of <code>withRestarts</code> is very similar to a <code>tryCatch()</code>. In general, a restart name should describe the action the restart takes. In <code>parse_log_file()</code>, you can call the restart <code>skip_log_entry</code> since thatâs what it does. The new version will look like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parse_log_file &lt;- function(file) &#123;</span><br><span class="line">  lines &lt;- readLines(file)</span><br><span class="line"></span><br><span class="line">  lapply(lines, function(text) &#123;</span><br><span class="line">    withRestarts(</span><br><span class="line">      parse_log_entry(text),</span><br><span class="line">      skip_log_entry = function(e) NULL</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you invoke this version of <code>parse_log_file()</code> on a log file containing corrupted entries, it wonât handle the error directly; youâll end up in the debugger. However, there among the various restarts listed by <code>findRestarts()</code> will be one called <code>skip_log_entry</code>, which, if you choose it, will cause <code>parse_log_file()</code> to continue on its way as before. To avoid ending up in the debugger, you can establish a condition handler that invokes the <code>skip_log_entry</code> restart automatically.</p>
<p>The advantage of establishing a restart rather than having <code>parse_log_file()</code> handle the error directly is it makes <code>parse_log_file()</code> usable in more situations. The higher-level code that invokes <code>parse_log_file()</code> doesnât have to invoke the <code>skip_log_entry</code> restart. It can choose to handle the error at a higher level. Or, as Iâll show in the next section, you can add restarts to <code>parse_log_entry()</code> to provide other recovery strategies, and then condition handlers can choose which strategy they want to use.</p>
<p>But before I can talk about that, you need to see how to set up a condition handler that will invoke the <code>skip_log_entry</code> restart. You can set up the handler anywhere in the chain of calls leading to <code>parse_log_file()</code>. This may be quite high up in your application, not necessarily in <code>parse_log_file()</code>âs direct caller. For instance, suppose the main entry point to your application is a function, <code>log_analyzer()</code>, that finds a bunch of logs and analyzes them with the function <code>analyze_log()</code>, which eventually leads to a call to <code>parse_log_file()</code>. Without any error handling, it might look like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_analyzer &lt;- function() &#123;</span><br><span class="line">  logs &lt;- find_all_logs()</span><br><span class="line">  lapply(logs, analyze_log)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The job of <code>analyze_log()</code> is to call, directly or indirectly, <code>parse_log_file()</code> and then do something with the list of log entries returned. An extremely simple version might look like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">analyze_log &lt;- function(log) &#123;</span><br><span class="line">  entries &lt;- parse_log_file(log)</span><br><span class="line">  lapply(entries, anaylze_entry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>where the function <code>analyze_entry()</code> is presumably responsible for extracting whatever information you care about from each log entry and stashing it away somewhere.</p>
<p>Assuming you always want to skip malformed log entries, you could change this function to establish a condition handler that invokes the <code>skip_log_entry</code> restart for you. However, you canât use <code>tryCatch()</code> to establish the condition handler because then the stack would be unwound to the function where the <code>tryCatch()</code> appears. Instead, you need to use the lower-level macro <code>withCallingHandlers()</code>. The basic form of <code>withCallingHandlers()</code> is as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">withCallingHandlers(</span><br><span class="line">  expr,</span><br><span class="line">  condition_1 = function() ...,</span><br><span class="line">  condition_2 = function() ....</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>An important difference between <code>tryCatch()</code> and <code>withCallingHandlers()</code> is that the handler function bound by <code>withCallingHandlers()</code> will be run without unwinding the stackâthe flow of control will still be in the call to <code>parse_log_entry()</code> when this function is called. A call to <code>invokeRestart()</code> will find and invoke the most recently bound restart with the given name. So you can add a handler to <code>log_analyzer()</code> that will invoke the <code>skip_log_entry</code> restart established in <code>parse_log_file()</code> like this:^5^</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log_analyzer &lt;- function() &#123;</span><br><span class="line">  logs &lt;- find_all_logs()</span><br><span class="line"></span><br><span class="line">  withCallingHandlers(</span><br><span class="line">    malformed_log_entry_error = function(e) invokeRestart(&quot;skip_log_entry&quot;),</span><br><span class="line">    lapply(logs, analyze_log)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this <code>withCallingHandlers()</code>, the handler function is an anonymous function that invokes the restart <code>skip_log_entry</code>. You could also define a named function that does the same thing and bind it instead. In fact, a common practice when defining a restart is to define a function, with the same name and taking a single argument, the condition, that invokes the eponymous restart. Such functions are called <em>restart functions</em>. You could define a restart function for <code>skip_log_entry</code> like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_log_entry &lt;- function() invokeRestart(&quot;skip_log_entry&quot;)</span><br></pre></td></tr></table></figure>
<p>Then you could change the definition of <code>log_analyzer()</code> to this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log_analyzer &lt;- function() &#123;</span><br><span class="line">  logs &lt;- find_all_logs()</span><br><span class="line"></span><br><span class="line">  withCallingHandlers(</span><br><span class="line">    malformed_log_entry_error = skip_log_entry,</span><br><span class="line">    lapply(logs, analyze_log)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As written, the <code>skip_log_entry</code> restart function assumes that a <code>skip_log_entry</code> restart has been established. If a <code>malformed_log_entry_error</code> is ever signaled by code called from <code>log_analyzer()</code> without a <code>skip_log_entry</code> having been established, the call to <code>invokeRestart()</code> will signal an error when it fails to find the <code>skip_log_entry</code> restart. If you want to allow for the possibility that a <code>malformed_log_entry_error</code> might be signaled from code that doesnât have a <code>skip_log_entry</code> restart established, you could change the <code>skip_log_entry</code> function to this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">skip_log_entry &lt;- function() &#123;</span><br><span class="line">  r &lt;- findRestart(&quot;skip_log_entry&quot;)</span><br><span class="line">  if (is.null(r)) return()</span><br><span class="line"></span><br><span class="line">  invokeRestart(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findRestart</code> looks for a restart with a given name and returns an object representing the restart if the restart is found and <code>NULL</code> if not. You can invoke the restart by passing the restart object to <code>invokeRestart()</code>. Thus, when <code>skip_log_entry</code> is bound with <code>withCallingHandlers()</code>, it will handle the condition by invoking the <code>skip_log_entry</code> restart if one is available and otherwise will return normally, giving other condition handlers, bound higher on the stack, a chance to handle the condition.</p>
<h2 id="Providing-Multiple-Restarts"><a href="#Providing-Multiple-Restarts" class="headerlink" title="Providing Multiple Restarts"></a>Providing Multiple Restarts</h2><p>Since restarts must be explicitly invoked to have any effect, you can define multiple restarts, each providing a different recovery strategy. As I mentioned earlier, not all log-parsing applications will necessarily want to skip malformed entries. Some applications might want <code>parse_log_file()</code> to include a special kind of object representing malformed entries in the list of <code>log-entry</code> objects; other applications may have some way to repair a malformed entry and may want a way to pass the fixed entry back to <code>parse_log_entry()</code>.</p>
<p>To allow more complex recovery protocols, restarts can take arbitrary arguments, which are passed in the call to <code>invokeRestart()</code>. You can provide support for both the recovery strategies I just mentioned by adding two restarts to <code>parse_log_entry()</code>, each of which takes a single argument. One simply returns the value itâs passed as the return value of <code>parse_log_entry()</code>, while the other tries to parse its argument in the place of the original log entry.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">parse_log_entry &lt;- function(text) &#123;</span><br><span class="line">  if (well_formed_log_entry(text)) &#123;</span><br><span class="line">    return(new_log_entry(text))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  withRestarts(</span><br><span class="line">    stop(malformed_log_entry_error(text)),</span><br><span class="line">    use_value = function(x) x,</span><br><span class="line">    reparse_entry = function(fixed_text) parse_log_entry(fixed_text)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The name <code>use_value()</code> is a standard name for this kind of restart. You can define a restart function for <code>use_value</code> similar to the <code>skip_log_entry</code> function you just defined.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_value &lt;- function(x) invokeRestart(&quot;use_value&quot;, x)</span><br></pre></td></tr></table></figure>
<p>So, if you wanted to change the policy on malformed entries to one that created an instance of <code>malformed_log_entry</code>, you could change <code>log_analyzer()</code> to this (assuming the existence of a <code>malformed_log_entry</code> constructor with a <code>text</code> parameter):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">log_analyzer &lt;- function() &#123;</span><br><span class="line">  logs &lt;- find_all_logs()</span><br><span class="line"></span><br><span class="line">  withCallingHandlers(</span><br><span class="line">    malformed_log_entry_error = function(text) &#123;</span><br><span class="line">      use_value(malformed_log_entry(text))</span><br><span class="line">    &#125;,</span><br><span class="line">    lapply(logs, analyze_log)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You could also have put these new restarts into <code>parse_log_file()</code> instead of <code>parse_log_entry()</code>. However, you generally want to put restarts in the lowest-level code possible. It wouldnât, though, be appropriate to move the <code>skip_log_entry</code> restart into <code>parse_log_entry()</code> since that would cause <code>parse_log_entry()</code> to sometimes return normally with <code>NULL</code>, the very thing you started out trying to avoid. And itâd be an equally bad idea to remove the <code>skip_log_entry</code> restart on the theory that the condition handler could get the same effect by invoking the <code>use-value</code> restart with <code>NULL</code> as the argument; that would require the condition handler to have intimate knowledge of how the <code>parse_log_file()</code> works. As it stands, the <code>skip_log_entry</code> is a properly abstracted part of the log-parsing API.</p>
<h2 id="Other-Uses-for-Conditions"><a href="#Other-Uses-for-Conditions" class="headerlink" title="Other Uses for Conditions"></a>Other Uses for Conditions</h2><p>While conditions are mainly used for error handling, they can be used for other purposesâyou can use conditions, condition handlers, and restarts to build a variety of protocols between low- and high-level code. The key to understanding the potential of conditions is to understand that merely signaling a condition has no effect on the flow of control.</p>
<p>The primitive signaling function <code>signalCondition()</code> implements the mechanism of searching for an applicable condition handler and invoking its handler function. The reason a handler can decline to handle a condition by returning normally is because the call to the handler function is just a regular function callâwhen the handler returns, control passes back to <code>signalCondition()</code>, which then looks for another, less recently bound handler that can handle the condition. If <code>signalCondition()</code> runs out of condition handlers before the condition is handled, it also returns normally.</p>
<p>The <code>stop()</code> function youâve been using calls <code>signalCondition()</code>. If the error is handled by a condition handler that transfers control via <code>tryCatch()</code> or by invoking a restart, then the call to <code>signalCondition()</code> never returns.</p>
<p>Another condition signaling function, <code>warning()</code>, provides an example of a different kind of protocol built on the condition system. Like <code>stop()</code>, <code>warnings()</code> calls <code>signalCondition()</code> to signal a condition. But if <code>signalCondition()</code> returns, <code>warning()</code> doesnât throw a top-level errorâit prints the condition to <code>stderr</code> and returns <code>NULL</code>, allowing its caller to proceed. <code>warning()</code> also establishes a restart, <code>muffle_warning()</code>, around the call to <code>signalCondition()</code> that can be used by a condition handler to make <code>warning()</code> return without printing anything. Of course, a condition signaled with <code>warning()</code> could also be handled in some other wayâa condition handler could âpromoteâ a warning to an error by handling it as if it were an error.</p>
<p>For instance, in the log-parsing application, if there were ways a log entry could be slightly malformed but still parsable, you could write <code>parse_log_entry()</code> to go ahead and parse the slightly defective entries but to signal a condition with <code>warning()</code> when it did. Then the larger application could choose to let the warning print, to muffle the warning, or to treat the warning like an error, recovering the same way it would from a <code>malformed_log_entry_error</code>.</p>
<p>You can also build your own protocols on <code>signalCondition()</code>âwhenever low-level code needs to communicate information back up the call stack to higher-level code, the condition mechanism is a reasonable mechanism to use. But for most purposes, one of the standard error or warning protocols should suffice.</p>
<p>Unfortunately, itâs the fate of error handling to always get short shrift in programming textsâproper error handling, or lack thereof, is often the biggest difference between illustrative code and hardened, production-quality code. The trick to writing the latter has more to do with adopting a particularly rigorous way of thinking about software than with the details of any particular programming language constructs. That said, if your goal is to write that kind of software, youâll find the R condition system is an excellent tool for writing robust code and one that fits quite nicely into Râs incremental development style.</p>
<h3 id="Writing-Robust-Software"><a href="#Writing-Robust-Software" class="headerlink" title="Writing Robust Software"></a>Writing Robust Software</h3><p>For information on writing robust software, you could do worse than to start by finding a copy of <em>Software Reliability</em> (John Wiley &amp; Sons, 1976) by Glenford J. Meyers. Bertrand Meyerâs writings on Design By Contract also provide a useful way of thinking about software correctness. For instance, see Chapters 11 and 12 of his <em>Object-Oriented Software Construction</em> (Prentice Hall, 1997). Keep in mind, however, that Bertrand Meyer is the inventor of Eiffel, a statically typed bondage and discipline language in the Algol/Ada school. While he has a lot of smart things to say about object orientation and software reliability, thereâs a fairly wide gap between his view of programming and The R Way. Finally, for an excellent overview of the larger issues surrounding building fault-tolerant systems, see Chapter 3 of the classic <em>Transaction Processing: Concepts and Techniques</em> (Morgan Kaufmann, 1993) by Jim Gray and Andreas Reuter.</p>
<p>^1^<em>Throws</em> or <em>raises</em> an exception in Java/Python terms</p>
<p>^2^<em>Catches</em> the exception in Java/Python terms</p>
<p>^3^In this respect, a condition is a lot like an exception in Java or Python except not all conditions represent an error or <em>exceptional</em> situation.</p>
<p>^5^The compiler may complain if the parameter is never used. You can silence that warning by adding a declaration <code>(declare (ignore c))</code> as the first expression in the <code>LAMBDA</code> body.</p>
<hr>
<p>The chapter concludes with a discussion of âdefensiveâ programming: ways to avoid common errors before they occur. In the short run youâll spend more time writing code, but in the long run youâll save time because error messages will be more informative and will let you narrow in on the root cause more quickly. The basic principle of defensive programming is to âfail fastâ, to raise an error as soon as something goes wrong. In R, this takes three particular forms: checking that inputs are correct, avoiding non-standard evaluation, and avoiding functions that can return different types of output.</p>
<h5 id="Quiz-5"><a href="#Quiz-5" class="headerlink" title="Quiz"></a>Quiz</h5><p>Want to skip this chapter? Go for it, if you can answer the questions below. Find the answers at the end of the chapter in <a href="#debugging-answers">answers</a>.</p>
<ol>
<li>How can you find out where an error occurred?</li>
<li>What does <code>browser()</code> do? List the five useful single-key commands   that you can use inside of a <code>browser()</code> environment.</li>
<li>What function do you use to ignore errors in block of code?</li>
<li>Why might you want to create an error with a custom S3 class?</li>
</ol>
<h5 id="Outline-5"><a href="#Outline-5" class="headerlink" title="Outline"></a>Outline</h5><ol>
<li><a href="#debugging-techniques">Debugging techniques</a> outlines a general   approach for finding and resolving bugs.</li>
<li><a href="#debugging-tools">Debugging tools</a> introduces you to the R functions   and RStudio features that help you locate exactly where an error   occurred.</li>
<li><a href="#condition-handling">Condition handling</a> shows you how you can catch   conditions (errors, warnings, and messages) in your own code. This allows   you to create code thatâs both more robust and more informative in the   presence of errors.</li>
<li><a href="#defensive-programming">Defensive programming</a> introduces you to   some important techniques for defensive programming, techniques that help   prevent bugs from occurring in the first place.</li>
</ol>
<h2 id="Debugging-techniques"><a href="#Debugging-techniques" class="headerlink" title="Debugging techniques"></a><a href="id=&quot;debugging-techniques&quot;">Debugging techniques</a></h2><blockquote>
<p>âFinding your bug is a process of confirming the many things<br>that you believe are true â until you find one which is not<br>true.â</p>
<p>âNorm Matloff</p>
</blockquote>
<p>Debugging code is challenging. Many bugs are subtle and hard to find. Indeed, if a bug was obvious, you probably wouldâve been able to avoid it in the first place. While itâs true that with a good technique, you can productively debug a problem with just <code>print()</code>, there are times when additional help would be welcome. In this section, weâll discuss some useful tools, which R and RStudio provide, and outline a general procedure for debugging.</p>
<p>While the procedure below is by no means foolproof, it will hopefully help you to organise your thoughts when debugging. There are four steps:</p>
<ol>
<li><p><strong>Realise that you have a bug</strong></p>
<p> If youâre reading this chapter, youâve probably already completed this step.    It is a surprisingly important one: you canât fix a bug until you know it    exists. This is one reason why automated test suites are important when<br> producing high-quality code. Unfortunately, automated testing is outside the    scope of this book, but you can read more about it at    <a href="http://r-pkgs.had.co.nz/tests.html" target="_blank" rel="external">http://r-pkgs.had.co.nz/tests.html</a>.</p>
</li>
<li><p><strong>Make it repeatable</strong></p>
<p> Once youâve determined you have a bug, you need to be able to reproduce it    on command. Without this, it becomes extremely difficult to isolate its    cause and to confirm that youâve successfully fixed it.</p>
<p> Generally, you will start with a big block of code that you know causes the    error and then slowly whittle it down to get to the smallest possible    snippet that still causes the error. Binary search is particularly useful    for this. To do a binary search, you repeatedly remove half of the code    until you find the bug. This is fast because, with each step, you reduce the    amount of code to look through by half.</p>
<p> If it takes a long time to generate the bug, itâs also worthwhile to figure    out how to generate it faster. The quicker you can do this, the quicker you    can figure out the cause.</p>
<p> As you work on creating a minimal example, youâll also discover similar    inputs that donât trigger the bug. Make note of them: they will be helpful    when diagnosing the cause of the bug.</p>
<p> If youâre using automated testing, this is also a good time to create an    automated test case. If your existing test coverage is low, take the    opportunity to add some nearby tests to ensure that existing good behaviour    is preserved. This reduces the chances of creating a new bug.</p>
</li>
<li><p><strong>Figure out where it is</strong></p>
<p> If youâre lucky, one of the tools in the following section will help you to    quickly identify the line of code thatâs causing the bug. Usually, however,    youâll have to think a bit more about the problem. Itâs a great idea to    adopt the scientific method. Generate hypotheses, design experiments to test    them, and record your results. This may seem like a lot of work, but a    systematic approach will end up saving you time. I often waste a lot of time    relying on my intuition to solve a bug (âoh, it must be an off-by-one error,    so Iâll just subtract 1 hereâ), when I would have been better off taking a    systematic approach.</p>
</li>
<li><p><strong>Fix it and test it</strong></p>
<p> Once youâve found the bug, you need to figure out how to fix it and to check    that the fix actually worked. Again, itâs very useful to have automated    tests in place. Not only does this help to ensure that youâve actually fixed    the bug, it also helps to ensure you havenât introduced any new bugs in the    process. In the absence of automated tests, make sure to carefully record    the correct output, and check against the inputs that previously failed.</p>
</li>
</ol>
<h2 id="Debugging-tools"><a href="#Debugging-tools" class="headerlink" title="Debugging tools"></a><a href="id=&quot;debugging-tools&quot;">Debugging tools</a></h2><p>To implement a strategy of debugging, youâll need tools. In this section, youâll learn about the tools provided by R and the RStudio IDE. RStudioâs integrated debugging support makes life easier by exposing existing R tools in a user friendly way. Iâll show you both the R and RStudio ways so that you can work with whatever environment you use. You may also want to refer to the official <a href="http://www.rstudio.com/ide/docs/debugging/overview" target="_blank" rel="external">RStudio debugging documentation</a> which always reflects the tools in the latest version of RStudio.</p>
<p>There are three key debugging tools:</p>
<ul>
<li>RStudioâs error inspector and <code>traceback()</code> which list the sequence of calls  that lead to the error.</li>
<li>RStudioâs âRerun with Debugâ tool and <code>options(error = browser)</code> which open  an interactive session where the error occurred.</li>
<li>RStudioâs breakpoints and <code>browser()</code> which open an interactive session at  an arbitrary location in the code.</li>
</ul>
<p>Iâll explain each tool in more detail below.</p>
<p>You shouldnât need to use these tools when writing new functions. If you find yourself using them frequently with new code, you may want to reconsider your approach. Instead of trying to write one big function all at once, work interactively on small pieces. If you start small, you can quickly identify why something doesnât work. But if you start large, you may end up struggling to identify the source of the problem.</p>
<h3 id="Determining-the-sequence-of-calls"><a href="#Determining-the-sequence-of-calls" class="headerlink" title="Determining the sequence of calls"></a>Determining the sequence of calls</h3><p>The first tool is the <strong>call stack</strong>, the sequence of calls that lead up to an error. Hereâs a simple example: you can see that <code>f()</code> calls <code>g()</code> calls <code>h()</code> calls <code>i()</code> which adds together a number and a string creating a error:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(a) g(a)</span><br><span class="line">g &lt;- function(b) h(b)</span><br><span class="line">h &lt;- function(c) i(c)</span><br><span class="line">i &lt;- function(d) &quot;a&quot; + d</span><br><span class="line">f(10)</span><br></pre></td></tr></table></figure>
<p>When we run this code in RStudio we see:</p>
<p><img src="screenshots/traceback-hidden.png" alt=""></p>
<p>Two options appear to the right of the error message: âShow Tracebackâ and âRerun with Debugâ.  If you click âShow tracebackâ you see:</p>
<p><img src="screenshots/traceback-shown.png" alt=""></p>
<p>If youâre not using RStudio, you can use <code>traceback()</code> to get the same information:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">traceback()</span><br><span class="line"># 4: i(c) at exceptions-example.R#3</span><br><span class="line"># 3: h(b) at exceptions-example.R#2</span><br><span class="line"># 2: g(a) at exceptions-example.R#1</span><br><span class="line"># 1: f(10)</span><br></pre></td></tr></table></figure>
<p>Read the call stack from bottom to top: the initial call is <code>f()</code>, which calls <code>g()</code>, then <code>h()</code>, then <code>i()</code>, which triggers the error. If youâre calling code that you <code>source()</code>d into R, the traceback will also display the location of the function, in the form <code>filename.r#linenumber</code>. These are clickable in RStudio, and will take you to the corresponding line of code in the editor.</p>
<p>Sometimes this is enough information to let you track down the error and fix it. However, itâs usually not. <code>traceback()</code> shows you where the error occurred, but not why. The next useful tool is the interactive debugger, which allows you to pause execution of a function and interactively explore its state.</p>
<h3 id="Browsing-on-error"><a href="#Browsing-on-error" class="headerlink" title="Browsing on error"></a>Browsing on error</h3><p>The easiest way to enter the interactive debugger is through RStudioâs âRerun with Debugâ tool. This reruns the command that created the error, pausing execution where the error occurred. Youâre now in an interactive state inside the function, and you can interact with any object defined there. Youâll see the corresponding code in the editor (with the statement that will be run next highlighted), objects in the current environment in the âEnvironmentâ pane, the call stack in a âTracebackâ pane, and you can run arbitrary R code in the console.</p>
<p>As well as any regular R function, there are a few special commands you can use in debug mode. You can access them either with the RStudio toolbar</p>
<p><img src="screenshots/debug-toolbar.png" alt=""></p>
<p>or with the keyboard:</p>
<ul>
<li>Next, <code>n</code>: executes the next step in the function. Be careful if you have a  variable named <code>n</code>; to print it youâll need to do <code>print(n)</code>.</li>
<li><p>Step into,</p>
<p>  <img src="screenshots/step-into.png" alt=""></p>
<p>  or <code>s</code>:  works like next, but if the next step is a function, it will step into that  function so you can work through each line.</p>
</li>
<li><p>Finish,</p>
<p>  <img src="screenshots/finish-loop.png" alt=""></p>
<p>  or <code>f</code>:  finishes execution of the current loop or function.</p>
</li>
<li><p>Continue, <code>c</code>: leaves interactive debugging and continues regular execution  of the function. This is useful if youâve fixed the bad state and want to  check that the function proceeds correctly.</p>
</li>
<li>Stop, <code>Q</code>: stops debugging, terminates the function, and returns to the global  workspace. Use this once youâve figured out where the problem is, and youâre  ready to fix it and reload the code.</li>
</ul>
<p>There are two other slightly less useful commands that arenât available in the toolbar:</p>
<ul>
<li>Enter: repeats the previous command. I find this too easy to activate  accidentally, so I turn it off using <code>options(browserNLdisabled = TRUE)</code>.</li>
<li><code>where</code>: prints stack trace of active calls (the interactive equivalent of  <code>traceback</code>).</li>
</ul>
<p>To enter this style of debugging outside of RStudio, you can use the <code>error</code> option which specifies a function to run when an error occurs. The function most similar to Rstudioâs debug is <code>browser()</code>: this will start an interactive console in the environment where the error occurred. Use <code>options(error = browser)</code> to turn it on, re-run the previous command, then use <code>options(error = NULL)</code> to return to the default error behaviour. You could automate this with the <code>browseOnce()</code> function as defined below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">browseOnce &lt;- function() &#123;</span><br><span class="line">  old &lt;- getOption(&quot;error&quot;)</span><br><span class="line">  function() &#123;</span><br><span class="line">    options(error = old)</span><br><span class="line">    browser()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">options(error = browseOnce())</span><br><span class="line"></span><br><span class="line">f &lt;- function() stop(&quot;!&quot;)</span><br><span class="line"># Enters browser</span><br><span class="line">f()</span><br><span class="line"># Runs normally</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>(Youâll learn more about functions that return functions in <a href="#functional-programming">Functional programming</a>.)</p>
<p>There are two other useful functions that you can use with the <code>error</code> option:</p>
<ul>
<li><code>recover</code> is a step up from <code>browser</code>, as it allows you to enter the  environment of any of the calls in the call stack. This is useful because  often the root cause of the error is a number of calls back.</li>
<li><p><code>dump.frames</code> is an equivalent to <code>recover</code> for non-interactive code. It  creates a <code>last.dump.rda</code> file in the current working directory. Then,  in a later interactive R session, you load that file, and use <code>debugger()</code>  to enter an interactive debugger with the same interface as <code>recover()</code>.  This allows interactive debugging of batch code.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># In batch R process ----</span><br><span class="line">dump_and_quit &lt;- function() &#123;</span><br><span class="line">  # Save debugging info to file last.dump.rda</span><br><span class="line">  dump.frames(to.file = TRUE)</span><br><span class="line">  # Quit R with error status</span><br><span class="line">  q(status = 1)</span><br><span class="line">&#125;</span><br><span class="line">options(error = dump_and_quit)</span><br><span class="line"></span><br><span class="line"># In a later interactive session ----</span><br><span class="line">load(&quot;last.dump.rda&quot;)</span><br><span class="line">debugger()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>To reset error behaviour to the default, use <code>options(error = NULL)</code>. Then errors will print a message and abort function execution.</p>
<h3 id="Browsing-arbitrary-code"><a href="#Browsing-arbitrary-code" class="headerlink" title="Browsing arbitrary code"></a>Browsing arbitrary code</h3><p>As well as entering an interactive console on error, you can enter it at an arbitrary code location by using either an Rstudio breakpoint or <code>browser()</code>. You can set a breakpoint in Rstudio by clicking to the left of the line number, or pressing <code>Shift + F9</code>. Equivalently, add <code>browser()</code> where you want execution to pause. Breakpoints behave similarly to <code>browser()</code> but they are easier to set (one click instead of nine key presses), and you donât run the risk of accidentally including a <code>browser()</code> statement in your source code. There are two small downsides to breakpoints:</p>
<ul>
<li>There are a few unusual situations in which breakpoints will not work:  read <a href="http://www.rstudio.com/ide/docs/debugging/breakpoint-troubleshooting" target="_blank" rel="external">breakpoint troubleshooting</a> for more details.</li>
<li>RStudio currently does not support conditional breakpoints, whereas you  can always put <code>browser()</code> inside an <code>if</code> statement.</li>
</ul>
<p>As well as adding <code>browser()</code> yourself, there are two other functions that will add it to code:</p>
<ul>
<li><code>debug()</code> inserts a browser statement in the first line of the specified  function. <code>undebug()</code> removes it. Alternatively, you can use <code>debugonce()</code>  to browse only on the next run.</li>
<li><code>utils::setBreakpoint()</code> works similarly, but instead of taking a function  name, it takes a file name and line number and finds the appropriate function  for you.</li>
</ul>
<p>These two functions are both special cases of <code>trace()</code>, which inserts arbitrary code at any position in an existing function. <code>trace()</code> is occasionally useful when youâre debugging code that you donât have the source for. To remove tracing from a function, use <code>untrace()</code>. You can only perform one trace per function, but that one trace can call multiple functions.</p>
<h3 id="The-call-stack-traceback-where-and-recover"><a href="#The-call-stack-traceback-where-and-recover" class="headerlink" title="The call stack: traceback(), where, and recover()"></a>The call stack: <code>traceback()</code>, <code>where</code>, and <code>recover()</code></h3><p>Unfortunately the call stacks printed by <code>traceback()</code>, <code>browser()</code> + <code>where</code>, and <code>recover()</code> are not consistent. The following table shows how the call stacks from a simple nested set of calls are displayed by the three tools.</p>
<p><code>traceback()</code>       <code>where</code>                    <code>recover()</code></p>
<hr>
<p><code>4: stop(&quot;Error&quot;)</code>  <code>where 1: stop(&quot;Error&quot;)</code>   <code>1: f()</code><br><code>3: h(x)</code>           <code>where 2: h(x)</code>            <code>2: g(x)</code><br><code>2: g(x)</code>           <code>where 3: g(x)</code>            <code>3: h(x)</code><br><code>1: f()</code>            <code>where 4: f()</code></p>
<p>Note that numbering is different between <code>traceback()</code> and <code>where</code>, and that <code>recover()</code> displays calls in the opposite order, and omits the call to <code>stop()</code>. RStudio displays calls in the same order as <code>traceback()</code> but omits the numbers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) g(x)</span><br><span class="line">g &lt;- function(x) h(x)</span><br><span class="line">h &lt;- function(x) stop(&quot;Error&quot;)</span><br><span class="line">f(); traceback()</span><br><span class="line">options(error = browser); f()</span><br><span class="line">options(error = recover); f()</span><br><span class="line">options(error = NULL)</span><br></pre></td></tr></table></figure>
<h3 id="Other-types-of-failure"><a href="#Other-types-of-failure" class="headerlink" title="Other types of failure"></a>Other types of failure</h3><p>There are other ways for a function to fail apart from throwing an error or returning an incorrect result.</p>
<ul>
<li>A function may generate an unexpected warning. The easiest way to track down  warnings is to convert them into errors with <code>options(warn = 2)</code> and use the  regular debugging tools. When you do this youâll see some extra calls  in the call stack, like <code>doWithOneRestart()</code>, <code>withOneRestart()</code>,  <code>withRestarts()</code>, and <code>.signalSimpleWarning()</code>. Ignore these: they are<br>internal functions used to turn warnings into errors.</li>
<li><p>A function may generate an unexpected message. Thereâs no built-in tool to  help solve this problem, but itâs possible to create one:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">message2error &lt;- function(code) &#123;</span><br><span class="line">  withCallingHandlers(code, message = function(e) stop(e))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f &lt;- function() g()</span><br><span class="line">g &lt;- function() message(&quot;Hi!&quot;)</span><br><span class="line">g()</span><br><span class="line"># Error in message(&quot;Hi!&quot;): Hi!</span><br><span class="line">message2error(g())</span><br><span class="line">traceback()</span><br><span class="line"># 10: stop(e) at #2</span><br><span class="line"># 9: (function (e) stop(e))(list(message = &quot;Hi!\n&quot;,</span><br><span class="line">#      call = message(&quot;Hi!&quot;)))</span><br><span class="line"># 8: signalCondition(cond)</span><br><span class="line"># 7: doWithOneRestart(return(expr), restart)</span><br><span class="line"># 6: withOneRestart(expr, restarts[[1L]])</span><br><span class="line"># 5: withRestarts()</span><br><span class="line"># 4: message(&quot;Hi!&quot;) at #1</span><br><span class="line"># 3: g()</span><br><span class="line"># 2: withCallingHandlers(code, message = function(e) stop(e))</span><br><span class="line">#      at #2</span><br><span class="line"># 1: message2error(g())</span><br></pre></td></tr></table></figure>
<p>  As with warnings, youâll need to ignore some of the calls on the traceback    (i.e., the first two and the last seven).</p>
</li>
<li>A function might never return. This is particularly hard to debug  automatically, but sometimes terminating the function and looking at the  call stack is informative. Otherwise, use the basic debugging strategies  described above.</li>
<li><p>The worst scenario is that your code might crash R completely, leaving you  with no way to interactively debug your code. This indicates a bug in the  underlying C code. This is hard to debug. Sometimes an interactive debugger,  like <code>gdb</code>, can be useful, but describing how to use it is beyond the  scope of this book.</p>
<p>  If the crash is caused by base R code, post a reproducible example to R-help.<br>  If itâs in a package, contact the package maintainer. If itâs your own C or    C++ code, youâll need to use numerous <code>print()</code> statements to narrow down    the location of the bug, and then youâll need to use many more print    statements to figure out which data structure doesnât have the properties    that you expect.</p>
</li>
</ul>
<h2 id="Condition-handling"><a href="#Condition-handling" class="headerlink" title="Condition handling"></a><a href="id=&quot;condition-handling&quot;">Condition handling</a></h2><p>Unexpected errors require interactive debugging to figure out what went wrong. Some errors, however, are expected, and you want to handle them automatically. In R, expected errors crop up most frequently when youâre fitting many models to different datasets, such as bootstrap replicates. Sometimes the model might fail to fit and throw an error, but you donât want to stop everything. Instead, you want to fit as many models as possible and then perform diagnostics after the fact.</p>
<p>In R, there are three tools for handling conditions (including errors) programmatically:</p>
<ul>
<li><code>try()</code> gives you the ability to continue execution even when an error occurs.</li>
<li><code>tryCatch()</code> lets you specify <strong>handler</strong> functions that control what  happens when a condition is signalled.</li>
<li><code>withCallingHandlers()</code> is a variant of <code>tryCatch()</code> that runs its handlers  in a different context. Itâs rarely needed, but is useful to be aware of.</li>
</ul>
<p>The following sections describe these tools in more detail.</p>
<h3 id="Ignore-errors-with-try"><a href="#Ignore-errors-with-try" class="headerlink" title="Ignore errors with try"></a><a href="id=&quot;try&quot;">Ignore errors with try</a></h3><p><code>try()</code> allows execution to continue even after an error has occurred. For example, normally if you run a function that throws an error, it terminates immediately and doesnât return a value:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f1 &lt;- function(x) &#123;</span><br><span class="line">  log(x)</span><br><span class="line">  10</span><br><span class="line">&#125;</span><br><span class="line">f1(&quot;x&quot;)</span><br></pre></td></tr></table></figure>
<p>However, if you wrap the statement that creates the error in <code>try()</code>, the error message will be printed but execution will continue:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f2 &lt;- function(x) &#123;</span><br><span class="line">  try(log(x))</span><br><span class="line">  10</span><br><span class="line">&#125;</span><br><span class="line">f2(&quot;a&quot;)</span><br><span class="line">#&gt; Error in log(x) : non-numeric argument to mathematical function</span><br><span class="line">#&gt; [1] 10</span><br></pre></td></tr></table></figure>
<p>You can suppress the message with <code>try(..., silent = TRUE)</code>.</p>
<p>To pass larger blocks of code to <code>try()</code>, wrap them in <code>{}</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try(&#123;</span><br><span class="line">  a &lt;- 1</span><br><span class="line">  b &lt;- &quot;x&quot;</span><br><span class="line">  a + b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>You can also capture the output of the <code>try()</code> function. If successful, it will be the last result evaluated in the block (just like a function). If unsuccessful it will be an (invisible) object of class âtry-errorâ:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">success &lt;- try(1 + 2)</span><br><span class="line">failure &lt;- try(&quot;a&quot; + &quot;b&quot;)</span><br><span class="line">class(success)</span><br><span class="line">class(failure)</span><br></pre></td></tr></table></figure>
<p><code>try()</code> is particularly useful when youâre applying a function to multiple elements in a list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elements &lt;- list(1:10, c(-1, 10), c(TRUE, FALSE), letters)</span><br><span class="line">results &lt;- lapply(elements, log)</span><br><span class="line">results &lt;- lapply(elements, function(x) try(log(x)))</span><br></pre></td></tr></table></figure>
<p>There isnât a built-in function to test for the try-error class, so weâll define one. Then you can easily find the locations of errors with <code>sapply()</code> (as discussed in <a href="#functionals">Functionals</a>), and extract the successes or look at the inputs that lead to failures.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">is.error &lt;- function(x) inherits(x, &quot;try-error&quot;)</span><br><span class="line">succeeded &lt;- !vapply(results, is.error, logical(1))</span><br><span class="line"></span><br><span class="line"># look at successful results</span><br><span class="line">str(results[succeeded])</span><br><span class="line"></span><br><span class="line"># look at inputs that failed</span><br><span class="line">str(elements[!succeeded])</span><br></pre></td></tr></table></figure>
<p>Another useful <code>try()</code> idiom is using a default value if an expression fails. Simply assign the default value outside the try block, and then run the risky code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default &lt;- NULL</span><br><span class="line">try(default &lt;- read.csv(&quot;possibly-bad-input.csv&quot;), silent = TRUE)</span><br></pre></td></tr></table></figure>
<p>There is also <code>plyr::failwith()</code>, which makes this strategy even easier to implement. See <a href="#output-fos">Function Operators</a> for more details.</p>
<h3 id="Handle-conditions-with-tryCatch"><a href="#Handle-conditions-with-tryCatch" class="headerlink" title="Handle conditions with tryCatch()"></a>Handle conditions with <code>tryCatch()</code></h3><p><code>tryCatch()</code> is a general tool for handling conditions: in addition to errors, you can take different actions for warnings, messages, and interrupts.  Youâve seen errors (made by <code>stop()</code>), warnings (<code>warning()</code>) and messages (<code>message()</code>) before, but interrupts are new. They canât be generated directly by the programmer, but are raised when the user attempts to terminate execution by pressing Ctrl + Break, Escape, or Ctrl + C (depending on the platform).</p>
<p>With <code>tryCatch()</code> you map conditions to <strong>handlers</strong>, named functions that are called with the condition as an input. If a condition is signalled, <code>tryCatch()</code> will call the first handler whose name matches one of the classes of the condition. The only useful built-in names are <code>error</code>, <code>warning</code>, <code>message</code>, <code>interrupt</code>, and the catch-all <code>condition</code>. A handler function can do anything, but typically it will either return a value or create a more informative error message. For example, the <code>show_condition()</code> function below sets up handlers that return the type of condition signalled:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">show_condition &lt;- function(code) &#123;</span><br><span class="line">  tryCatch(code,</span><br><span class="line">    error = function(c) &quot;error&quot;,</span><br><span class="line">    warning = function(c) &quot;warning&quot;,</span><br><span class="line">    message = function(c) &quot;message&quot;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">show_condition(stop(&quot;!&quot;))</span><br><span class="line">show_condition(warning(&quot;?!&quot;))</span><br><span class="line">show_condition(message(&quot;?&quot;))</span><br><span class="line"></span><br><span class="line"># If no condition is captured, tryCatch returns the</span><br><span class="line"># value of the input</span><br><span class="line">show_condition(10)</span><br></pre></td></tr></table></figure>
<p>You can use <code>tryCatch()</code> to implement <code>try()</code>. A simple implementation is shown below. <code>base::try()</code> is more complicated in order to make the error message look more like what youâd see if <code>tryCatch()</code> wasnât used. Note the use of <code>conditionMessage()</code> to extract the message associated with the original error.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try2 &lt;- function(code, silent = FALSE) &#123;</span><br><span class="line">  tryCatch(code, error = function(c) &#123;</span><br><span class="line">    msg &lt;- conditionMessage(c)</span><br><span class="line">    if (!silent) message(c)</span><br><span class="line">    invisible(structure(msg, class = &quot;try-error&quot;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try2(1)</span><br><span class="line">try2(stop(&quot;Hi&quot;))</span><br><span class="line">try2(stop(&quot;Hi&quot;), silent = TRUE)</span><br></pre></td></tr></table></figure>
<p>As well as returning default values when a condition is signalled, handlers can be used to make more informative error messages. For example, by modifying the message stored in the error condition object, the following function wraps <code>read.csv()</code> to add the file name to any errors:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">read.csv2 &lt;- function(file, ...) &#123;</span><br><span class="line">  tryCatch(read.csv(file, ...), error = function(c) &#123;</span><br><span class="line">    c$message &lt;- paste0(c$message, &quot; (in &quot;, file, &quot;)&quot;)</span><br><span class="line">    stop(c)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">read.csv(&quot;code/dummy.csv&quot;)</span><br><span class="line">read.csv2(&quot;code/dummy.csv&quot;)</span><br></pre></td></tr></table></figure>
<p>Catching interrupts can be useful if you want to take special action when the user tries to abort running code. But be careful, itâs easy to create a loop that you can never escape (unless you kill R)!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Don&apos;t let the user interrupt the code</span><br><span class="line">i &lt;- 1</span><br><span class="line">while(i &lt; 3) &#123;</span><br><span class="line">  tryCatch(&#123;</span><br><span class="line">    Sys.sleep(0.5)</span><br><span class="line">    message(&quot;Try to escape&quot;)</span><br><span class="line">  &#125;, interrupt = function(x) &#123;</span><br><span class="line">    message(&quot;Try again!&quot;)</span><br><span class="line">    i &lt;&lt;- i + 1</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tryCatch()</code> has one other argument: <code>finally</code>. It specifies a block of code (not a function) to run regardless of whether the initial expression succeeds or fails. This can be useful for clean up (e.g., deleting files, closing connections). This is functionally equivalent to using <code>on.exit()</code> but it can wrap smaller chunks of code than an entire function.</p>
<h3 id="withCallingHandlers"><a href="#withCallingHandlers" class="headerlink" title="withCallingHandlers()"></a><code>withCallingHandlers()</code></h3><p>An alternative to <code>tryCatch()</code> is <code>withCallingHandlers()</code>. There are two main differences between these functions:</p>
<ul>
<li><p>The return value of <code>tryCatch()</code> handlers is returned by <code>tryCatch()</code>,  whereas the return value of <code>withCallingHandlers()</code> handlers is ignored:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function() stop(&quot;!&quot;)</span><br><span class="line">tryCatch(f(), error = function(e) 1)</span><br><span class="line">withCallingHandlers(f(), error = function(e) 1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>The handlers in <code>withCallingHandlers()</code> are called in the context of the  call that generated the condition whereas the handlers in <code>tryCatch()</code> are  called in the context of <code>tryCatch()</code>. This is shown here with <code>sys.calls()</code>,  which is the run-time equivalent of <code>traceback()</code> â it lists all calls  leading to the current function.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function() g()</span><br><span class="line">g &lt;- function() h()</span><br><span class="line">h &lt;- function() stop(&quot;!&quot;)</span><br><span class="line"></span><br><span class="line">tryCatch(f(), error = function(e) print(sys.calls()))</span><br><span class="line"># [[1]] tryCatch(f(), error = function(e) print(sys.calls()))</span><br><span class="line"># [[2]] tryCatchList(expr, classes, parentenv, handlers)</span><br><span class="line"># [[3]] tryCatchOne(expr, names, parentenv, handlers[[1L]])</span><br><span class="line"># [[4]] value[[3L]](cond)</span><br><span class="line"></span><br><span class="line">withCallingHandlers(f(), error = function(e) print(sys.calls()))</span><br><span class="line"># [[1]] withCallingHandlers(f(),</span><br><span class="line">#    error = function(e) print(sys.calls()))</span><br><span class="line"># [[2]] f()</span><br><span class="line"># [[3]] g()</span><br><span class="line"># [[4]] h()</span><br><span class="line"># [[5]] stop(&quot;!&quot;)</span><br><span class="line"># [[6]] .handleSimpleError(</span><br><span class="line">#    function (e) print(sys.calls()), &quot;!&quot;, quote(h()))</span><br><span class="line"># [[7]] h(simpleError(msg, call))</span><br></pre></td></tr></table></figure>
<p>  This also affects the order in which <code>on.exit()</code> is called.</p>
</li>
</ul>
<p>These subtle differences are rarely useful, except when youâre trying to capture exactly what went wrong and pass it on to another function. For most purposes, you should never need to use <code>withCallingHandlers()</code>.</p>
<h3 id="Custom-signal-classes"><a href="#Custom-signal-classes" class="headerlink" title="Custom signal classes"></a>Custom signal classes</h3><p>One of the challenges of error handling in R is that most functions just call <code>stop()</code> with a string. That means if you want to figure out if a particular error occurred, you have to look at the text of the error message. This is error prone, not only because the text of the error might change over time, but also because many error messages are translated, so the message might be completely different to what you expect.</p>
<p>R has a little known and little used feature to solve this problem. Conditions are S3 classes, so you can define your own classes if you want to distinguish different types of error. Each condition signalling function, <code>stop()</code>, <code>warning()</code>, and <code>message()</code>, can be given either a list of strings, or a custom S3 condition object. Custom condition objects are not used very often, but are very useful because they make it possible for the user to respond to different errors in different ways. For example, âexpectedâ errors (like a model failing to converge for some input datasets) can be silently ignored, while unexpected errors (like no disk space available) can be propagated to the user.</p>
<p>R doesnât come with a built-in constructor function for conditions, but we can easily add one. Conditions must contain <code>message</code> and <code>call</code> components, and may contain other useful components. When creating a new condition, it should always inherit from <code>condition</code> and one of <code>error</code>, <code>warning</code>, or <code>message</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">condition &lt;- function(subclass, message, call = sys.call(-1), ...) &#123;</span><br><span class="line">  structure(</span><br><span class="line">    class = c(subclass, &quot;condition&quot;),</span><br><span class="line">    list(message = message, call = call),</span><br><span class="line">    ...</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">is.condition &lt;- function(x) inherits(x, &quot;condition&quot;)</span><br></pre></td></tr></table></figure>
<p>You can signal an arbitrary condition with <code>signalCondition()</code>, but nothing will happen unless youâve instantiated a custom signal handler (with <code>tryCatch()</code> or <code>withCallingHandlers()</code>). Instead, use <code>stop()</code>, <code>warning()</code>, or <code>message()</code> as appropriate to trigger the usual handling. R wonât complain if the class of your condition doesnât match the function, but you should avoid this in real code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c &lt;- condition(c(&quot;my_error&quot;, &quot;error&quot;), &quot;This is an error&quot;)</span><br><span class="line">signalCondition(c)</span><br><span class="line"># NULL</span><br><span class="line">stop(c)</span><br><span class="line"># Error: This is an error</span><br><span class="line">warning(c)</span><br><span class="line"># Warning message: This is an error</span><br><span class="line">message(c)</span><br><span class="line"># This is an error</span><br></pre></td></tr></table></figure>
<p>You can then use <code>tryCatch()</code> to take different actions for different types of errors. In this example we make a convenient <code>custom_stop()</code> function that allows us to signal error conditions with arbitrary classes. In a real application, it would be better to have individual S3 constructor functions that you could document, describing the error classes in more detail.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">custom_stop &lt;- function(subclass, message, call = sys.call(-1),</span><br><span class="line">                        ...) &#123;</span><br><span class="line">  c &lt;- condition(c(subclass, &quot;error&quot;), message, call = call, ...)</span><br><span class="line">  stop(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_log &lt;- function(x) &#123;</span><br><span class="line">  if (!is.numeric(x))</span><br><span class="line">    custom_stop(&quot;invalid_class&quot;, &quot;my_log() needs numeric input&quot;)</span><br><span class="line">  if (any(x &lt; 0))</span><br><span class="line">    custom_stop(&quot;invalid_value&quot;, &quot;my_log() needs positive inputs&quot;)</span><br><span class="line"></span><br><span class="line">  log(x)</span><br><span class="line">&#125;</span><br><span class="line">tryCatch(</span><br><span class="line">  my_log(&quot;a&quot;),</span><br><span class="line">  invalid_class = function(c) &quot;class&quot;,</span><br><span class="line">  invalid_value = function(c) &quot;value&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Note that when using <code>tryCatch()</code> with multiple handlers and custom classes, the first handler to match any class in the signalâs class hierarchy is called, not the best match. For this reason, you need to make sure to put the most specific handlers first:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tryCatch(customStop(&quot;my_error&quot;, &quot;!&quot;),</span><br><span class="line">  error = function(c) &quot;error&quot;,</span><br><span class="line">  my_error = function(c) &quot;my_error&quot;</span><br><span class="line">)</span><br><span class="line">tryCatch(custom_stop(&quot;my_error&quot;, &quot;!&quot;),</span><br><span class="line">  my_error = function(c) &quot;my_error&quot;,</span><br><span class="line">  error = function(c) &quot;error&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-19"><a href="#Exercises-19" class="headerlink" title="Exercises"></a>Exercises</h3><ul>
<li><p>Compare the following two implementations of <code>message2error()</code>. What is the  main advantage of <code>withCallingHandlers()</code> in this scenario? (Hint: look  carefully at the traceback.)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message2error &lt;- function(code) &#123;</span><br><span class="line">  withCallingHandlers(code, message = function(e) stop(e))</span><br><span class="line">&#125;</span><br><span class="line">message2error &lt;- function(code) &#123;</span><br><span class="line">  tryCatch(code, message = function(e) stop(e))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Defensive-programming"><a href="#Defensive-programming" class="headerlink" title="Defensive programming"></a><a href="id=&quot;defensive-programming&quot;">Defensive programming</a></h2><p>Defensive programming is the art of making code fail in a well-defined manner even when something unexpected occurs. A key principle of defensive programming is to âfail fastâ: as soon as something wrong is discovered, signal an error. This is more work for the author of the function (you!), but it makes debugging easier for users because they get errors earlier rather than later, after unexpected input has passed through several functions.</p>
<p>In R, the âfail fastâ principle is implemented in three ways:</p>
<ul>
<li>Be strict about what you accept. For example, if your function is not  vectorised in its inputs, but uses functions that are, make sure to check  that the inputs are scalars. You can use <code>stopifnot()</code>, the  <a href="https://github.com/hadley/assertthat" target="_blank" rel="external">assertthat</a> package, or simple <code>if</code>  statements and <code>stop()</code>.</li>
<li>Avoid functions that use non-standard evaluation, like <code>subset</code>, <code>transform</code>,  and <code>with</code>. These functions save time when used interactively, but because  they make assumptions to reduce typing, when they fail, they often fail with  uninformative error messages. You can learn more about non-standard evaluation  in <a href="#nse">non-standard evaluation</a>.</li>
<li>Avoid functions that return different types of output depending on their  input. The two biggest offenders are <code>[</code> and <code>sapply()</code>. Whenever  subsetting a data frame in a function, you should always use <code>drop = FALSE</code>,  otherwise you will accidentally convert 1-column data frames into vectors.  Similarly, never use <code>sapply()</code> inside a function: always use the stricter  <code>vapply()</code> which will throw an error if the inputs are incorrect types and  return the correct type of output even for zero-length inputs.</li>
</ul>
<p>There is a tension between interactive analysis and programming. When youâre working interactively, you want R to do what you mean. If it guesses wrong, you want to discover that right away so you can fix it. When youâre programming, you want functions that signal errors if anything is even slightly wrong or underspecified. Keep this tension in mind when writing functions. If youâre writing functions to facilitate interactive data analysis, feel free to guess what the analyst wants and recover from minor misspecifications automatically. If youâre writing functions for programming, be strict. Never try to guess what the caller wants.</p>
<h3 id="Exercises-20"><a href="#Exercises-20" class="headerlink" title="Exercises"></a>Exercises</h3><ul>
<li><p>The goal of the <code>col_means()</code> function defined below is to compute the means  of all numeric columns in a data frame.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">col_means &lt;- function(df) &#123;</span><br><span class="line">  numeric &lt;- sapply(df, is.numeric)</span><br><span class="line">  numeric_cols &lt;- df[, numeric]</span><br><span class="line"></span><br><span class="line">  data.frame(lapply(numeric_cols, mean))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  However, the function is not robust to unusual inputs. Look at    the following results, decide which ones are incorrect, and modify    <code>col_means()</code> to be more robust. (Hint: there are two function calls    in <code>col_means()</code> that are particularly prone to problems.)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">col_means(mtcars)</span><br><span class="line">col_means(mtcars[, 0])</span><br><span class="line">col_means(mtcars[0, ])</span><br><span class="line">col_means(mtcars[, &quot;mpg&quot;, drop = F])</span><br><span class="line">col_means(1:10)</span><br><span class="line">col_means(as.matrix(mtcars))</span><br><span class="line">col_means(as.list(mtcars))</span><br><span class="line"></span><br><span class="line">mtcars2 &lt;- mtcars</span><br><span class="line">mtcars2[-1] &lt;- lapply(mtcars2[-1], as.character)</span><br><span class="line">col_means(mtcars2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>The following function âlagsâ a vector, returning a version of <code>x</code> that is <code>n</code>  values behind the original. Improve the function so that it (1) returns a  useful error message if <code>n</code> is not a vector, and (2) has reasonable behaviour  when <code>n</code> is 0 or longer than <code>x</code>.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lag &lt;- function(x, n = 1L) &#123;</span><br><span class="line">  xlen &lt;- length(x)</span><br><span class="line">  c(rep(NA, n), x[seq_len(xlen - n)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Quiz-answers-3"><a href="#Quiz-answers-3" class="headerlink" title="Quiz answers"></a><a href="id=&quot;debugging-answers&quot;">Quiz answers</a></h2><ol>
<li>The most useful tool to determine where a error occurred is <code>traceback()</code>.   Or use RStudio, which displays it automatically where an error occurs.</li>
<li><code>browser()</code> pauses execution at the specified line and allows you to   enter an interactive environment. In that environment, there are five   useful commands: <code>n</code>, execute the next command; <code>s</code>, step into the   next function; <code>f</code>, finish the current loop or function; <code>c</code>, continue   execution normally; <code>Q</code>, stop the function and return to the console.</li>
<li>You could use <code>try()</code> or <code>tryCatch()</code>.</li>
<li>Because you can then capture specific types of error with <code>tryCatch()</code>,   rather than relying on the comparison of error strings, which is risky,   especially when messages are translated.</li>
</ol>
<hr>
<h1 id="Functional-programming"><a href="#Functional-programming" class="headerlink" title="Functional programming"></a>Functional programming</h1><p>R, at its heart, is a functional programming (FP) language. This means that it provides many tools for the creation and manipulation of functions. In particular, R has whatâs known as first class functions. You can do anything with functions that you can do with vectors: you can assign them to variables, store them in lists, pass them as arguments to other functions, create them inside functions, and even return them as the result of a function.</p>
<p>The chapter starts by showing a motivating example, removing redundancy and duplication in code used to clean and summarise data. Then youâll learn about the three building blocks of functional programming: anonymous functions, closures (functions written by functions), and lists of functions. These pieces are twined together in the conclusion which shows how to build a suite of tools for numerical integration, starting from very simple primitives. This is a recurring theme in FP: start with small, easy-to-understand building blocks, combine them into more complex structures, and apply them with confidence.</p>
<p>The discussion of functional programming continues in the following two chapters: <a href="#functionals">functionals</a> explores functions that take functions as arguments and return vectors as output, and <a href="#function-operators">function operators</a> explores functions that take functions as input and return them as output.</p>
<h5 id="Outline-6"><a href="#Outline-6" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#fp-motivation">Motivation</a> motivates functional programming using a  common problem: cleaning and summarising data before serious analysis.</li>
<li><a href="#anonymous-functions">Anonymous functions</a> shows you a side of functions  that you might not have known about: you can use functions without  giving them a name.</li>
<li><a href="#closures">Closures</a> introduces the closure, a function written by another  function. A closure can access its own arguments, and variables defined in  its parent.</li>
<li><a href="#lists-of-functions">Lists of functions</a> shows how to put functions in a  list, and explains why you might care.</li>
<li><a href="#numerical-integration">Numerical integration</a> concludes the chapter  with a case study that uses anonymous functions, closures and lists of  functions to build a flexible toolkit for numerical integration.</li>
</ul>
<h5 id="Prequisites"><a href="#Prequisites" class="headerlink" title="Prequisites"></a>Prequisites</h5><p>You should be familiar with the basic rules of lexical scoping, as described in <a href="#lexical-scoping">lexical scoping</a>. Make sure youâve installed the pryr package with <code>install.packages(&quot;pryr&quot;)</code></p>
<!--
#### Other languages

While FP techniques form the core of languages like Haskell, OCaml and F#, those techniques can also be found in other languages. They are well supported in multi-paradigm systems like Lisp, Scheme, Clojure and Scala. Also, while they tend not to be the dominant technique used by programmers, they can be used in modern scripting languages like Python, Ruby and JavaScript. In contrast, C, Java and C# provide few functional tools, and while it's possible to do FP in those languages, it tends to be an awkward fit. In sum, if you Google for it you're likely to find a tutorial on functional programming in any language. But doing so can often be syntactically awkward or used so rarely that other programmers won't understand your code.

Recently FP has experienced a surge in interest because it provides a complementary set of techniques to object oriented programming, the dominant style for the last several decades. Since FP functions tend to not modify their inputs, they make for programs that are easier to reason about using only local information, and are often easier to parallelise. The traditional weaknesses of FP languages, poorer performance and sometimes unpredictable memory usage, have been largely eliminated in recent years.
-->
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>Imagine youâve loaded a data file, like the one below, that uses $-99$ to represent missing values. You want to replace all the $-99$s with <code>NA</code>s.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Generate a sample dataset</span><br><span class="line">set.seed(1014)</span><br><span class="line">df &lt;- data.frame(replicate(6, sample(c(1:10, -99), 6, rep = TRUE)))</span><br><span class="line">names(df) &lt;- letters[1:6]</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p>When you first started writing R code, you might have solved the problem with copy-and-paste:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df$a[df$a == -99] &lt;- NA</span><br><span class="line">df$b[df$b == -99] &lt;- NA</span><br><span class="line">df$c[df$c == -98] &lt;- NA</span><br><span class="line">df$d[df$d == -99] &lt;- NA</span><br><span class="line">df$e[df$e == -99] &lt;- NA</span><br><span class="line">df$f[df$g == -99] &lt;- NA</span><br></pre></td></tr></table></figure>
<p>One problem with copy-and-paste is that itâs easy to make mistakes. Can you spot the two in the block above? These mistakes are inconsistencies that arose because we didnât have an authorative description of the desired action (replace $-99$ with <code>NA</code>). Duplicating an action makes bugs more likely and makes it harder to change code. For example, if the code for a missing value changes from $-99$ to 9999, youâd need to make the change in multiple places.</p>
<p>To prevent bugs and to make more flexible code, adopt the âdo not repeat yourselfâ, or DRY, principle. Popularised by the <a href="http://pragprog.com/about" target="_blank" rel="external">âpragmatic programmersâ</a>, Dave Thomas and Andy Hunt, this principle states: âevery piece of knowledge must have a single, unambiguous, authoritative representation within a systemâ. FP tools are valuable because they provide tools to reduce duplication.</p>
<p>We can start applying FP ideas by writing a function that fixes the missing values in a single vector:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fix_missing &lt;- function(x) &#123;</span><br><span class="line">  x[x == -99] &lt;- NA</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br><span class="line">df$a &lt;- fix_missing(df$a)</span><br><span class="line">df$b &lt;- fix_missing(df$b)</span><br><span class="line">df$c &lt;- fix_missing(df$c)</span><br><span class="line">df$d &lt;- fix_missing(df$d)</span><br><span class="line">df$e &lt;- fix_missing(df$e)</span><br><span class="line">df$f &lt;- fix_missing(df$e)</span><br></pre></td></tr></table></figure>
<p>This reduces the scope of possible mistakes, but it doesnât eliminate them: you can no longer accidentally type -98 instead of -99, but you can still mess up the name of variable. The next step is to remove this possible source of error by combining two functions. One function, <code>fix_missing()</code>, knows how to fix a single vector; the other, <code>lapply()</code>, knows how to do something to each column in a data frame.</p>
<p><code>lapply()</code> takes three inputs: <code>x</code>, a list; <code>f</code>, a function; and <code>...</code>, other arguments to pass to <code>f()</code>. It applies the function to each element of the list and returns a new list. <code>lapply(x, f, ...)</code> is equivalent to the following for loop:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out &lt;- vector(&quot;list&quot;, length(x))</span><br><span class="line">for (i in seq_along(x)) &#123;</span><br><span class="line">  out[[i]] &lt;- f(x[[i]], ...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The real <code>lapply()</code> is rather more complicated since itâs implemented in C for efficiency, but the essence of the algorithm is the same. <code>lapply()</code> is called a <strong>functional</strong>, because it takes a function as an argument. Functionals are an important part of functional programming. Youâll learn more about them in <a href="#functionals">functionals</a>.</p>
<p>We can apply <code>lapply()</code> to this problem because data frames are lists. We just need a neat little trick to make sure we get back a data frame, not a list. Instead of assigning the results of <code>lapply()</code> to <code>df</code>, weâll assign them to <code>df[]</code>. Râs usual rules ensure that we get a data frame, not a list. (If this comes as a surprise, you might want to read <a href="#subassignment">subsetting and assignment</a>.) Putting these pieces together gives us:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fix_missing &lt;- function(x) &#123;</span><br><span class="line">  x[x == -99] &lt;- NA</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br><span class="line">df[] &lt;- lapply(df, fix_missing)</span><br></pre></td></tr></table></figure>
<p>This code has five advantages over copy and paste:</p>
<ul>
<li>Itâs more compact.</li>
<li>If the code for a missing value changes, it only needs to be updated in  one place.</li>
<li>It works for any number of columns. There is no way to accidentally miss a  column.</li>
<li>There is no way to accidentally treat one column differently than another.</li>
<li><p>It is easy to generalise this technique to a subset of columns:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[1:5] &lt;- lapply(df[1:5], fix_missing)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>The key idea is function composition. Take two simple functions, one which does something to every column and one which fixes missing values, and combine them to fix missing values in every column. Writing simple functions that can be understood in isolation and then composed is a powerful technique.</p>
<p>What if different columns used different codes for missing values? You might be tempted to copy-and-paste:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fix_missing_99 &lt;- function(x) &#123;</span><br><span class="line">  x[x == -99] &lt;- NA</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br><span class="line">fix_missing_999 &lt;- function(x) &#123;</span><br><span class="line">  x[x == -999] &lt;- NA</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br><span class="line">fix_missing_9999 &lt;- function(x) &#123;</span><br><span class="line">  x[x == -999] &lt;- NA</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As before, itâs easy to create bugs. Instead we could use closures, functions that make and return functions. Closures allow us to make functions based on a template:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">missing_fixer &lt;- function(na_value) &#123;</span><br><span class="line">  function(x) &#123;</span><br><span class="line">    x[x == na_value] &lt;- NA</span><br><span class="line">    x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fix_missing_99 &lt;- missing_fixer(-99)</span><br><span class="line">fix_missing_999 &lt;- missing_fixer(-999)</span><br><span class="line"></span><br><span class="line">fix_missing_99(c(-99, -999))</span><br><span class="line">fix_missing_999(c(-99, -999))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin_sidebar(&quot;Extra argument&quot;)</span><br></pre></td></tr></table></figure>
<p>In this case, you could argue that we should just add another argument:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fix_missing &lt;- function(x, na.value) &#123;</span><br><span class="line">  x[x == na.value] &lt;- NA</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thatâs a reasonable solution here, but it doesnât always work well in every situation. Weâll see more compelling uses for closures in <a href="#functionals-math">MLE</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end_sidebar()</span><br></pre></td></tr></table></figure>
<p>Now consider a related problem. Once youâve cleaned up your data, you might want to compute the same set of numerical summaries for each variable. You could write code like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mean(df$a)</span><br><span class="line">median(df$a)</span><br><span class="line">sd(df$a)</span><br><span class="line">mad(df$a)</span><br><span class="line">IQR(df$a)</span><br><span class="line"></span><br><span class="line">mean(df$b)</span><br><span class="line">median(df$b)</span><br><span class="line">sd(df$b)</span><br><span class="line">mad(df$b)</span><br><span class="line">IQR(df$b)</span><br></pre></td></tr></table></figure>
<p>But again, youâd be better off identifying and removing duplicate items. Take a minute or two to think about how you might tackle this problem before reading on.</p>
<p>One approach would be to write a summary function and then apply it to each column:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">summary &lt;- function(x) &#123;</span><br><span class="line">  c(mean(x), median(x), sd(x), mad(x), IQR(x))</span><br><span class="line">&#125;</span><br><span class="line">lapply(df, summary)</span><br></pre></td></tr></table></figure>
<p>Thatâs a great start, but thereâs still some duplication. Itâs easier to see if we make the summary function more realistic:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">summary &lt;- function(x) &#123;</span><br><span class="line"> c(mean(x, na.rm = TRUE),</span><br><span class="line">   median(x, na.rm = TRUE),</span><br><span class="line">   sd(x, na.rm = TRUE),</span><br><span class="line">   mad(x, na.rm = TRUE),</span><br><span class="line">   IQR(x, na.rm = TRUE))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>All five functions are called with the same arguments (<code>x</code> and <code>na.rm</code>) repeated five times. As always, duplication makes our code fragile: itâs easier to introduce bugs and harder to adapt to changing requirements.</p>
<p>To remove this source of duplication, you can take advantage of another functional programming technique: storing functions in lists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">summary &lt;- function(x) &#123;</span><br><span class="line">  funs &lt;- c(mean, median, sd, mad, IQR)</span><br><span class="line">  lapply(funs, function(f) f(x, na.rm = TRUE))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This chapter discusses these techniques in more detail. But before you can start learning them, you need to learn the simplest FP tool, the anonymous function.</p>
<h2 id="Anonymous-functions"><a href="#Anonymous-functions" class="headerlink" title="Anonymous functions"></a>Anonymous functions</h2><p>In R, functions are objects in their own right. They arenât automatically bound to a name. Unlike many languages (e.g., C, C++, Python, and Ruby), R doesnât have a special syntax for creating a named function: when you create a function, you use the regular assignment operator to give it a name. If you choose not to give the function a name, you get an <strong>anonymous function</strong>.</p>
<p>You use an anonymous function when itâs not worth the effort to give it a name:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lapply(mtcars, function(x) length(unique(x)))</span><br><span class="line">Filter(function(x) !is.numeric(x), mtcars)</span><br><span class="line">integrate(function(x) sin(x) ^ 2, 0, pi)</span><br></pre></td></tr></table></figure>
<p>Like all functions in R, anonymous functions have <code>formals()</code>, a <code>body()</code>, and a parent <code>environment()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">formals(function(x = 4) g(x) + h(x))</span><br><span class="line">body(function(x = 4) g(x) + h(x))</span><br><span class="line">environment(function(x = 4) g(x) + h(x))</span><br></pre></td></tr></table></figure>
<p>You can call an anonymous function without giving it a name, but the code is a little tricky to read because you must use parentheses in two different ways: first, to call a function, and second to make it clear that you want to call the anonymous function itself, as opposed to calling a (possibly invalid) function <em>inside</em> the anonymous function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># This does not call the anonymous function.</span><br><span class="line"># (Note that &quot;3&quot; is not a valid function.)</span><br><span class="line">function(x) 3()</span><br><span class="line"></span><br><span class="line"># With appropriate parenthesis, the function is called:</span><br><span class="line">(function(x) 3)()</span><br><span class="line"></span><br><span class="line"># So this anonymous function syntax</span><br><span class="line">(function(x) x + 3)(10)</span><br><span class="line"></span><br><span class="line"># behaves exactly the same as</span><br><span class="line">f &lt;- function(x) x + 3</span><br><span class="line">f(10)</span><br></pre></td></tr></table></figure>
<p>You can call anonymous functions with named arguments, but doing so is a good sign that your function needs a name.</p>
<p>One of the most common uses for anonymous functions is to create closures, functions made by other functions. Closures are described in the next section.</p>
<h3 id="Exercises-21"><a href="#Exercises-21" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Given a function, like <code>&quot;mean&quot;</code>, <code>match.fun()</code> lets you find a function.   Given a function, can you find its name? Why doesnât that make sense in R?</li>
<li>Use <code>lapply()</code> and an anonymous function to find the coefficient of   variation (the standard deviation divided by the mean) for all columns in   the <code>mtcars</code> dataset.</li>
<li><p>Use <code>integrate()</code> and an anonymous function to find the area under the   curve for the following functions.   Use <a href="http://www.wolframalpha.com/" target="_blank" rel="external">Wolfram Alpha</a> to check your answers.</p>
<ol>
<li><code>y = x ^ 2 - x</code>, x in [0, 10]</li>
<li><code>y = sin(x) + cos(x)</code>, x in [-$\pi$, $\pi$]</li>
<li><code>y = exp(x) / x</code>, x in [10, 20]</li>
</ol>
</li>
<li><p>A good rule of thumb is that an anonymous function should fit on one line   and shouldnât need to use <code>{}</code>. Review your code. Where could you have   used an anonymous function instead of a named function? Where should you   have used a named function instead of an anonymous function?</p>
</li>
</ol>
<h2 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h2><blockquote>
<p>âAn object is data with functions. A closure is a function with data.â<br>â John D. Cook</p>
</blockquote>
<p>One use of anonymous functions is to create small functions that are not worth naming. Another important use is to create closures, functions written by functions. Closures get their name because they <strong>enclose</strong> the environment of the parent function and can access all its variables. This is useful because it allows us to have two levels of parameters: a parent level that controls operation and a child level that does the work.</p>
<p>The following example uses this idea to generate a family of power functions in which a parent function (<code>power()</code>) creates two child functions (<code>square()</code> and <code>cube()</code>).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">power &lt;- function(exponent) &#123;</span><br><span class="line">  function(x) &#123;</span><br><span class="line">    x ^ exponent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square &lt;- power(2)</span><br><span class="line">square(2)</span><br><span class="line">square(4)</span><br><span class="line"></span><br><span class="line">cube &lt;- power(3)</span><br><span class="line">cube(2)</span><br><span class="line">cube(4)</span><br></pre></td></tr></table></figure>
<p>When you print a closure, you donât see anything terribly useful:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">square</span><br><span class="line">cube</span><br></pre></td></tr></table></figure>
<p>Thatâs because the function itself doesnât change. The difference is the enclosing environment, <code>environment(square)</code>. One way to see the contents of the environment is to convert it to a list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">as.list(environment(square))</span><br><span class="line">as.list(environment(cube))</span><br></pre></td></tr></table></figure>
<p>Another way to see whatâs going on is to use <code>pryr::unenclose()</code>. This function replaces variables defined in the enclosing environment with their values:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(pryr)</span><br><span class="line">unenclose(square)</span><br><span class="line">unenclose(cube)</span><br></pre></td></tr></table></figure>
<p>The parent environment of a closure is the execution environment of the function that created it, as shown by this code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">power &lt;- function(exponent) &#123;</span><br><span class="line">  print(environment())</span><br><span class="line">  function(x) x ^ exponent</span><br><span class="line">&#125;</span><br><span class="line">zero &lt;- power(0)</span><br><span class="line">environment(zero)</span><br></pre></td></tr></table></figure>
<p>The execution environment normally disappears after the function returns a value. However, functions capture their enclosing environments. This means when function a returns function b, function b captures and stores the execution environment of function a, and it doesnât disappear. (This has important consequences for memory use, see <a href="#gc">memory usage</a> for details.)</p>
<p>In R, almost every function is a closure. All functions remember the environment in which they were created, typically either the global environment, if itâs a function that youâve written, or a package environment, if itâs a function that someone else has written. The only exception is primitive functions, which call C code directly and donât have an associated environment.</p>
<p>Closures are useful for making function factories, and are one way to manage mutable state in R.</p>
<h3 id="Function-factories"><a href="#Function-factories" class="headerlink" title="Function factories"></a>Function factories</h3><p>A function factory is a factory for making new functions. Weâve already seen two examples of function factories, <code>missing_fixer()</code> and <code>power()</code>. You call it with arguments that describe the desired actions, and it returns a function that will do the work for you. For <code>missing_fixer()</code> and <code>power()</code>, thereâs not much benefit in using a function factory instead of a single function with multiple arguments. Function factories are most useful when:</p>
<ul>
<li><p>The different levels are more complex, with multiple arguments and<br>complicated bodies.</p>
</li>
<li><p>Some work only needs to be done once, when the function is generated.</p>
</li>
</ul>
<p>Function factories are particularly well suited to maximum likelihood problems, and youâll see a more compelling use of them in <a href="#functionals-math">mathematical functionals</a>.</p>
<h3 id="Mutable-state"><a href="#Mutable-state" class="headerlink" title="Mutable state"></a><a href="id=&quot;mutable-state&quot;">Mutable state</a></h3><p>Having variables at two levels allows you to maintain state across function invocations. This is possible because while the execution environment is refreshed every time, the enclosing environment is constant. The key to managing variables at different levels is the double arrow assignment operator (<code>&lt;&lt;-</code>). Unlike the usual single arrow assignment (<code>&lt;-</code>) that always assigns in the current environment, the double arrow operator will keep looking up the chain of parent environments until it finds a matching name. (<a href="#binding">Binding names to values</a> has more details on how it works.)</p>
<p>Together, a static parent environment and <code>&lt;&lt;-</code> make it possible to maintain state across function calls. The following example shows a counter that records how many times a function has been called. Each time <code>new_counter</code> is run, it creates an environment, initialises the counter <code>i</code> in this environment, and then creates a new function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new_counter &lt;- function() &#123;</span><br><span class="line">  i &lt;- 0</span><br><span class="line">  function() &#123;</span><br><span class="line">    i &lt;&lt;- i + 1</span><br><span class="line">    i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The new function is a closure, and its enclosing environment is the environment created when <code>new_counter()</code> is run. Ordinarily, function execution environments are temporary, but a closure maintains access to the environment in which it was created. In the example below, closures <code>counter_one()</code> and <code>counter_two()</code> each get their own enclosing environments when run, so they can maintain different counts.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">counter_one &lt;- new_counter()</span><br><span class="line">counter_two &lt;- new_counter()</span><br><span class="line"></span><br><span class="line">counter_one()</span><br><span class="line">counter_one()</span><br><span class="line">counter_two()</span><br></pre></td></tr></table></figure>
<p>The counters get around the âfresh startâ limitation by not modifying variables in their local environment. Since the changes are made in the unchanging parent (or enclosing) environment, they are preserved across function calls.</p>
<p>What happens if you donât use a closure? What happens if you use <code>&lt;-</code> instead of <code>&lt;&lt;-</code>? Make predictions about what will happen if you replace <code>new_counter()</code> with the variants below, then run the code and check your predictions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">i &lt;- 0</span><br><span class="line">new_counter2 &lt;- function() &#123;</span><br><span class="line">  i &lt;&lt;- i + 1</span><br><span class="line">  i</span><br><span class="line">&#125;</span><br><span class="line">new_counter3 &lt;- function() &#123;</span><br><span class="line">  i &lt;- 0</span><br><span class="line">  function() &#123;</span><br><span class="line">    i &lt;- i + 1</span><br><span class="line">    i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Modifying values in a parent environment is an important technique because it is one way to generate âmutable stateâ in R. Mutable state is normally hard because every time it looks like youâre modifying an object, youâre actually creating and then modifying a copy. However, if you do need mutable objects and your code is not very simple, itâs usually better to use reference classes, as described in <a href="#rc">RC</a>.</p>
<p>The power of closures is tightly coupled with the more advanced ideas in <a href="#functionals">functionals</a> and <a href="#function-operators">function operators</a>. Youâll see many more closures in those two chapters. The following section discusses the third technique of functional programming in R: the ability to store functions in a list.</p>
<h3 id="Exercises-22"><a href="#Exercises-22" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Why are functions created by other functions called closures?</li>
<li><p>What does the following statistical function do? What would be a better    name for it? (The existing name is a bit of a hint.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bc &lt;- function(lambda) &#123;</span><br><span class="line">  if (lambda == 0) &#123;</span><br><span class="line">    function(x) log(x)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    function(x) (x ^ lambda - 1) / lambda</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>What does <code>approxfun()</code> do? What does it return?</p>
</li>
<li>What does <code>ecdf()</code> do? What does it return?</li>
<li><p>Create a function that creates functions that compute the ith    <a href="http://en.wikipedia.org/wiki/Central_moment" target="_blank" rel="external">central moment</a> of a numeric    vector. You can test it by running the following code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m1 &lt;- moment(1)</span><br><span class="line">m2 &lt;- moment(2)</span><br><span class="line"></span><br><span class="line">x &lt;- runif(100)</span><br><span class="line">stopifnot(all.equal(m1(x), 0))</span><br><span class="line">stopifnot(all.equal(m2(x), var(x) * 99 / 100))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Create a function <code>pick()</code> that takes an index, <code>i</code>, as an argument and    returns a function with an argument <code>x</code> that subsets <code>x</code> with <code>i</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lapply(mtcars, pick(5))</span><br><span class="line"># should do the same as this</span><br><span class="line">lapply(mtcars, function(x) x[[5]])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Lists-of-functions"><a href="#Lists-of-functions" class="headerlink" title="Lists of functions"></a><a href="id=&quot;lists-of-functions&quot;">Lists of functions</a></h2><p>In R, functions can be stored in lists. This makes it easier to work with groups of related functions, in the same way a data frame makes it easier to work with groups of related vectors.</p>
<p>Weâll start with a simple benchmarking example. Imagine you are comparing the performance of multiple ways of computing the arithmetic mean. You could do this by storing each approach (function) in a list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">compute_mean &lt;- list(</span><br><span class="line">  base = function(x) mean(x),</span><br><span class="line">  sum = function(x) sum(x) / length(x),</span><br><span class="line">  manual = function(x) &#123;</span><br><span class="line">    total &lt;- 0</span><br><span class="line">    n &lt;- length(x)</span><br><span class="line">    for (i in seq_along(x)) &#123;</span><br><span class="line">      total &lt;- total + x[i] / n</span><br><span class="line">    &#125;</span><br><span class="line">    total</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Calling a function from a list is straightforward. You extract it then call it:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- runif(1e5)</span><br><span class="line">system.time(compute_mean$base(x))</span><br><span class="line">system.time(compute_mean[[2]](x))</span><br><span class="line">system.time(compute_mean[[&quot;manual&quot;]](x))</span><br></pre></td></tr></table></figure>
<p>To call each function (e.g., to check that they all return the same results), use <code>lapply()</code>. Weâll need either an anonymous function or a new named function, since there isnât a built-in function to handle this situation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lapply(compute_mean, function(f) f(x))</span><br><span class="line"></span><br><span class="line">call_fun &lt;- function(f, ...) f(...)</span><br><span class="line">lapply(compute_mean, call_fun, x)</span><br></pre></td></tr></table></figure>
<p>To time each function, we can combine <code>lapply()</code> and <code>system.time()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lapply(compute_mean, function(f) system.time(f(x)))</span><br></pre></td></tr></table></figure>
<p>Another use for a list of functions is to summarise an object in multiple ways. To do that, we could store each summary function in a list, and then run them all with <code>lapply()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1:10</span><br><span class="line">funs &lt;- list(</span><br><span class="line">  sum = sum,</span><br><span class="line">  mean = mean,</span><br><span class="line">  median = median</span><br><span class="line">)</span><br><span class="line">lapply(funs, function(f) f(x))</span><br></pre></td></tr></table></figure>
<p>What if we wanted our summary functions to automatically remove missing values? One approach would be make a list of anonymous functions that call our summary functions with the appropriate arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">funs2 &lt;- list(</span><br><span class="line">  sum = function(x, ...) sum(x, ..., na.rm = TRUE),</span><br><span class="line">  mean = function(x, ...) mean(x, ..., na.rm = TRUE),</span><br><span class="line">  median = function(x, ...) median(x, ..., na.rm = TRUE)</span><br><span class="line">)</span><br><span class="line">lapply(funs2, function(f) f(x))</span><br></pre></td></tr></table></figure>
<p>This, however, leads to a lot of duplication. Apart from a different function name, each function is almost identical. A better approach would be to modify our <code>lapply()</code> call to include the extra argument:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lapply(funs, function(f) f(x, na.rm = TRUE))</span><br></pre></td></tr></table></figure>
<h3 id="Moving-lists-of-functions-to-the-global-environment"><a href="#Moving-lists-of-functions-to-the-global-environment" class="headerlink" title="Moving lists of functions to the global environment"></a>Moving lists of functions to the global environment</h3><p>From time to time you may create a list of functions that you want to be available without having to use a special syntax. For example, imagine you want to create HTML code by mapping each tag to an R function. The following example uses a function factory to create functions for the tags <code>&lt;p&gt;</code> (paragraph), <code>&lt;b&gt;</code> (bold), and <code>&lt;i&gt;</code> (italics).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">simple_tag &lt;- function(tag) &#123;</span><br><span class="line">  force(tag)</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    paste0(&quot;&lt;&quot;, tag, &quot;&gt;&quot;, paste0(...), &quot;&lt;/&quot;, tag, &quot;&gt;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">tags &lt;- c(&quot;p&quot;, &quot;b&quot;, &quot;i&quot;)</span><br><span class="line">html &lt;- lapply(setNames(tags, tags), simple_tag)</span><br></pre></td></tr></table></figure>
<p>Iâve put the functions in a list because I donât want them to be available all the time. The risk of a conflict between an existing R function and an HTML tag is high. But keeping them in a list makes code more verbose:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html$p(&quot;This is &quot;, html$b(&quot;bold&quot;), &quot; text.&quot;)</span><br></pre></td></tr></table></figure>
<p>Depending on how long we want the effect to last, you have three options to eliminate the use of <code>html$</code>:</p>
<ul>
<li><p>For a very temporary effect, you can use <code>with()</code>:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with(html, p(&quot;This is &quot;, b(&quot;bold&quot;), &quot; text.&quot;))</span><br></pre></td></tr></table></figure>
</li>
<li><p>For a longer effect, you can <code>attach()</code> the functions to the search path,  then <code>detach()</code> when youâre done:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">attach(html)</span><br><span class="line">p(&quot;This is &quot;, b(&quot;bold&quot;), &quot; text.&quot;)</span><br><span class="line">detach(html)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Finally, you could copy the functions to the global environment with  <code>list2env()</code>. You can undo this by deleting the functions after youâre done.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list2env(html, environment())</span><br><span class="line">p(&quot;This is &quot;, b(&quot;bold&quot;), &quot; text.&quot;)</span><br><span class="line">rm(list = names(html), envir = environment())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>I recommend the first option, using <code>with()</code>, because it makes it very clear when code is being executed in a special context and what that context is.</p>
<h3 id="Exercises-23"><a href="#Exercises-23" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Implement a summary function that works like <code>base::summary()</code>, but uses a    list of functions. Modify the function so it returns a closure, making it    possible to use it as a function factory.</li>
<li><p>Which of the following commands is equivalent to <code>with(x, f(z))</code>?</p>
<p> (a) <code>x$f(x$z)</code>.<br> (b) <code>f(x$z)</code>.<br> (c) <code>x$f(z)</code>.<br> (d) <code>f(z)</code>.<br> (e) It depends.</p>
</li>
</ol>
<h2 id="Case-study-numerical-integration"><a href="#Case-study-numerical-integration" class="headerlink" title="Case study: numerical integration"></a><a href="id=&quot;numerical-integration&quot;">Case study: numerical integration</a></h2><p>To conclude this chapter, Iâll develop a simple numerical integration tool using first-class functions. Each step in the development of the tool is driven by a desire to reduce duplication and to make the approach more general.</p>
<p>The idea behind numerical integration is simple: find the area under a curve by approximating the curve with simpler components. The two simplest approaches are the <strong>midpoint</strong> and <strong>trapezoid</strong> rules. The midpoint rule approximates a curve with a rectangle. The trapezoid rule uses a trapezoid. Each takes the function we want to integrate, <code>f</code>, and a range of values, from <code>a</code> to <code>b</code>, to integrate over. For this example, Iâll try to integrate <code>sin x</code> from 0 to $\pi$. This is a good choice for testing because it has a simple answer: 2.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">midpoint &lt;- function(f, a, b) &#123;</span><br><span class="line">  (b - a) * f((a + b) / 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trapezoid &lt;- function(f, a, b) &#123;</span><br><span class="line">  (b - a) / 2 * (f(a) + f(b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">midpoint(sin, 0, pi)</span><br><span class="line">trapezoid(sin, 0, pi)</span><br></pre></td></tr></table></figure>
<p>Neither of these functions gives a very good approximation. To make them more accurate using the idea that underlies calculus: weâll break up the range into smaller pieces and integrate each piece using one of the simple rules. This is called <strong>composite integration</strong>. Iâll implement it using two new functions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">midpoint_composite &lt;- function(f, a, b, n = 10) &#123;</span><br><span class="line">  points &lt;- seq(a, b, length = n + 1)</span><br><span class="line">  h &lt;- (b - a) / n</span><br><span class="line"></span><br><span class="line">  area &lt;- 0</span><br><span class="line">  for (i in seq_len(n)) &#123;</span><br><span class="line">    area &lt;- area + h * f((points[i] + points[i + 1]) / 2)</span><br><span class="line">  &#125;</span><br><span class="line">  area</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trapezoid_composite &lt;- function(f, a, b, n = 10) &#123;</span><br><span class="line">  points &lt;- seq(a, b, length = n + 1)</span><br><span class="line">  h &lt;- (b - a) / n</span><br><span class="line"></span><br><span class="line">  area &lt;- 0</span><br><span class="line">  for (i in seq_len(n)) &#123;</span><br><span class="line">    area &lt;- area + h / 2 * (f(points[i]) + f(points[i + 1]))</span><br><span class="line">  &#125;</span><br><span class="line">  area</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">midpoint_composite(sin, 0, pi, n = 10)</span><br><span class="line">midpoint_composite(sin, 0, pi, n = 100)</span><br><span class="line">trapezoid_composite(sin, 0, pi, n = 10)</span><br><span class="line">trapezoid_composite(sin, 0, pi, n = 100)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mid &lt;- sapply(1:20, function(n) midpoint_composite(sin, 0, pi, n))</span><br><span class="line">trap &lt;- sapply(1:20, function(n) trapezoid_composite(sin, 0, pi, n))</span><br><span class="line">matplot(cbind(mid, trap),</span><br><span class="line">  xlab = &quot;Number of pieces&quot;, ylab = &quot;Estimate of area&quot;)</span><br></pre></td></tr></table></figure>
<p>Youâll notice that thereâs a lot of duplication between <code>midpoint_composite()</code> and <code>trapezoid_composite()</code>. Apart from the internal rule used to integrate over a range, they are basically the same. From these specific functions you can extract a more general composite integration function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">composite &lt;- function(f, a, b, n = 10, rule) &#123;</span><br><span class="line">  points &lt;- seq(a, b, length = n + 1)</span><br><span class="line"></span><br><span class="line">  area &lt;- 0</span><br><span class="line">  for (i in seq_len(n)) &#123;</span><br><span class="line">    area &lt;- area + rule(f, points[i], points[i + 1])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  area</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">composite(sin, 0, pi, n = 10, rule = midpoint)</span><br><span class="line">composite(sin, 0, pi, n = 10, rule = trapezoid)</span><br></pre></td></tr></table></figure>
<p>This function takes two functions as arguments: the function to integrate and the integration rule. We can now add even better rules for integrating over smaller ranges:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">simpson &lt;- function(f, a, b) &#123;</span><br><span class="line">  (b - a) / 6 * (f(a) + 4 * f((a + b) / 2) + f(b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boole &lt;- function(f, a, b) &#123;</span><br><span class="line">  pos &lt;- function(i) a + i * (b - a) / 4</span><br><span class="line">  fi &lt;- function(i) f(pos(i))</span><br><span class="line"></span><br><span class="line">  (b - a) / 90 *</span><br><span class="line">    (7 * fi(0) + 32 * fi(1) + 12 * fi(2) + 32 * fi(3) + 7 * fi(4))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">composite(sin, 0, pi, n = 10, rule = simpson)</span><br><span class="line">composite(sin, 0, pi, n = 10, rule = boole)</span><br></pre></td></tr></table></figure>
<p>It turns out that the midpoint, trapezoid, Simpson, and Boole rules are all examples of a more general family called <a href="http://en.wikipedia.org/wiki/Newton%E2%80%93Cotes_formulas" target="_blank" rel="external">Newton-Cotes rules</a>. (They are polynomials of increasing complexity.) We  can use this common structure to write a function that can generate any general Newton-Cotes rule:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">newton_cotes &lt;- function(coef, open = FALSE) &#123;</span><br><span class="line">  n &lt;- length(coef) + open</span><br><span class="line"></span><br><span class="line">  function(f, a, b) &#123;</span><br><span class="line">    pos &lt;- function(i) a + i * (b - a) / n</span><br><span class="line">    points &lt;- pos(seq.int(0, length(coef) - 1))</span><br><span class="line"></span><br><span class="line">    (b - a) / sum(coef) * sum(f(points) * coef)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boole &lt;- newton_cotes(c(7, 32, 12, 32, 7))</span><br><span class="line">milne &lt;- newton_cotes(c(2, -1, 2), open = TRUE)</span><br><span class="line">composite(sin, 0, pi, n = 10, rule = milne)</span><br></pre></td></tr></table></figure>
<p>Mathematically, the next step in improving numerical integration is to move from a grid of evenly spaced points to a grid where the points are closer together near the end of the range, such as Gaussian quadrature. Thatâs beyond the scope of this case study, but you could implement it with similar techniques.</p>
<h3 id="Exercises-24"><a href="#Exercises-24" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Instead of creating individual functions (e.g., <code>midpoint()</code>,      <code>trapezoid()</code>, <code>simpson()</code>, etc.), we could store them in a list. If we    did that, how would that change the code? Can you create the list of    functions from a list of coefficients for the Newton-Cotes formulae?</li>
<li>The trade-off between integration rules is that more complex rules are    slower to compute, but need fewer pieces. For <code>sin()</code> in the range    [0, $\pi$], determine the number of pieces needed so that each rule will    be equally accurate. Illustrate your results with a graph. How do they    change for different functions? <code>sin(1 / x^2)</code> is particularly challenging.</li>
</ol>
<hr>
<h1 id="Functionals"><a href="#Functionals" class="headerlink" title="Functionals"></a><a href="id=&quot;functionals&quot;">Functionals</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library(pryr)</span><br><span class="line">library(stringr)</span><br><span class="line">find_funs(&quot;package:base&quot;, fun_calls, fixed(&quot;match.fun&quot;))</span><br><span class="line">find_funs(&quot;package:base&quot;, fun_args, ignore.case(&quot;^(fun|f)$&quot;))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>âTo become significantly more reliable, code must become more transparent.<br>In particular, nested conditions and loops must be viewed with great<br>suspicion. Complicated control flows confuse programmers. Messy code often<br>hides bugs.â</p>
<p>â Bjarne Stroustrup</p>
</blockquote>
<p>A higher-order function is a function that takes a function as an input or returns a function as output. Weâve already seen one type of higher order function: closures, functions returned by another function. The complement to a closure is a <strong>functional</strong>, a function that takes a function as an input and returns a vector as output. Hereâs a simple functional: it calls the function provided as input with 1000 random uniform numbers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">randomise &lt;- function(f) f(runif(1e3))</span><br><span class="line">randomise(mean)</span><br><span class="line">randomise(mean)</span><br><span class="line">randomise(sum)</span><br></pre></td></tr></table></figure>
<p>The chances are that youâve already used a functional: the three most frequently used are <code>lapply()</code>, <code>apply()</code>, and <code>tapply()</code>. All three take a function as input (among other things) and return a vector as output.</p>
<p>A common use of functionals is as an alternative to for loops. For loops have a bad rap in R. They have a reputation for being slow (although that reputation is only partly true, see <a href="#modification">modification in place</a> for more details). But the real downside of for loops is that theyâre not very expressive. A for loop conveys that itâs iterating over something, but doesnât clearly convey a high level goal. Instead of using a for loop, itâs better to use a functional. Each functional is tailored for a specific task, so when you recognise the functional you know immediately why itâs being used. Functionals play other roles as well as replacements for for-loops. They are useful for encapsulating common data manipulation tasks like split-apply-combine, for thinking âfunctionallyâ, and for working with mathematical functions.</p>
<p>Functionals reduce bugs in your code by better communicating intent. Functionals implemented in base R are well tested (i.e., bug-free) and efficient, because theyâre used by so many people. Many are written in C, and use special tricks to enhance performance. That said, using functionals will not always produce the fastest code. Instead, it helps you clearly communicate and build tools that solve a wide range of problems. Itâs a mistake to focus on speed until you know itâll be a problem. Once you have clear, correct code you can make it fast using the techniques youâll learn in <a href="#profiling">improving the speed of your code</a>.</p>
<h5 id="Outline-7"><a href="#Outline-7" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#lapply">My first functional: lapply()</a> introduces your first functional:  <code>lapply()</code>.</li>
<li><a href="#functionals-loop">For loop functionals</a> shows you variants of <code>lapply()</code>  that produce different outputs, take different inputs, and distribute  computation in different ways.</li>
<li><a href="#functionals-ds">Data structure functionals</a> discusses functionals that  work with more complex data structures like matrices and arrays.</li>
<li><a href="#functionals-fp">Functional programming</a> teaches you about the powerful  <code>Reduce()</code> and <code>Filter()</code> functions which are useful for working with  lists.</li>
<li><a href="#functionals-math">Mathematical functionals</a> discusses functionals that you  might be familiar with from mathematics, like root finding, integration, and  optimisation.</li>
<li><a href="#functionals-not">Loops that shouldnât be converted to functions</a> provides  some important caveats about when you shouldnât attempt to convert a loop into  a functional.</li>
<li><a href="#function-family">A family of functions</a> finishes off the chapter by  showing you how functionals can take a simple building block and use it to  create a set of powerful and consistent tools.</li>
</ul>
<h5 id="Prerequisites-3"><a href="#Prerequisites-3" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><p>Youâll use closures frequently used in conjunction with functionals. If you need a refresher, review <a href="#closures">closures</a>.</p>
<h2 id="My-first-functional-lapply"><a href="#My-first-functional-lapply" class="headerlink" title="My first functional: lapply()"></a><a href="id=&quot;lapply&quot;">My first functional: lapply()</a></h2><p>The simplest functional is <code>lapply()</code>, which you may already be familiar with. <code>lapply()</code> takes a function, applies it to each element in a list, and returns the results in the form of a list. <code>lapply()</code> is the building block for many other functionals, so itâs important to understand how it works. Hereâs a pictorial representation:</p>
<p><img src="diagrams/lapply.png" alt=""></p>
<p><code>lapply()</code> is written in C for performance, but we can create a simple R implementation that does the same thing:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lapply2 &lt;- function(x, f, ...) &#123;</span><br><span class="line">  out &lt;- vector(&quot;list&quot;, length(x))</span><br><span class="line">  for (i in seq_along(x)) &#123;</span><br><span class="line">    out[[i]] &lt;- f(x[[i]], ...)</span><br><span class="line">  &#125;</span><br><span class="line">  out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>From this code, you can see that <code>lapply()</code> is a wrapper for a common for loop pattern: create a container for output, apply <code>f()</code> to each component of a list, and fill the container with the results. All other for loop functionals are variations on this theme: they simply use different types of input or output.</p>
<p><code>lapply()</code> makes it easier to work with lists by eliminating much of the boilerplate associated with looping. This allows you to focus on the function that youâre applying:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Create some random data</span><br><span class="line">l &lt;- replicate(20, runif(sample(1:10, 1)), simplify = FALSE)</span><br><span class="line"></span><br><span class="line"># With a for loop</span><br><span class="line">out &lt;- vector(&quot;list&quot;, length(l))</span><br><span class="line">for (i in seq_along(l)) &#123;</span><br><span class="line">  out[[i]] &lt;- length(l[[i]])</span><br><span class="line">&#125;</span><br><span class="line">unlist(out)</span><br><span class="line"></span><br><span class="line"># With lapply</span><br><span class="line">unlist(lapply(l, length))</span><br></pre></td></tr></table></figure>
<p>(Iâm using <code>unlist()</code> to convert the output from a list to a vector to make it more compact. Weâll see other ways of making the output a vector shortly.)</p>
<p>Since data frames are also lists, <code>lapply()</code> is also useful when you want to do something to each column of a data frame:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># What class is each column?</span><br><span class="line">unlist(lapply(mtcars, class))</span><br><span class="line"></span><br><span class="line"># Divide each column by the mean</span><br><span class="line">mtcars[] &lt;- lapply(mtcars, function(x) x / mean(x))</span><br></pre></td></tr></table></figure>
<p>The pieces of <code>x</code> are always supplied as the first argument to <code>f</code>. If you want to vary a different argument, you can use an anonymous function. The following example varies the amount of trimming applied when computing the mean of a fixed <code>x</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trims &lt;- c(0, 0.1, 0.2, 0.5)</span><br><span class="line">x &lt;- rcauchy(1000)</span><br><span class="line">unlist(lapply(trims, function(trim) mean(x, trim = trim)))</span><br></pre></td></tr></table></figure>
<h3 id="Looping-patterns"><a href="#Looping-patterns" class="headerlink" title="Looping patterns"></a>Looping patterns</h3><p>Itâs useful to remember that there are three basic ways to loop over a vector:</p>
<ol>
<li>loop over the elements: <code>for (x in xs)</code></li>
<li>loop over the numeric indices: <code>for (i in seq_along(xs))</code></li>
<li>loop over the names: <code>for (nm in names(xs))</code></li>
</ol>
<p>The first form is usually not a good choice for a for loop because it leads to inefficient ways of saving output. With this form itâs very natural to save the output by extending a datastructure, like in this example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xs &lt;- runif(1e3)</span><br><span class="line">res &lt;- c()</span><br><span class="line">for (x in xs) &#123;</span><br><span class="line">  # This is slow!</span><br><span class="line">  res &lt;- c(res, sqrt(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is slow because each time you extend the vector, R has to copy all of the existing elements. <a href="#avoid-copies">Avoid copies</a> discusses this problem in more depth. Instead, itâs much better to create the space youâll need for the output and then fill it in. This is easiest with the second form:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res &lt;- numeric(length(xs))</span><br><span class="line">for (i in seq_along(xs)) &#123;</span><br><span class="line">  res[i] &lt;- sqrt(xs[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Just as there are three basic ways to use a for loop, there are three basic ways to use <code>lapply()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lapply(xs, function(x) &#123;&#125;)</span><br><span class="line">lapply(seq_along(xs), function(i) &#123;&#125;)</span><br><span class="line">lapply(names(xs), function(nm) &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>Typically youâd use the first form because <code>lapply()</code> takes care of saving the output for you. However, if you need to know the position or name of the element youâre working with, you should use the second or third form. Both give you an elementâs position (<code>i</code>, <code>nm</code>) and value (<code>xs[[i]]</code>, <code>xs[[nm]]</code>). If youâre struggling to solve a problem using one form, you might find it easier with another.</p>
<h3 id="Exercises-25"><a href="#Exercises-25" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>Why are the following two invocations of <code>lapply()</code> equivalent?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trims &lt;- c(0, 0.1, 0.2, 0.5)</span><br><span class="line">x &lt;- rcauchy(100)</span><br><span class="line"></span><br><span class="line">lapply(trims, function(trim) mean(x, trim = trim))</span><br><span class="line">lapply(trims, mean, x = x)</span><br></pre></td></tr></table></figure>
</li>
<li><p>The function below scales a vector so it falls in the range [0, 1]. How    would you apply it to every column of a data frame? How would you apply it    to every numeric column in a data frame?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scale01 &lt;- function(x) &#123;</span><br><span class="line">  rng &lt;- range(x, na.rm = TRUE)</span><br><span class="line">  (x - rng[1]) / (rng[2] - rng[1])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Use both for loops and <code>lapply()</code> to fit linear models to the    <code>mtcars</code> using the formulas stored in this list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">formulas &lt;- list(</span><br><span class="line">  mpg ~ disp,</span><br><span class="line">  mpg ~ I(1 / disp),</span><br><span class="line">  mpg ~ disp + wt,</span><br><span class="line">  mpg ~ I(1 / disp) + wt</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Fit the model <code>mpg ~ disp</code> to each of the bootstrap replicates of <code>mtcars</code>    in the list below by using a for loop and <code>lapply()</code>. Can you do it    without an anonymous function?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bootstraps &lt;- lapply(1:10, function(i) &#123;</span><br><span class="line">  rows &lt;- sample(1:nrow(mtcars), rep = TRUE)</span><br><span class="line">  mtcars[rows, ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>For each model in the previous two exercises, extract $R^2$ using the    function below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsq &lt;- function(mod) summary(mod)$r.squared</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="For-loop-functionals-friends-of-lapply"><a href="#For-loop-functionals-friends-of-lapply" class="headerlink" title="For loop functionals: friends of lapply()"></a><a href="id=&quot;functionals-loop&quot;">For loop functionals: friends of lapply()</a></h2><p>The key to using functionals in place of for loops is recognising that common looping patterns are already implemented in existing base functionals. Once youâve mastered these existing functionals, the next step is to start writing your own: if you discover youâre duplicating the same looping pattern in many places, you should extract it out into its own function.</p>
<p>The following sections build on <code>lapply()</code> and discuss:</p>
<ul>
<li><code>sapply()</code> and <code>vapply()</code>, variants of <code>lapply()</code> that produce vectors,  matrices, and arrays as <strong>output</strong>, instead of lists.</li>
<li><code>Map()</code> and <code>mapply()</code> which iterate over multiple <strong>input</strong> data structures  in parallel.</li>
<li><code>mclapply()</code> and <code>mcMap()</code>, parallel versions of <code>lapply()</code> and <code>Map()</code>.</li>
<li>Writing a new function, <code>rollapply()</code>, to solve a new problem.</li>
</ul>
<h3 id="Vector-output-sapply-and-vapply"><a href="#Vector-output-sapply-and-vapply" class="headerlink" title="Vector output: sapply and vapply"></a>Vector output: <code>sapply</code> and <code>vapply</code></h3><p><code>sapply()</code> and <code>vapply()</code> are very similar to <code>lapply()</code> except they simplify their output to produce an atomic vector. While <code>sapply()</code> guesses, <code>vapply()</code> takes an additional argument specifying the output type. <code>sapply()</code> is great for interactive use because it saves typing, but if you use it inside your functions youâll get weird errors if you supply the wrong type of input. <code>vapply()</code> is more verbose, but gives more informative error messages and never fails silently. It is better suited for use inside other functions.</p>
<p>The following example illustrates these differences. When given a data frame, <code>sapply()</code> and <code>vapply()</code> return the same results. When given an empty list, <code>sapply()</code> returns another empty list instead of the more correct zero-length logical vector.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sapply(mtcars, is.numeric)</span><br><span class="line">vapply(mtcars, is.numeric, logical(1))</span><br><span class="line">sapply(list(), is.numeric)</span><br><span class="line">vapply(list(), is.numeric, logical(1))</span><br></pre></td></tr></table></figure>
<p>If the function returns results of different types or lengths, <code>sapply()</code> will silently return a list, while <code>vapply()</code> will throw an error. <code>sapply()</code> is fine for interactive use because youâll normally notice if something goes wrong, but itâs dangerous when writing functions.</p>
<p>The following example illustrates a possible problem when extracting the class of columns in a data frame: if you falsely assume that class only has one value and use <code>sapply()</code>, you wonât find out about the problem until some future function is given a list instead of a character vector.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(x = 1:10, y = letters[1:10])</span><br><span class="line">sapply(df, class)</span><br><span class="line">vapply(df, class, character(1))</span><br><span class="line"></span><br><span class="line">df2 &lt;- data.frame(x = 1:10, y = Sys.time() + 1:10)</span><br><span class="line">sapply(df2, class)</span><br><span class="line">vapply(df2, class, character(1))</span><br></pre></td></tr></table></figure>
<p><code>sapply()</code> is a thin wrapper around <code>lapply()</code> that transforms a list into a vector in the final step. <code>vapply()</code> is an implementation of <code>lapply()</code> that assigns results to a vector (or matrix) of appropriate type instead of as a list. The following code shows a pure R implementation of the essence of <code>sapply()</code> and <code>vapply()</code> (the real functions have better error handling and preserve names, among other things).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sapply2 &lt;- function(x, f, ...) &#123;</span><br><span class="line">  res &lt;- lapply2(x, f, ...)</span><br><span class="line">  simplify2array(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vapply2 &lt;- function(x, f, f.value, ...) &#123;</span><br><span class="line">  out &lt;- matrix(rep(f.value, length(x)), nrow = length(x))</span><br><span class="line">  for (i in seq_along(x)) &#123;</span><br><span class="line">    res &lt;- f(x[i], ...)</span><br><span class="line">    stopifnot(</span><br><span class="line">      length(res) == length(f.value),</span><br><span class="line">      typeof(res) == typeof(f.value)</span><br><span class="line">    )</span><br><span class="line">    out[i, ] &lt;- res</span><br><span class="line">  &#125;</span><br><span class="line">  out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="diagrams/sapply-vapply.png" alt=""></p>
<p><code>vapply()</code> and <code>sapply()</code> have different outputs from <code>lapply()</code>. The following section discusses <code>Map()</code>, which has different inputs.</p>
<h3 id="Multiple-inputs-Map-and-mapply"><a href="#Multiple-inputs-Map-and-mapply" class="headerlink" title="Multiple inputs: Map (and mapply)"></a><a href="id=&quot;map&quot;">Multiple inputs: <code>Map</code> (and <code>mapply</code>)</a></h3><p>With <code>lapply()</code>, only one argument to the function varies; the others are fixed. This makes it poorly suited for some problems. For example, how would you find a weighted mean when you have two lists, one of observations and the other of weights?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Generate some sample data</span><br><span class="line">xs &lt;- replicate(5, runif(10), simplify = FALSE)</span><br><span class="line">ws &lt;- replicate(5, rpois(10, 5) + 1, simplify = FALSE)</span><br></pre></td></tr></table></figure>
<p>Itâs easy to use <code>lapply()</code> to compute the unweighted means:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlist(lapply(xs, mean))</span><br></pre></td></tr></table></figure>
<p>But how could we supply the weights to <code>weighted.mean()</code>? <code>lapply(x, means, w)</code> wonât work because the additional arguments to <code>lapply()</code> are passed to every call. We could change looping forms:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unlist(lapply(seq_along(xs), function(i) &#123;</span><br><span class="line">  weighted.mean(xs[[i]], ws[[i]])</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>This works, but itâs a little clumsy. A cleaner alternative is to use <code>Map</code>, a variant of <code>lapply()</code>, where all arguments can vary. This lets us write:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlist(Map(weighted.mean, xs, ws))</span><br></pre></td></tr></table></figure>
<p>Note that the order of arguments is a little different: function is the first argument for <code>Map()</code> and the second for <code>lapply()</code>.</p>
<p>This is equivalent to:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stopifnot(length(xs) == length(ws))</span><br><span class="line">out &lt;- vector(&quot;list&quot;, length(xs))</span><br><span class="line">for (i in seq_along(xs)) &#123;</span><br><span class="line">  out[[i]] &lt;- weighted.mean(xs[[i]], ws[[i]])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thereâs a natural equivalence between <code>Map()</code> and <code>lapply()</code> because you can always convert a <code>Map()</code> to an <code>lapply()</code> that iterates over indices. But using <code>Map()</code> is more concise, and more clearly indicates what youâre trying to do.</p>
<p><code>Map</code> is useful whenever you have two (or more) lists (or data frames) that you need to process in parallel. For example, another way of standardising columns is to first compute the means and then divide by them. We could do this with <code>lapply()</code>, but if we do it in two steps, we can more easily check the results at each step, which is particularly important if the first step is more complicated.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mtmeans &lt;- lapply(mtcars, mean)</span><br><span class="line">mtmeans[] &lt;- Map(`/`, mtcars, mtmeans)</span><br><span class="line"></span><br><span class="line"># In this case, equivalent to</span><br><span class="line">mtcars[] &lt;- lapply(mtcars, function(x) x / mean(x))</span><br></pre></td></tr></table></figure>
<p>If some of the arguments should be fixed and constant, use an anonymous function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map(function(x, w) weighted.mean(x, w, na.rm = TRUE), xs, ws)</span><br></pre></td></tr></table></figure>
<p>Weâll see a more compact way to express the same idea in the next chapter.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin_sidebar(&quot;mapply&quot;)</span><br></pre></td></tr></table></figure>
<p>You may be more familiar with <code>mapply()</code> than <code>Map()</code>. I prefer <code>Map()</code> because:</p>
<ul>
<li><p>Itâs equivalent to <code>mapply</code> with <code>simplify = FALSE</code>, which is almost always<br>what you want.</p>
</li>
<li><p>Instead of using an anonymous function to provide constant inputs, <code>mapply</code><br>has the <code>MoreArgs</code> argument that takes a list of extra arguments that will<br>be supplied, as is, to each call. This breaks Râs usual lazy evaluation<br>semantics, and is inconsistent with other functions.</p>
</li>
</ul>
<p>In brief, <code>mapply()</code> adds more complication for little gain.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end_sidebar()</span><br></pre></td></tr></table></figure>
<h3 id="Rolling-computations"><a href="#Rolling-computations" class="headerlink" title="Rolling computations"></a>Rolling computations</h3><p>What if you need a for loop replacement that doesnât exist in base R? You can often create your own by recognising common looping structures and implementing your own wrapper. For example, you might be interested in smoothing your data using a rolling (or running) mean function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rollmean &lt;- function(x, n) &#123;</span><br><span class="line">  out &lt;- rep(NA, length(x))</span><br><span class="line"></span><br><span class="line">  offset &lt;- trunc(n / 2)</span><br><span class="line">  for (i in (offset + 1):(length(x) - n + offset + 1)) &#123;</span><br><span class="line">    out[i] &lt;- mean(x[(i - offset):(i + offset - 1)])</span><br><span class="line">  &#125;</span><br><span class="line">  out</span><br><span class="line">&#125;</span><br><span class="line">x &lt;- seq(1, 3, length = 1e2) + runif(1e2)</span><br><span class="line">plot(x)</span><br><span class="line">lines(rollmean(x, 5), col = &quot;blue&quot;, lwd = 2)</span><br><span class="line">lines(rollmean(x, 10), col = &quot;red&quot;, lwd = 2)</span><br></pre></td></tr></table></figure>
<p>But if the noise was more variable (i.e., it has a longer tail), you might worry that your rolling mean was too sensitive to outliers. Instead, you might want to compute a rolling median.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- seq(1, 3, length = 1e2) + rt(1e2, df = 2) / 3</span><br><span class="line">plot(x)</span><br><span class="line">lines(rollmean(x, 5), col = &quot;red&quot;, lwd = 2)</span><br></pre></td></tr></table></figure>
<p>To change <code>rollmean()</code> to <code>rollmedian()</code>, all you need to do is replace <code>mean</code> with <code>median</code> inside the loop. But instead of copying and pasting to create a new function, we could extract the idea of computing a rolling summary into its own function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rollapply &lt;- function(x, n, f, ...) &#123;</span><br><span class="line">  out &lt;- rep(NA, length(x))</span><br><span class="line"></span><br><span class="line">  offset &lt;- trunc(n / 2)</span><br><span class="line">  for (i in (offset + 1):(length(x) - n + offset + 1)) &#123;</span><br><span class="line">    out[i] &lt;- f(x[(i - offset):(i + offset)], ...)</span><br><span class="line">  &#125;</span><br><span class="line">  out</span><br><span class="line">&#125;</span><br><span class="line">plot(x)</span><br><span class="line">lines(rollapply(x, 5, median), col = &quot;red&quot;, lwd = 2)</span><br></pre></td></tr></table></figure>
<p>You might notice that the internal loop looks pretty similar to a <code>vapply()</code> loop, so we could rewrite the function as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rollapply &lt;- function(x, n, f, ...) &#123;</span><br><span class="line">  offset &lt;- trunc(n / 2)</span><br><span class="line">  locs &lt;- (offset + 1):(length(x) - n + offset + 1)</span><br><span class="line">  num &lt;- vapply(</span><br><span class="line">    locs,</span><br><span class="line">    function(i) f(x[(i - offset):(i + offset)], ...),</span><br><span class="line">    numeric(1)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  c(rep(NA, offset), num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is effectively the same as the implementation in <code>zoo::rollapply()</code>, which provides many more features and much more error checking.</p>
<h3 id="Parallelisation"><a href="#Parallelisation" class="headerlink" title="Parallelisation"></a>Parallelisation</h3><p>One interesting thing about the implementation of <code>lapply()</code> is that because each iteration is isolated from all others, the order in which they are computed doesnât matter. For example, <code>lapply3()</code> scrambles the order of computation, but the results are always the same:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lapply3 &lt;- function(x, f, ...) &#123;</span><br><span class="line">  out &lt;- vector(&quot;list&quot;, length(x))</span><br><span class="line">  for (i in sample(seq_along(x))) &#123;</span><br><span class="line">    out[[i]] &lt;- f(x[[i]], ...)</span><br><span class="line">  &#125;</span><br><span class="line">  out</span><br><span class="line">&#125;</span><br><span class="line">unlist(lapply(1:10, sqrt))</span><br><span class="line">unlist(lapply3(1:10, sqrt))</span><br></pre></td></tr></table></figure>
<p>This has a very important consequence: since we can compute each element in any order, itâs easy to dispatch the tasks to different cores, and compute them in parallel. This is what <code>parallel::mclapply()</code> (and <code>parallel::mcMap()</code>) does. (These functions are not available in Windows, but you can use the similar <code>parLapply()</code> with a bit more work. See <a href="#parallelise">parallelise</a> for more details.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library(parallel)</span><br><span class="line">unlist(mclapply(1:10, sqrt, mc.cores = 4))</span><br></pre></td></tr></table></figure>
<p>In this case, <code>mclapply()</code> is actually slower than <code>lapply()</code>. This is because the cost of the individual computations is low, and additional work is needed to send the computation to the different cores and to collect the results.</p>
<p>If we take a more realistic example, generating bootstrap replicates of a linear model for example, the advantages are clearer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boot_df &lt;- function(x) x[sample(nrow(x), rep = T), ]</span><br><span class="line">rsquared &lt;- function(mod) summary(mod)$r.square</span><br><span class="line">boot_lm &lt;- function(i) &#123;</span><br><span class="line">  rsquared(lm(mpg ~ wt + disp, data = boot_df(mtcars)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system.time(lapply(1:500, boot_lm))</span><br><span class="line">system.time(mclapply(1:500, boot_lm, mc.cores = 2))</span><br></pre></td></tr></table></figure>
<p>While increasing the number of cores will not always lead to linear improvement, switching from <code>lapply()</code> or <code>Map()</code> to its parallelised forms can dramatically improve computational performance.</p>
<h3 id="Exercises-26"><a href="#Exercises-26" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>Use <code>vapply()</code> to:</p>
<p>a) Compute the standard deviation of every column in a numeric data frame.<br>a) Compute the standard deviation of every numeric column in a mixed data       frame. (Hint: youâll need to use <code>vapply()</code> twice.)</p>
</li>
<li><p>Why is using <code>sapply()</code> to get the <code>class()</code> of each element in    a data frame dangerous?</p>
</li>
<li><p>The following code simulates the performance of a t-test for non-normal    data. Use <code>sapply()</code> and an anonymous function to extract the p-value from    every trial.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trials &lt;- replicate(</span><br><span class="line">  100,</span><br><span class="line">  t.test(rpois(10, 10), rpois(7, 10)),</span><br><span class="line">  simplify = FALSE</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Extra challenge: get rid of the anonymous function by using <code>[[</code> directly.</p>
</li>
<li><p>What does <code>replicate()</code> do? What sort of for loop does it eliminate? Why    do its arguments differ from <code>lapply()</code> and friends?</p>
</li>
<li>Implement a version of <code>lapply()</code> that supplies <code>FUN</code> with both the name    and the value of each component.</li>
<li>Implement a combination of <code>Map()</code> and <code>vapply()</code> to create an <code>lapply()</code>    variant that iterates in parallel over all of its inputs and stores its    outputs in a vector (or a matrix). What arguments should the function    take?</li>
<li>Implement <code>mcsapply()</code>, a multicore version of <code>sapply()</code>. Can you    implement <code>mcvapply()</code>, a parallel version of <code>vapply()</code>? Why or why not?</li>
</ol>
<h2 id="Manipulating-matrices-and-data-frames"><a href="#Manipulating-matrices-and-data-frames" class="headerlink" title="Manipulating matrices and data frames"></a><a href="id=&quot;functionals-ds&quot;">Manipulating matrices and data frames</a></h2><p>Functionals can also be used to eliminate loops in common data manipulation tasks. In this section, weâll give a brief overview of the available options, hint at how they can help you, and point you in the right direction to learn more. Weâll cover three categories of data structure functionals:</p>
<ul>
<li><code>apply()</code>, <code>sweep()</code>, and <code>outer()</code> work with matrices.</li>
<li><code>tapply()</code> summarises a vector by groups defined by another vector.</li>
<li>the <code>plyr</code> package, which generalises <code>tapply()</code> to make it easy to  work with data frames, lists, or arrays as inputs, and data frames, lists,  or arrays as outputs.</li>
</ul>
<h3 id="Matrix-and-array-operations"><a href="#Matrix-and-array-operations" class="headerlink" title="Matrix and array operations"></a>Matrix and array operations</h3><p>So far, all the functionals weâve seen work with 1d input structures. The three functionals in this section provide useful tools for working with higher-dimensional data structures. <code>apply()</code> is a variant of <code>sapply()</code> that works with matrices and arrays. You can think of it as an operation that summarises a matrix or array by collapsing each row or column to a single number. It has four arguments:</p>
<ul>
<li><code>X</code>, the matrix or array to summarise</li>
<li><code>MARGIN</code>, an integer vector giving the dimensions to summarise over,  1 = rows, 2 = columns, etc.</li>
<li><code>FUN</code>, a summary function</li>
<li><code>...</code> other arguments passed on to <code>FUN</code></li>
</ul>
<p>A typical example of <code>apply()</code> looks like this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- matrix(1:20, nrow = 5)</span><br><span class="line">apply(a, 1, mean)</span><br><span class="line">apply(a, 2, mean)</span><br></pre></td></tr></table></figure>
<p>There are a few caveats to using <code>apply()</code>. It doesnât have a simplify argument, so you can never be completely sure what type of output youâll get. This  means that <code>apply()</code> is not safe to use inside a function unless you carefully check the inputs. <code>apply()</code> is also not idempotent in the sense that if the summary function is the identity operator, the output is not always the same as the input:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a1 &lt;- apply(a, 1, identity)</span><br><span class="line">identical(a, a1)</span><br><span class="line">identical(a, t(a1))</span><br><span class="line">a2 &lt;- apply(a, 2, identity)</span><br><span class="line">identical(a, a2)</span><br></pre></td></tr></table></figure>
<p>(You can put high-dimensional arrays back in the right order using <code>aperm()</code>, or use <code>plyr::aaply()</code>, which is idempotent.)</p>
<p><code>sweep()</code> allows you to âsweepâ out the values of a summary statistic. It is often used with <code>apply()</code> to standardise arrays. The following example scales the rows of a matrix so that all values lie between 0 and 1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- matrix(rnorm(20, 0, 10), nrow = 4)</span><br><span class="line">x1 &lt;- sweep(x, 1, apply(x, 1, min), `-`)</span><br><span class="line">x2 &lt;- sweep(x1, 1, apply(x1, 1, max), `/`)</span><br></pre></td></tr></table></figure>
<p>The final matrix functional is <code>outer()</code>. Itâs a little different in that it takes multiple vector inputs and creates a matrix or array output where the input function is run over every combination of the inputs:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Create a times table</span><br><span class="line">outer(1:3, 1:10, &quot;*&quot;)</span><br></pre></td></tr></table></figure>
<p>Good places to learn more about <code>apply()</code> and friends are:</p>
<ul>
<li><a href="http://petewerner.blogspot.com/2012/12/using-apply-sapply-lapply-in-r.html" target="_blank" rel="external">âUsing apply, sapply, lapply in Râ</a> by Peter Werner.</li>
<li><a href="http://rforpublichealth.blogspot.no/2012/09/the-infamous-apply-function.html" target="_blank" rel="external">âThe infamous apply functionâ</a> by Slawa Rokicki.</li>
<li><a href="http://forgetfulfunctor.blogspot.com/2011/07/r-apply-function-tutorial-with-examples.html" target="_blank" rel="external">âThe R apply function - a tutorial with examplesâ</a> by axiomOfChoice.</li>
<li>The stackoverflow question <a href="http://stackoverflow.com/questions/3505701" target="_blank" rel="external">âR Grouping functions: <code>sapply</code> vs. <code>lapply</code> vs. <code>apply</code> vs. <code>tapply</code> vs. <code>by</code> vs. <code>aggregate</code>â</a>.</li>
</ul>
<h3 id="Group-apply"><a href="#Group-apply" class="headerlink" title="Group apply"></a>Group apply</h3><p>You can think about <code>tapply()</code> as a generalisation to <code>apply()</code> that allows for âraggedâ arrays, arrays where each row can have a different number of columns. This is often needed when youâre trying to summarise a data set. For example, imagine youâve collected pulse rate data from a medical trial, and you want to compare the two groups:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pulse &lt;- round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12))</span><br><span class="line">group &lt;- rep(c(&quot;A&quot;, &quot;B&quot;), c(10, 12))</span><br><span class="line"></span><br><span class="line">tapply(pulse, group, length)</span><br><span class="line">tapply(pulse, group, mean)</span><br></pre></td></tr></table></figure>
<p><code>tapply()</code> works by creating a âraggedâ data structure from a set of inputs, and then applying a function to the individual elements of that structure. The first task is actually what the <code>split()</code> function does. It takes two inputs and returns a list which groups elements together from the first vector according to elements, or categories, from the second vector:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split(pulse, group)</span><br></pre></td></tr></table></figure>
<p>Then <code>tapply()</code> is just the combination of <code>split()</code> and <code>sapply()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tapply2 &lt;- function(x, group, f, ..., simplify = TRUE) &#123;</span><br><span class="line">  pieces &lt;- split(x, group)</span><br><span class="line">  sapply(pieces, f, simplify = simplify)</span><br><span class="line">&#125;</span><br><span class="line">tapply2(pulse, group, length)</span><br><span class="line">tapply2(pulse, group, mean)</span><br></pre></td></tr></table></figure>
<p>Being able to rewrite <code>tapply()</code> as a combination of <code>split()</code> and <code>sapply()</code> is a good indication that weâve identified some useful building blocks.</p>
<h3 id="The-plyr-package"><a href="#The-plyr-package" class="headerlink" title="The plyr package"></a>The plyr package</h3><p>One challenge with using the base functionals is that they have grown organically over time, and have been written by multiple authors. This means that they are not very consistent:</p>
<ul>
<li>With <code>tapply()</code> and <code>sapply()</code>, the simplify argument is called <code>simplify</code>.  With <code>mapply()</code>, itâs called <code>SIMPLIFY</code>. With <code>apply()</code>, the argument is  absent.</li>
<li><code>vapply()</code> is a variant of <code>sapply()</code> that allows you to describe what the  output should be, but there are no corresponding variants for <code>tapply()</code>,  <code>apply()</code>, or <code>Map()</code>.</li>
<li>The first argument of most base functionals is a vector, but the first  argument in <code>Map()</code> is a function.</li>
</ul>
<p>This makes learning these operators challenging, as you have to memorise all of the variations. Additionally, if you think about the possible combinations of input and output types, base R only covers a partial set of cases:</p>
<table>
<thead>
<tr>
<th></th>
<th>list</th>
<th>data frame</th>
<th>array</th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td><code>lapply()</code></td>
<td></td>
<td><code>sapply()</code></td>
</tr>
<tr>
<td>data frame</td>
<td><code>by()</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>array</td>
<td></td>
<td></td>
<td><code>apply()</code></td>
</tr>
</tbody>
</table>
<p>This was one of the driving motivations behind the creation of the plyr package. It provides consistently named functions with consistently named arguments and covers all combinations of input and output data structures:</p>
<table>
<thead>
<tr>
<th></th>
<th>list</th>
<th>data frame</th>
<th>array</th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td><code>llply()</code></td>
<td><code>ldply()</code></td>
<td><code>laply()</code></td>
</tr>
<tr>
<td>data frame</td>
<td><code>dlply()</code></td>
<td><code>ddply()</code></td>
<td><code>daply()</code></td>
</tr>
<tr>
<td>array</td>
<td><code>alply()</code></td>
<td><code>adply()</code></td>
<td><code>aaply()</code></td>
</tr>
</tbody>
</table>
<p>Each of these functions splits up the input, applies a function to each piece, and then combines the results. Overall, this process is called âsplit-apply-combineâ. You can read more about it and plyr in <a href="http://www.jstatsoft.org/v40/i01/" target="_blank" rel="external">âThe Split-Apply-Combine Strategy for Data Analysisâ</a>, an open-access article published in the <em>Journal of Statistical Software</em>.</p>
<h3 id="Exercises-27"><a href="#Exercises-27" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>How does <code>apply()</code> arrange the output? Read the documentation and perform    some experiments.</li>
<li>Thereâs no equivalent to <code>split()</code> + <code>vapply()</code>. Should there be? When    would it be useful? Implement one yourself.</li>
<li>Implement a pure R version of <code>split()</code>. (Hint: use <code>unique()</code> and    subsetting.) Can you do it without a for loop?</li>
<li>What other types of input and output are missing? Brainstorm before you  look up some answers in the <a href="http://www.jstatsoft.org/v40/i01/" target="_blank" rel="external">plyr paper</a>.</li>
</ol>
<h2 id="Manipulating-lists"><a href="#Manipulating-lists" class="headerlink" title="Manipulating lists"></a><a href="id=&quot;functionals-fp&quot;">Manipulating lists</a></h2><p>Another way of thinking about functionals is as a set of general tools for altering, subsetting, and collapsing lists. Every functional programming language has three tools for this: <code>Map()</code>, <code>Reduce()</code>, and <code>Filter()</code>. Weâve seen <code>Map()</code> already, and the following sections describe <code>Reduce()</code>, a powerful tool for extending two-argument functions, and <code>Filter()</code>, a member of an important class of functionals that work with predicates, functions that return a single <code>TRUE</code> or <code>FALSE</code>.</p>
<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce()"></a><code>Reduce()</code></h3><p><code>Reduce()</code> reduces a vector, <code>x</code>, to a single value by recursively calling a function, <code>f</code>, two arguments at a time. It combines the first two elements with <code>f</code>, then combines the result of that call with the third element, and so on. Calling <code>Reduce(f, 1:3)</code> is equivalent to <code>f(f(1, 2), 3)</code>. Reduce is also known as fold, because it folds together adjacent elements in the list.</p>
<p>The following two examples show what <code>Reduce</code> does with an infix and prefix function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reduce(`+`, 1:3) # -&gt; ((1 + 2) + 3)</span><br><span class="line">Reduce(sum, 1:3) # -&gt; sum(sum(1, 2), 3)</span><br></pre></td></tr></table></figure>
<p>The essence of <code>Reduce()</code> can be described by a simple for loop:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Reduce2 &lt;- function(f, x) &#123;</span><br><span class="line">  out &lt;- x[[1]]</span><br><span class="line">  for(i in seq(2, length(x))) &#123;</span><br><span class="line">    out &lt;- f(out, x[[i]])</span><br><span class="line">  &#125;</span><br><span class="line">  out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The real <code>Reduce()</code> is more complicated because it includes arguments to control whether the values are reduced from the left or from the right (<code>right</code>), an optional initial value (<code>init</code>), and an option to output intermediate results (<code>accumulate</code>).</p>
<p><code>Reduce()</code> is an elegant way of extending a function that works with two inputs into a function that can deal with any number of inputs. Itâs useful for implementing many types of recursive operations, like merges and intersections. (Weâll see another use in the final case study.) Imagine you have a list of numeric vectors, and you want to find the values that occur in every element:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l &lt;- replicate(5, sample(1:10, 15, replace = T), simplify = FALSE)</span><br><span class="line">str(l)</span><br></pre></td></tr></table></figure>
<p>You could do that by intersecting each element in turn:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intersect(intersect(intersect(intersect(l[[1]], l[[2]]),</span><br><span class="line">  l[[3]]), l[[4]]), l[[5]])</span><br></pre></td></tr></table></figure>
<p>Thatâs hard to read. With <code>Reduce()</code>, the equivalent is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reduce(intersect, l)</span><br></pre></td></tr></table></figure>
<h3 id="Predicate-functionals"><a href="#Predicate-functionals" class="headerlink" title="Predicate functionals"></a>Predicate functionals</h3><p>A <strong>predicate</strong> is a function that returns a single <code>TRUE</code> or <code>FALSE</code>, like <code>is.character</code>, <code>all</code>, or <code>is.NULL</code>. A predicate functional applies a predicate to each element of a list or data frame. There are three useful predicate functionals in base R: <code>Filter()</code>, <code>Find()</code>, and <code>Position()</code>.</p>
<ul>
<li><code>Filter()</code> selects only those elements which match the predicate.</li>
<li><code>Find()</code> returns the first element which matches the predicate (or the last  element if <code>right = TRUE</code>).</li>
<li><code>Position()</code> returns the position of the first element that matches the  predicate (or the last element if <code>right = TRUE</code>).</li>
</ul>
<p>Another useful predicate functional is <code>where()</code>, a custom functional that generates a logical vector from a list (or a data frame) and a predicate:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where &lt;- function(f, x) &#123;</span><br><span class="line">  vapply(x, f, logical(1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The following example shows how you might use these functionals with a data frame:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</span><br><span class="line">where(is.factor, df)</span><br><span class="line">str(Filter(is.factor, df))</span><br><span class="line">str(Find(is.factor, df))</span><br><span class="line">Position(is.factor, df)</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-28"><a href="#Exercises-28" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Why isnât <code>is.na()</code> a predicate function? What base R function is closest    to being a predicate version of <code>is.na()</code>?</li>
<li>Use <code>Filter()</code> and <code>vapply()</code> to create a function that applies a summary    statistic to every numeric column in a data frame.</li>
<li>Whatâs the relationship between <code>which()</code> and <code>Position()</code>? Whatâs    the relationship between <code>where()</code> and <code>Filter()</code>?</li>
<li>Implement <code>Any()</code>, a function that takes a list and a predicate function,    and returns <code>TRUE</code> if the predicate function returns <code>TRUE</code> for any of    the inputs. Implement <code>All()</code> similarly.</li>
<li>Implement the <code>span()</code> function from Haskell: given a list <code>x</code> and a    predicate function <code>f</code>, <code>span</code> returns the location of the longest    sequential run of elements where the predicate is true. (Hint: you    might find <code>rle()</code> helpful.)</li>
</ol>
<h2 id="Mathematical-functionals"><a href="#Mathematical-functionals" class="headerlink" title="Mathematical functionals"></a><a href="id=&quot;functionals-math&quot;">Mathematical functionals</a></h2><p>Functionals are very common in mathematics. The limit, the maximum, the roots (the set of points where <code>f(x) = 0</code>), and the definite integral are all functionals: given a function, they return a single number (or vector of numbers). At first glance, these functions donât seem to fit in with the theme of eliminating loops, but if you dig deeper youâll find out that they are all implemented using an algorithm that involves iteration.</p>
<p>In this section weâll use some of Râs built-in mathematical functionals. There are three functionals that work with functions to return single numeric values:</p>
<ul>
<li><code>integrate()</code> finds the area under the curve defined by <code>f()</code></li>
<li><code>uniroot()</code> finds where <code>f()</code> hits zero</li>
<li><code>optimise()</code> finds the location of lowest (or highest) value of <code>f()</code></li>
</ul>
<p>Letâs explore how these are used with a simple function, <code>sin()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">integrate(sin, 0, pi)</span><br><span class="line">str(uniroot(sin, pi * c(1 / 2, 3 / 2)))</span><br><span class="line">str(optimise(sin, c(0, 2 * pi)))</span><br><span class="line">str(optimise(sin, c(0, pi), maximum = TRUE))</span><br></pre></td></tr></table></figure>
<p>In statistics, optimisation is often used for maximum likelihood estimation (MLE). In MLE, we have two sets of parameters: the data, which is fixed for a given problem, and the parameters, which vary as we try to find the maximum. These two sets of parameters make the problem well suited for closures. Combining closures with optimisation gives rise to the following approach to solving MLE problems.</p>
<p>The following example shows how we might find the maximum likelihood estimate for $\lambda$, if our data come from a Poisson distribution. First, we create a function factory that, given a dataset, returns a function that computes the negative log likelihood (NLL) for parameter <code>lambda</code>. In R, itâs common to work with the negative since <code>optimise()</code> defaults to finding the minimum.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">poisson_nll &lt;- function(x) &#123;</span><br><span class="line">  n &lt;- length(x)</span><br><span class="line">  sum_x &lt;- sum(x)</span><br><span class="line">  function(lambda) &#123;</span><br><span class="line">    n * lambda - sum_x * log(lambda) # + terms not involving lambda</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note how the closure allows us to precompute values that are constant with respect to the data.</p>
<p>We can use this function factory to generate specific NLL functions for input data. Then <code>optimise()</code> allows us to find the best values (the maximum likelihood estimates), given a generous starting range.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1 &lt;- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)</span><br><span class="line">x2 &lt;- c(6, 4, 7, 3, 3, 7, 5, 2, 2, 7, 5, 4, 12, 6, 9)</span><br><span class="line">nll1 &lt;- poisson_nll(x1)</span><br><span class="line">nll2 &lt;- poisson_nll(x2)</span><br><span class="line"></span><br><span class="line">optimise(nll1, c(0, 100))$minimum</span><br><span class="line">optimise(nll2, c(0, 100))$minimum</span><br></pre></td></tr></table></figure>
<p>We can check that these values are correct by comparing them to the analytic solution: in this case, itâs just the mean of the data, <code>r mean(x1)</code> and <code>r mean(x2)</code>.</p>
<p>Another important mathematical functional is <code>optim()</code>. It is a generalisation of <code>optimise()</code> that works with more than one dimension. If youâre interested in how it works, you might want to explore the <code>Rvmmin</code> package, which provides a pure-R implementation of <code>optim()</code>. Interestingly <code>Rvmmin</code> is no slower than <code>optim()</code>, even though it is written in R, not C. For this problem, the bottleneck lies not in controlling the optimisation but with having to evaluate the function multiple times.</p>
<h3 id="Exercises-29"><a href="#Exercises-29" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Implement <code>arg_max()</code>. It should take a function and a vector of inputs,    and return the elements of the input where the function returns the highest    value. For example, <code>arg_max(-10:5, function(x) x ^ 2)</code> should return -10.    <code>arg_max(-5:5, function(x) x ^ 2)</code> should return <code>c(-5, 5)</code>.    Also implement the matching <code>arg_min()</code> function.</li>
<li>Challenge: read about the    <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3" target="_blank" rel="external">fixed point algorithm</a>.    Complete the exercises using R.</li>
</ol>
<h2 id="Loops-that-should-be-left-as-is"><a href="#Loops-that-should-be-left-as-is" class="headerlink" title="Loops that should be left as is"></a><a href="id=&quot;functionals-not&quot;">Loops that should be left as is</a></h2><p>Some loops have no natural functional equivalent. In this section youâll learn about three common cases:</p>
<ul>
<li>modifying in place</li>
<li>recursive functions</li>
<li>while loops</li>
</ul>
<p>Itâs possible to torture these problems to use a functional, but itâs not a good idea. Youâll create code that is harder to understand, eliminating the main reason for using functionals in the first case.</p>
<h3 id="Modifying-in-place"><a href="#Modifying-in-place" class="headerlink" title="Modifying in place"></a>Modifying in place</h3><p>If you need to modify part of an existing data frame, itâs often better to use a for loop. For example, the following code performs a variable-by-variable transformation by matching the names of a list of functions to the names of variables in a data frame.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trans &lt;- list(</span><br><span class="line">  disp = function(x) x * 0.0163871,</span><br><span class="line">  am = function(x) factor(x, levels = c(&quot;auto&quot;, &quot;manual&quot;))</span><br><span class="line">)</span><br><span class="line">for(var in names(trans)) &#123;</span><br><span class="line">  mtcars[[var]] &lt;- trans[[var]](mtcars[[var]])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We wouldnât normally use <code>lapply()</code> to replace this loop directly, but it is <em>possible</em>. Just replace the loop with <code>lapply()</code> by using <code>&lt;&lt;-</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lapply(names(trans), function(var) &#123;</span><br><span class="line">  mtcars[[var]] &lt;&lt;- trans[[var]](mtcars[[var]])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>The for loop is gone, but the code is longer and much harder to understand. The reader needs to understand <code>&lt;&lt;-</code> and how <code>x[[y]] &lt;&lt;- z</code> works (itâs not simple!). In short, weâve taken a simple, easily understood for loop, and turned it into something few people will understand: not a good idea!</p>
<h3 id="Recursive-relationships"><a href="#Recursive-relationships" class="headerlink" title="Recursive relationships"></a>Recursive relationships</h3><p>Itâs hard to convert a for loop into a functional when the relationship between elements is not independent, or is defined recursively. For example, exponential smoothing works by taking a weighted average of the current and previous data points. The <code>exps()</code> function below implements exponential smoothing with a for loop.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exps &lt;- function(x, alpha) &#123;</span><br><span class="line">  s &lt;- numeric(length(x) + 1)</span><br><span class="line">  for (i in seq_along(s)) &#123;</span><br><span class="line">    if (i == 1) &#123;</span><br><span class="line">      s[i] &lt;- x[i]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      s[i] &lt;- alpha * x[i - 1] + (1 - alpha) * s[i - 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s</span><br><span class="line">&#125;</span><br><span class="line">x &lt;- runif(6)</span><br><span class="line">exps(x, 0.5)</span><br></pre></td></tr></table></figure>
<p>We canât eliminate the for loop because none of the functionals weâve seen allow the output at position <code>i</code> to depend on both the input and output at position <code>i - 1</code>.</p>
<p>One way to eliminate the for loop in this case is to <a href="http://en.wikipedia.org/wiki/Recurrence_relation#Solving" target="_blank" rel="external">solve the recurrence relation</a> by removing the recursion and replacing it with explicit references. This requires a new set of mathematical tools, and is challenging, but it can pay off by producing a simpler function.</p>
<h3 id="While-loops"><a href="#While-loops" class="headerlink" title="While loops"></a>While loops</h3><p>Another type of looping construct in R is the <code>while</code> loop. It keeps running until some condition is met. <code>while</code> loops are more general than <code>for</code> loops: you can rewrite every for loop as a while loop, but you canât do the reverse.  For example, we could turn this for loop:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (i in 1:10) print(i)</span><br></pre></td></tr></table></figure>
<p>into this while loop:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i &lt;- 1</span><br><span class="line">while(i &lt;= 10) &#123;</span><br><span class="line">  print(i)</span><br><span class="line">  i &lt;- i + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Not every while loop can be turned into a for loop because many while loops donât know in advance how many times they will be run:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i &lt;- 0</span><br><span class="line">while(TRUE) &#123;</span><br><span class="line">  if (runif(1) &gt; 0.9) break</span><br><span class="line">  i &lt;- i + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is a common problem when youâre writing simulations.</p>
<p>In this case we can remove the loop by recognising a special feature of the problem. Here weâre counting the number of successes before Bernoulli trial with p = 0.1 fails. This is a geometric random variable, so you could replace the code with <code>i &lt;- rgeom(1, 0.1)</code>. Reformulating the problem in this way is hard to do in general, but youâll benefit greatly if you can do it for your problem.</p>
<h2 id="A-family-of-functions"><a href="#A-family-of-functions" class="headerlink" title="A family of functions"></a><a href="id=&quot;function-family&quot;">A family of functions</a></h2><p>To finish off the chapter, this case study shows how you can use functionals to take a simple building block and make it powerful and general. Iâll start with a simple idea, adding two numbers together, and use functionals to extend it to summing multiple numbers, computing parallel and cumulative sums, and summing across array dimensions.</p>
<p>Weâll start by defining a very simple addition function, one which takes two scalar arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add &lt;- function(x, y) &#123;</span><br><span class="line">  stopifnot(length(x) == 1, length(y) == 1,</span><br><span class="line">    is.numeric(x), is.numeric(y))</span><br><span class="line">  x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(Weâre using Râs existing addition operator here, which does much more, but the focus here is on how we can take very simple building blocks and extend them to do more.)</p>
<p>Iâll also add an <code>na.rm</code> argument. A helper function will make this a bit easier: if <code>x</code> is missing it should return <code>y</code>, if <code>y</code> is missing it should return <code>x</code>, and if both <code>x</code> and <code>y</code> are missing then it should return another argument to the function: <code>identity</code>. This function is probably a bit more general than what we need now, but itâs useful if we implement other binary operators.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rm_na &lt;- function(x, y, identity) &#123;</span><br><span class="line">  if (is.na(x) &amp;&amp; is.na(y)) &#123;</span><br><span class="line">    identity</span><br><span class="line">  &#125; else if (is.na(x)) &#123;</span><br><span class="line">    y</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">rm_na(NA, 10, 0)</span><br><span class="line">rm_na(10, NA, 0)</span><br><span class="line">rm_na(NA, NA, 0)</span><br></pre></td></tr></table></figure>
<p>This allows us to write a version of <code>add()</code> that can deal with missing values if needed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add &lt;- function(x, y, na.rm = FALSE) &#123;</span><br><span class="line">  if (na.rm &amp;&amp; (is.na(x) || is.na(y))) rm_na(x, y, 0) else x + y</span><br><span class="line">&#125;</span><br><span class="line">add(10, NA)</span><br><span class="line">add(10, NA, na.rm = TRUE)</span><br><span class="line">add(NA, NA)</span><br><span class="line">add(NA, NA, na.rm = TRUE)</span><br></pre></td></tr></table></figure>
<p>Why did we pick an identity of <code>0</code>? Why should <code>add(NA, NA, na.rm = TRUE)</code> return 0? Well, for every other input it returns a number, so even if both arguments are <code>NA</code>, it should still do that. What number should it return? We can figure it out because additional is associative, which means that the order of additional doesnât matter. That means that the following two function calls should return the same value:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(add(3, NA, na.rm = TRUE), NA, na.rm = TRUE)</span><br><span class="line">add(3, add(NA, NA, na.rm = TRUE), na.rm = TRUE)</span><br></pre></td></tr></table></figure>
<p>This implies that <code>add(NA, NA, na.rm = TRUE)</code> must be 0, and hence <code>identity = 0</code> is the correct default.</p>
<p>Now that we have the basics working, we can extend the function to deal with more complicated inputs. One obvious generalisation is to add more than two numbers. We can do this by iteratively adding two numbers: if the input is <code>c(1, 2, 3)</code> we compute <code>add(add(1, 2), 3)</code>. This is a simple application of <code>Reduce()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r_add &lt;- function(xs, na.rm = TRUE) &#123;</span><br><span class="line">  Reduce(function(x, y) add(x, y, na.rm = na.rm), xs)</span><br><span class="line">&#125;</span><br><span class="line">r_add(c(1, 4, 10))</span><br></pre></td></tr></table></figure>
<p>This looks good, but we need to test a few special cases:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r_add(NA, na.rm = TRUE)</span><br><span class="line">r_add(numeric())</span><br></pre></td></tr></table></figure>
<p>These are incorrect. In the first case, we get a missing value even though weâve explicitly asked to ignore them. In the second case, we get <code>NULL</code> instead of a length one numeric vector (as we do for every other set of inputs).</p>
<p>The two problems are related. If we give <code>Reduce()</code> a length one vector, it doesnât have anything to reduce, so it just returns the input. If we give it an input of length zero, it always returns <code>NULL</code>. The easiest way to fix this problem is to use the <code>init</code> argument of <code>Reduce()</code>. This is added to the start of every input vector:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r_add &lt;- function(xs, na.rm = TRUE) &#123;</span><br><span class="line">  Reduce(function(x, y) add(x, y, na.rm = na.rm), xs, init = 0)</span><br><span class="line">&#125;</span><br><span class="line">r_add(c(1, 4, 10))</span><br><span class="line">r_add(NA, na.rm = TRUE)</span><br><span class="line">r_add(numeric())</span><br></pre></td></tr></table></figure>
<p><code>r_add()</code> is equivalent to <code>sum()</code>.</p>
<p>It would be nice to have a vectorised version of <code>add()</code> so that we can perform the addition of two vectors of numbers in element-wise fashion. We could use <code>Map()</code> or <code>vapply()</code> to implement this, but neither is perfect. <code>Map()</code> returns a list, instead of a numeric vector, so we need to use <code>simplify2array()</code>. <code>vapply()</code> returns a vector but it requires us to loop over a set of indices.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v_add1 &lt;- function(x, y, na.rm = FALSE) &#123;</span><br><span class="line">  stopifnot(length(x) == length(y), is.numeric(x), is.numeric(y))</span><br><span class="line">  if (length(x) == 0) return(numeric())</span><br><span class="line">  simplify2array(</span><br><span class="line">    Map(function(x, y) add(x, y, na.rm = na.rm), x, y)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v_add2 &lt;- function(x, y, na.rm = FALSE) &#123;</span><br><span class="line">  stopifnot(length(x) == length(y), is.numeric(x), is.numeric(y))</span><br><span class="line">  vapply(seq_along(x), function(i) add(x[i], y[i], na.rm = na.rm),</span><br><span class="line">    numeric(1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A few test cases help to ensure that it behaves as we expect. Weâre a bit stricter than base R here because we donât do recycling. (You could add that if you wanted, but I find that recycling is a frequent source of silent bugs.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Both versions give the same results</span><br><span class="line">v_add1(1:10, 1:10)</span><br><span class="line">v_add1(numeric(), numeric())</span><br><span class="line">v_add1(c(1, NA), c(1, NA))</span><br><span class="line">v_add1(c(1, NA), c(1, NA), na.rm = TRUE)</span><br></pre></td></tr></table></figure>
<p>Another variant of <code>add()</code> is the cumulative sum. We can implement it with <code>Reduce()</code> by setting the <code>accumulate</code> argument to <code>TRUE</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c_add &lt;- function(xs, na.rm = FALSE) &#123;</span><br><span class="line">  Reduce(function(x, y) add(x, y, na.rm = na.rm), xs,</span><br><span class="line">    accumulate = TRUE)</span><br><span class="line">&#125;</span><br><span class="line">c_add(1:10)</span><br><span class="line">c_add(10:1)</span><br></pre></td></tr></table></figure>
<p>This is equivalent to <code>cumsum()</code>.</p>
<p>Finally, we might want to define addition for more complicated data structures like matrices. We could create <code>row</code> and <code>col</code> variants that sum across rows and columns, respectively, or we could go the whole hog and define an array version that could sum across any arbitrary set of dimensions. These are easily implemented as combinations of <code>add()</code> and <code>apply()</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">row_sum &lt;- function(x, na.rm = FALSE) &#123;</span><br><span class="line">  apply(x, 1, add, na.rm = na.rm)</span><br><span class="line">&#125;</span><br><span class="line">col_sum &lt;- function(x, na.rm = FALSE) &#123;</span><br><span class="line">  apply(x, 2, add, na.rm = na.rm)</span><br><span class="line">&#125;</span><br><span class="line">arr_sum &lt;- function(x, dim, na.rm = FALSE) &#123;</span><br><span class="line">  apply(x, dim, add, na.rm = na.rm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The first two are equivalent to <code>rowSums()</code> and <code>colSums()</code>.</p>
<p>If every function we have created has an existing equivalent in base R, why did we bother? There are two main reasons:</p>
<ul>
<li>Since all variants were implemented by combining a simple binary operator  (<code>add()</code>) and a well-tested functional (<code>Reduce()</code>, <code>Map()</code>, <code>apply()</code>),  we know that our variants will behave consistently.</li>
<li>We can apply the same infrastructure to other operators, especially those  that might not have the full suite of variants in base R.</li>
</ul>
<p>The downside of this approach is that these implementations are not that efficient. (For example, <code>colSums(x)</code> is much faster than <code>apply(x, 2, sum)</code>.) However, even if they arenât that fast, simple implementations are still a good starting point because theyâre less likely to have bugs. When you create faster versions, you can compare the results to make sure your fast versions are still correct.</p>
<p>If you enjoyed this section, you might also enjoy <a href="http://stevelosh.com/blog/2013/03/list-out-of-lambda/" target="_blank" rel="external">âList out of lambdaâ</a>, a blog article by Steve Losh that shows how you can produce high level language structures (like lists) out of more primitive language features (like closures, aka lambdas).</p>
<h3 id="Exercises-30"><a href="#Exercises-30" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Implement <code>smaller</code> and <code>larger</code> functions that, given two inputs, return    either the smaller or the larger value. Implement <code>na.rm = TRUE</code>: what    should the identity be? (Hint:    <code>smaller(x, smaller(NA, NA, na.rm = TRUE), na.rm = TRUE)</code> must be <code>x</code>, so    <code>smaller(NA, NA, na.rm = TRUE)</code> must be bigger than any other value of x.)    Use <code>smaller</code> and <code>larger</code> to implement equivalents of <code>min()</code>, <code>max()</code>,    <code>pmin()</code>, <code>pmax()</code>, and new functions <code>row_min()</code> and <code>row_max()</code>.</li>
<li><p>Create a table that has <em>and</em>, <em>or</em>, <em>add</em>, <em>multiply</em>, <em>smaller</em>, and    <em>larger</em> in the columns and <em>binary operator</em>, <em>reducing variant</em>,    <em>vectorised variant</em>, and <em>array variants</em> in the rows.</p>
<p>a) Fill in the cells with the names of base R functions that perform each of<br>   the roles.</p>
<p>a) Compare the names and arguments of the existing R functions. How<br>   consistent are they? How could you improve them?</p>
<p>a) Complete the matrix by implementing any missing functions.</p>
</li>
<li><p>How does <code>paste()</code> fit into this structure? What is the scalar binary    function that underlies <code>paste()</code>? What are the <code>sep</code> and <code>collapse</code>    arguments to <code>paste()</code> equivalent to? Are there any <code>paste</code> variants    that donât have existing R implementations?</p>
</li>
</ol>
<hr>
<h1 id="Function-operators"><a href="#Function-operators" class="headerlink" title="Function operators"></a><a href="id=&quot;function-operators&quot;">Function operators</a></h1><p>In this chapter, youâll learn about function operators (FOs). A function operator is a function that takes one (or more) functions as input and returns a function as output. In some ways, function operators are similar to functionals: thereâs nothing you canât do without them, but they can make your code more readable and expressive, and they can help you write code faster. The main difference is that functionals extract common patterns of loop use, where function operators extract common patterns of anonymous function use.</p>
<p>The following code shows a simple function operator, <code>chatty()</code>. It wraps a function, making a new function that prints out its first argument. Itâs useful because it gives you a window to see how functionals, like <code>vapply()</code>, work.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chatty &lt;- function(f) &#123;</span><br><span class="line">  function(x, ...) &#123;</span><br><span class="line">    res &lt;- f(x, ...)</span><br><span class="line">    cat(&quot;Processing &quot;, x, &quot;\n&quot;, sep = &quot;&quot;)</span><br><span class="line">    res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f &lt;- function(x) x ^ 2</span><br><span class="line">s &lt;- c(3, 2, 1)</span><br><span class="line">chatty(f)(1)</span><br><span class="line"></span><br><span class="line">vapply(s, chatty(f), numeric(1))</span><br></pre></td></tr></table></figure>
<p>In the last chapter, we saw that many built-in functionals, like <code>Reduce()</code>, <code>Filter()</code>, and <code>Map()</code>, have very few arguments, so we had to use anonymous functions to modify how they worked. In this chapter, weâll build specialised substitutes for common anonymous functions that allow us to communicate our intent more clearly. For example, in <a href="#map">multiple inputs</a> we used an anonymous function with <code>Map()</code> to supply fixed arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map(function(x, y) f(x, y, zs), xs, ys)</span><br></pre></td></tr></table></figure>
<p>Later in this chapter, weâll learn about partial application using the <code>partial()</code> function. Partial application encapsulates the use of an anonymous function to supply default arguments, and allows us to write succinct code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map(partial(f, zs = zs), xs, yz)</span><br></pre></td></tr></table></figure>
<p>This is an important use of FOs: by transforming the input function, you eliminate parameters from a functional. In fact, as long as the inputs and outputs of the function remain the same, this approach allows your functionals to be more extensible, often in ways you havenât thought of.</p>
<p>The chapter covers four important types of FO: behaviour, input, output, and combining. For each type, Iâll show you some useful FOs, and how you can use as another to decompose problems: as combinations of multiple functions instead of combinations of arguments. The goal is not to exhaustively list every possible FO, but to show a selection that demonstrate how they work together with other FP techniques. For your own work, youâll need to think about and experiment with how function operators can help you solve recurring problems.</p>
<h5 id="Outline-8"><a href="#Outline-8" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#behavioural-fos">Behavioural FOs</a> introduces you to FOs that change the  behaviour of a function like automatically logging usage to disk or ensuring  that a function is run only once.</li>
<li><a href="#output-fos">Output FOs</a> shows you how to write FOs that manipulate the  output of a function. These can do simple things like capturing errors, or  fundamentally change what the function does.</li>
<li><a href="#input-fos">Input FOs</a> describes how to modify the inputs to a function using  a FO like <code>Vectorize()</code> or <code>partial()</code>.</li>
<li><a href="#combining-fos">Combining FOs</a> shows the power of FOs that combine multiple  functions with function composition and logical operations.</li>
</ul>
<h5 id="Prerequisites-4"><a href="#Prerequisites-4" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><p>As well as writing FOs from scratch, this chapter uses function operators from the memoise, plyr, and pryr packages. Install them by running <code>install.packages(c(&quot;memoise&quot;, &quot;plyr&quot;, &quot;pryr&quot;))</code>.</p>
<!--
### In other languages

Function operators are used extensively in FP languages like Haskell, and commonly in Lisp, Scheme and Clojure. They are also an important part of modern JavaScript programming, like in the [underscore.js](http://underscorejs.org/) library. They are particularly common in CoffeeScript because its syntax for anonymous functions is so concise. In stack-based languages like Forth and Factor, function operators are used almost exclusively because it's rare to refer to variables by name. Python's decorators are just function operators by a [different name](http://stackoverflow.com/questions/739654/). In Java, they are very rare because it's difficult to manipulate functions (although possible if you wrap them up in strategy-type objects). They are also rare in C++ because, while it's possible to create objects that work like functions ("functors") by overloading the `()` operator, modifying these objects with other functions is not a common programming technique. That said, C++ 11 includes partial application (`std::bind`) as part of the standard library.
-->
<h2 id="Behavioural-FOs"><a href="#Behavioural-FOs" class="headerlink" title="Behavioural FOs"></a><a href="id=&quot;behavioural-fos&quot;">Behavioural FOs</a></h2><p>Behavioural FOs leave the inputs and outputs of a function unchanged, but add some extra behaviour. In this section, weâll look at functions which implement three useful behaviours:</p>
<ul>
<li>Add a delay to avoid swamping a server with requests.</li>
<li>Print to console every n invocations to check on a long running process.</li>
<li>Cache previous computations to improve performance.</li>
</ul>
<p>To motivate these behaviours, imagine we want to download a long vector of URLs. Thatâs pretty simple with <code>lapply()</code> and <code>download_file()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">download_file &lt;- function(url, ...) &#123;</span><br><span class="line">  download.file(url, basename(url), ...)</span><br><span class="line">&#125;</span><br><span class="line">lapply(urls, download_file)</span><br></pre></td></tr></table></figure>
<p>(<code>download_file()</code> is a simple wrapper around <code>utils::download.file()</code> which provides a reasonable default for the file name.)</p>
<p>There are a number of useful behaviours we might want to add to this function. If the list was long, we might want to print a <code>.</code> every ten URLs so we know that the functionâs still working. If weâre downloading files over the internet, we might want to add a small delay between each request to avoid hammering the server. Implementing these behaviours in a for loop is rather complicated. We can no longer use <code>lapply()</code> because we need an external counter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i &lt;- 1</span><br><span class="line">for(url in urls) &#123;</span><br><span class="line">  i &lt;- i + 1</span><br><span class="line">  if (i %% 10 == 0) cat(&quot;.&quot;)</span><br><span class="line">  Sys.delay(1)</span><br><span class="line">  download_file(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Understanding this code is hard because different concerns (iteration, printing, and downloading) are interleaved. In the remainder of this section weâll create FOs that encapsulate each behaviour and allow us to write code like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lapply(urls, dot\_every(10, delay\_by(1, download_file)))</span><br></pre></td></tr></table></figure>
<p>Implementing <code>delay_by()</code> is straightforward, and follows the same basic template that weâll see for the majority of FOs in this chapter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">delay_by &lt;- function(delay, f) &#123;</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    Sys.sleep(delay)</span><br><span class="line">    f(...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">system.time(runif(100))</span><br><span class="line">system.time(delay_by(0.1, runif)(100))</span><br></pre></td></tr></table></figure>
<p><code>dot_every()</code> is a little bit more complicated because it needs to manage a counter. Fortunately, we saw how to do that in <a href="#mutable-state">mutable state</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dot_every &lt;- function(n, f) &#123;</span><br><span class="line">  i &lt;- 1</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    if (i %% n == 0) cat(&quot;.&quot;)</span><br><span class="line">    i &lt;&lt;- i + 1</span><br><span class="line">    f(...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">x &lt;- lapply(1:100, runif)</span><br><span class="line">x &lt;- lapply(1:100, dot_every(10, runif))</span><br></pre></td></tr></table></figure>
<p>Notice that Iâve made the function the last argument in each FO. This makes it easier to read when we compose multiple function operators. If the function were the first argument, then instead of:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">download &lt;- dot\_every(10, delay\_by(1, download_file))</span><br></pre></td></tr></table></figure>
<p>weâd have</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">download &lt;- dot\_every(delay\_by(download_file, 1), 10)</span><br></pre></td></tr></table></figure>
<p>Thatâs harder to follow because (e.g.) the argument of <code>dot_every()</code> is far away from its call. This is sometimes called the <a href="http://en.wikipedia.org/wiki/Dagwood_sandwich" target="_blank" rel="external">Dagwood sandwich</a> problem: you have too much filling (too many long arguments) between your slices of bread (parentheses).</p>
<p>Iâve also tried to give the FOs descriptive names: delay by 1 (second), (print a) dot every 10 (invocations). The more clearly the function names used in your code express your intent, the easier it will be for others (including future you) to read and understand the code.</p>
<h3 id="Memoisation"><a href="#Memoisation" class="headerlink" title="Memoisation"></a>Memoisation</h3><p>Another thing you might worry about when downloading multiple files is accidentally downloading the same file multiple times. You could avoid this by calling <code>unique()</code> on the list of input URLs, or manually managing a data structure that mapped the URL to the result. An alternative approach is to use memoisation: modify a function to automatically cache its results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library(memoise)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slow_function &lt;- function(x) &#123;</span><br><span class="line">  Sys.sleep(1)</span><br><span class="line">  10</span><br><span class="line">&#125;</span><br><span class="line">system.time(slow_function())</span><br><span class="line">system.time(slow_function())</span><br><span class="line">fast_function &lt;- memoise(slow_function)</span><br><span class="line">system.time(fast_function())</span><br><span class="line">system.time(fast_function())</span><br></pre></td></tr></table></figure>
<p>Memoisation is an example of the classic computer science tradeoff of memory versus speed. A memoised function can run much faster because it stores all of the previous inputs and outputs, using more memory.</p>
<p>A realistic use of memoisation is computing the Fibonacci series. The Fibonacci series is defined recursively: the first two values are 1 and 1, then f(n) = f(n - 1) + f(n - 2). A naive version implemented in R would be very slow because, for example, <code>fib(10)</code> computes <code>fib(9)</code> and <code>fib(8)</code>, and <code>fib(9)</code> computes <code>fib(8)</code> and <code>fib(7)</code>, and so on. As a result, the value for each value in the series gets computed many, many times. Memoising <code>fib()</code> makes the implementation much faster because each value is computed only once.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fib &lt;- function(n) &#123;</span><br><span class="line">  if (n &lt; 2) return(1)</span><br><span class="line">  fib(n - 2) + fib(n - 1)</span><br><span class="line">&#125;</span><br><span class="line">system.time(fib(23))</span><br><span class="line">system.time(fib(24))</span><br><span class="line"></span><br><span class="line">fib2 &lt;- memoise(function(n) &#123;</span><br><span class="line">  if (n &lt; 2) return(1)</span><br><span class="line">  fib2(n - 2) + fib2(n - 1)</span><br><span class="line">&#125;)</span><br><span class="line">system.time(fib2(23))</span><br><span class="line">system.time(fib2(24))</span><br></pre></td></tr></table></figure>
<p>It doesnât make sense to memoise all functions. For example, a memoised random number generator is no longer random:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runifm &lt;- memoise(runif)</span><br><span class="line">runifm(5)</span><br><span class="line">runifm(5)</span><br></pre></td></tr></table></figure>
<p>Once we understand <code>memoise()</code>, itâs straightforward to apply to our problem:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">download &lt;- dot\_every(10, memoise(delay\_by(1, download\_file)))</span><br></pre></td></tr></table></figure>
<p>This gives a function that we can easily use with <code>lapply()</code>. However, if something goes wrong with the loop inside <code>lapply()</code>, it can be difficult to tell whatâs going on. The next section will show how we can use FOs to pull back the curtain and look inside.</p>
<h3 id="Capturing-function-invocations"><a href="#Capturing-function-invocations" class="headerlink" title="Capturing function invocations"></a><a href="id=&quot;tee&quot;">Capturing function invocations</a></h3><p>One challenge with functionals is that it can be hard to see whatâs going on inside of them. Itâs not easy to pry open their internals like it is with a for loop. Fortunately we can use FOs to peer behind the curtain with <code>tee()</code>.</p>
<p><code>tee()</code>, defined below, has three arguments, all functions: <code>f</code>, the function to modify; <code>on_input</code>, a function thatâs called with the inputs to <code>f</code>; and <code>on_output</code>, a function thatâs called with the output from <code>f</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ignore &lt;- function(...) NULL</span><br><span class="line">tee &lt;- function(f, on_input = ignore, on_output = ignore) &#123;</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    on_input(...)</span><br><span class="line">    output &lt;- f(...)</span><br><span class="line">    on_output(output)</span><br><span class="line">    output</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(The function is inspired by the unix shell command <code>tee</code>, which is used to split up streams of file operations so that you can both display whatâs happening and save intermediate results to a file.)</p>
<p>We can use <code>tee()</code> to look inside the <code>uniroot()</code> functional, and see how it iterates its way to a solution. The following example finds where <code>x</code> and <code>cos(x)</code> intersect:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g &lt;- function(x) cos(x) - x</span><br><span class="line">zero &lt;- uniroot(g, c(-5, 5))</span><br><span class="line">show_x &lt;- function(x, ...) cat(sprintf(&quot;%+.08f&quot;, x), &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line"># The location where the function is evaluated:</span><br><span class="line">zero &lt;- uniroot(tee(g, on_input = show_x), c(-5, 5))</span><br><span class="line"># The value of the function:</span><br><span class="line">zero &lt;- uniroot(tee(g, on_output = show_x), c(-5, 5))</span><br></pre></td></tr></table></figure>
<p><code>cat()</code> allows us to see whatâs happening as the function runs, but it doesnât give us a way to work with the values after the function as completed. To do that, we could capture the sequence of calls by creating a function, <code>remember()</code>, that records every argument called and retrieves them when coerced into a list. The small amount of S3 code needed is explained in <a href="#s3">S3</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">remember &lt;- function() &#123;</span><br><span class="line">  memory &lt;- list()</span><br><span class="line">  f &lt;- function(...) &#123;</span><br><span class="line">    # This is inefficient!</span><br><span class="line">    memory &lt;&lt;- append(memory, list(...))</span><br><span class="line">    invisible()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  structure(f, class = &quot;remember&quot;)</span><br><span class="line">&#125;</span><br><span class="line">as.list.remember &lt;- function(x, ...) &#123;</span><br><span class="line">  environment(x)$memory</span><br><span class="line">&#125;</span><br><span class="line">print.remember &lt;- function(x, ...) &#123;</span><br><span class="line">  cat(&quot;Remembering...\n&quot;)</span><br><span class="line">  str(as.list(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now we can draw a picture showing how uniroot zeroes in on the final answer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">locs &lt;- remember()</span><br><span class="line">vals &lt;- remember()</span><br><span class="line">zero &lt;- uniroot(tee(g, locs, vals), c(-5, 5))</span><br><span class="line">x &lt;- unlist(as.list(locs))</span><br><span class="line">error &lt;- unlist(as.list(vals))</span><br><span class="line">plot(x, type = &quot;b&quot;); abline(h = 0.739, col = &quot;grey50&quot;)</span><br><span class="line">plot(error, type = &quot;b&quot;); abline(h = 0, col = &quot;grey50&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="Laziness"><a href="#Laziness" class="headerlink" title="Laziness"></a>Laziness</h3><p>The function operators weâve seen so far follow a common pattern:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">funop &lt;- function(f, otherargs) &#123;</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    # maybe do something</span><br><span class="line">    res &lt;- f(...)</span><br><span class="line">    # maybe do something else</span><br><span class="line">    res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unfortunately thereâs a problem with this implementation because function arguments are lazily evaluated: <code>f()</code> may have changed between applying the FO and evaluating the function. This is a particular problem if youâre using a for loop or <code>lapply()</code> to apply multiple function operators. In the following example, we take a list of functions and delay each one. But when we try to evaluate the mean, we get the sum instead.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">funs &lt;- list(mean = mean, sum = sum)</span><br><span class="line">funs_m &lt;- lapply(funs, delay_by, delay = 0.1)</span><br><span class="line"></span><br><span class="line">funs_m$mean(1:10)</span><br></pre></td></tr></table></figure>
<p>We can avoid that problem by explicitly forcing the evaluation of <code>f()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delay_by &lt;- function(delay, f) &#123;</span><br><span class="line">  force(f)</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    Sys.sleep(delay)</span><br><span class="line">    f(...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funs_m &lt;- lapply(funs, delay_by, delay = 0.1)</span><br><span class="line">funs_m$mean(1:10)</span><br></pre></td></tr></table></figure>
<p>Itâs good practice to do that whenever you create a new FO.</p>
<h3 id="Exercises-31"><a href="#Exercises-31" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Write a FO that logs a time stamp and message to a file every time a    function is run.</li>
<li><p>What does the following function do? What would be a good name for it?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(g) &#123;</span><br><span class="line">  force(g)</span><br><span class="line">  result &lt;- NULL</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    if (is.null(result)) &#123;</span><br><span class="line">      result &lt;&lt;- g(...)</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">runif2 &lt;- f(runif)</span><br><span class="line">runif2(5)</span><br><span class="line">runif2(10)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Modify <code>delay_by()</code> so that instead of delaying by a fixed amount of time,    it ensures that a certain amount of time has elapsed since the function    was last called. That is, if you called    <code>g &lt;- delay_by(1, f); g(); Sys.sleep(2); g()</code> there shouldnât be an    extra delay.</p>
</li>
<li>Write <code>wait_until()</code> which delays execution until a specific time.</li>
<li><p>There are three places we could have added a memoise call: why did we    choose the one we did?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">download &lt;- memoise(dot_every(10, delay_by(1, download_file)))</span><br><span class="line">download &lt;- dot_every(10, memoise(delay_by(1, download_file)))</span><br><span class="line">download &lt;- dot_every(10, delay_by(1, memoise(download_file)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Why is the <code>remember()</code> function inefficient? How could you implement it    in more efficient way?</p>
</li>
<li><p>Why does the following code, from    <a href="http://stackoverflow.com/questions/8440675" target="_blank" rel="external">stackoverflow</a>, not do what you expect?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># return a linear function with slope a and intercept b.</span><br><span class="line">f &lt;- function(a, b) function(x) a * x + b</span><br><span class="line"></span><br><span class="line"># create a list of functions with different parameters.</span><br><span class="line">fs &lt;- Map(f, a = c(0, 1), b = c(0, 1))</span><br><span class="line"></span><br><span class="line">fs[[1]](3)</span><br><span class="line"># should return 0 * 3 + 0 = 0</span><br></pre></td></tr></table></figure>
<p>How can you modify <code>f</code> so that it works correctly?</p>
</li>
</ol>
<h2 id="Output-FOs"><a href="#Output-FOs" class="headerlink" title="Output FOs"></a><a href="id=&quot;output-fos&quot;">Output FOs</a></h2><p>The next step up in complexity is to modify the output of a function. This could be quite simple, or it could fundamentally change the operation of the function by returning something completely different to its usual output. In this section youâll learn about two simple modifications, <code>Negate()</code> and <code>failwith()</code>, and two fundamental modifications, <code>capture_it()</code> and <code>time_it()</code>.</p>
<h3 id="Minor-modifications"><a href="#Minor-modifications" class="headerlink" title="Minor modifications"></a>Minor modifications</h3><p><code>base::Negate()</code> and <code>plyr::failwith()</code> offer two minor, but useful, modifications of a function that are particularly handy in conjunction with functionals.</p>
<p><code>Negate()</code> takes a function that returns a logical vector (a predicate function), and returns the negation of that function. This can be a useful shortcut when a function returns the opposite of what you need. The essence of <code>Negate()</code> is very simple:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Negate &lt;- function(f) &#123;</span><br><span class="line">  force(f)</span><br><span class="line">  function(...) !f(...)</span><br><span class="line">&#125;</span><br><span class="line">(Negate(is.null))(NULL)</span><br></pre></td></tr></table></figure>
<p>I often use this idea to make a function, <code>compact()</code>, that removes all null elements from a list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compact &lt;- function(x) Filter(Negate(is.null), x)</span><br></pre></td></tr></table></figure>
<p><code>plyr::failwith()</code> turns a function that throws an error into a function that returns a default value when thereâs an error. Again, the essence of <code>failwith()</code> is simple; itâs just a wrapper around <code>try()</code>, the function that captures errors and allows execution to continue.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">failwith &lt;- function(default = NULL, f, quiet = FALSE) &#123;</span><br><span class="line">  force(f)</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    out &lt;- default</span><br><span class="line">    try(out &lt;- f(...), silent = quiet)</span><br><span class="line">    out</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">log(&quot;a&quot;)</span><br><span class="line">failwith(NA, log)(&quot;a&quot;)</span><br><span class="line">failwith(NA, log, quiet = TRUE)(&quot;a&quot;)</span><br></pre></td></tr></table></figure>
<p>(If you havenât seen <code>try()</code> before, itâs discussed in more detail in <a href="#try">exceptions and debugging</a>.)</p>
<p><code>failwith()</code> is very useful in conjunction with functionals: instead of the failure propagating and terminating the higher-level loop, you can complete the iteration and then find out what went wrong. For example, imagine youâre fitting a set of generalised linear models (GLMs) to a list of data frames. While GLMs can sometimes fail because of optimisation problems, youâd still want to be able to try to fit all the models, and later look back at those that failed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># If any model fails, all models fail to fit:</span><br><span class="line">models &lt;- lapply(datasets, glm, formula = y ~ x1 + x2 * x3)</span><br><span class="line"># If a model fails, it will get a NULL value</span><br><span class="line">models &lt;- lapply(datasets, failwith(NULL, glm),</span><br><span class="line">  formula = y ~ x1 + x2 * x3)</span><br><span class="line"></span><br><span class="line"># remove failed models (NULLs) with compact</span><br><span class="line">ok_models &lt;- compact(models)</span><br><span class="line"># extract the datasets corresponding to failed models</span><br><span class="line">failed_data &lt;- datasets[vapply(models, is.null, logical(1))]</span><br></pre></td></tr></table></figure>
<p>I think this is a great example of the power of combining functionals and function operators: it lets you succinctly express what you need to solve a common data analysis problem.</p>
<h3 id="Changing-what-a-function-does"><a href="#Changing-what-a-function-does" class="headerlink" title="Changing what a function does"></a>Changing what a function does</h3><p>Other output function operators can have a more profound effect on the operation of the function. Instead of returning the original return value, we can return some other effect of the function evaluation. Here are two examples:</p>
<ul>
<li><p>Return text that the function <code>print()</code>ed:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">capture_it &lt;- function(f) &#123;</span><br><span class="line">  force(f)</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    capture.output(f(...))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">str_out &lt;- capture_it(str)</span><br><span class="line">str(1:10)</span><br><span class="line">str_out(1:10)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Return how long a function took to run:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">time_it &lt;- function(f) &#123;</span><br><span class="line">  force(f)</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    system.time(f(...))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>time_it()</code> allows us to rewrite some of the code from the functionals chapter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">compute_mean &lt;- list(</span><br><span class="line">  base = function(x) mean(x),</span><br><span class="line">  sum = function(x) sum(x) / length(x)</span><br><span class="line">)</span><br><span class="line">x &lt;- runif(1e6)</span><br><span class="line"></span><br><span class="line"># Previously we used an anonymous function to time execution:</span><br><span class="line"># lapply(compute_mean, function(f) system.time(f(x)))</span><br><span class="line"></span><br><span class="line"># Now we can compose function operators:</span><br><span class="line">call_fun &lt;- function(f, ...) f(...)</span><br><span class="line">lapply(compute_mean, time_it(call_fun), x)</span><br></pre></td></tr></table></figure>
<p>In this example, thereâs not a huge benefit to using function operators, because the composition is simple and weâre applying the same operator to each function. Generally, using function operators is most effective when you are using multiple operators or if the gap between creating them and using them is large.</p>
<h3 id="Exercises-32"><a href="#Exercises-32" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Create a <code>negative()</code> FO that flips the sign of the output of the    function to which it is applied.</li>
<li>The <code>evaluate</code> package makes it easy to capture all the outputs (results,    text, messages, warnings, errors, and plots) from an expression. Create a    function like <code>capture_it()</code> that also captures the warnings and errors    generated by a function.</li>
<li>Create a FO that tracks files created or deleted in the working directory    (Hint: use <code>dir()</code> and <code>setdiff()</code>.) What other global effects of    functions might you want to track?</li>
</ol>
<h2 id="Input-FOs"><a href="#Input-FOs" class="headerlink" title="Input FOs"></a><a href="id=&quot;input-fos&quot;">Input FOs</a></h2><p>The next step up in complexity is to modify the inputs of a function. Again, you can modify how a function works in a minor way (e.g., setting default argument values), or in a major way (e.g., converting inputs from scalars to vectors, or vectors to matrices).</p>
<h3 id="Prefilling-function-arguments-partial-function-application"><a href="#Prefilling-function-arguments-partial-function-application" class="headerlink" title="Prefilling function arguments: partial function application"></a>Prefilling function arguments: partial function application</h3><p>A common use of anonymous functions is to make a variant of a function that has certain arguments âfilled inâ already. This is called âpartial function applicationâ, and is implemented by <code>pryr::partial()</code>. Once you have read <a href="#metaprogramming">metaprogramming</a>, I encourage you to read the source code for <code>partial()</code> and figure out how it works â itâs only 5 lines of code!</p>
<p><code>partial()</code> allows us to replace code like</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(a) g(a, b = 1)</span><br><span class="line">compact &lt;- function(x) Filter(Negate(is.null), x)</span><br><span class="line">Map(function(x, y) f(x, y, zs), xs, ys)</span><br></pre></td></tr></table></figure>
<p>with</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- partial(g, b = 1)</span><br><span class="line">compact &lt;- partial(Filter, Negate(is.null))</span><br><span class="line">Map(partial(f, zs = zs), xs, ys)</span><br></pre></td></tr></table></figure>
<p>We can use this idea to simplify the code used when working with lists of functions. Instead of:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funs2 &lt;- list(</span><br><span class="line">  sum = function(...) sum(..., na.rm = TRUE),</span><br><span class="line">  mean = function(...) mean(..., na.rm = TRUE),</span><br><span class="line">  median = function(...) median(..., na.rm = TRUE)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>we can write:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">library(pryr)</span><br><span class="line">funs2 &lt;- list(</span><br><span class="line">  sum = partial(sum, na.rm = TRUE),</span><br><span class="line">  mean = partial(mean, na.rm = TRUE),</span><br><span class="line">  median = partial(median, na.rm = TRUE)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Using partial function application is a straightforward task in many functional programming languages, but itâs not entirely clear how it should interact with Râs lazy evaluation rules. The approach <code>plyr::partial()</code> takes is to create a function that is as similar as possible to the anonymous function that youâd create by hand. Peter Meilstrup takes a different approach in his <a href="https://github.com/crowding/ptools/" target="_blank" rel="external">ptools package</a>. If youâre interested in the topic, you might want to read about the binary operators he created: <code>%()%</code>, <code>%&gt;&gt;%</code>, and <code>%&lt;&lt;%</code>.</p>
<h3 id="Changing-input-types"><a href="#Changing-input-types" class="headerlink" title="Changing input types"></a>Changing input types</h3><p>Itâs also possible to make a major change to a functionâs input, making a function work with fundamentally different types of data. There are a few existing functions that work along these lines:</p>
<ul>
<li><p><code>base::Vectorize()</code> converts a scalar function to a vector function. It takes    a non-vectorised function and vectorises it with respect to the arguments    specified in the <code>vectorize.args</code> argument. This doesnât give you any    magical performance improvements, but itâs useful if you want a quick and    dirty way of making a vectorised function.     A mildly useful extension to <code>sample()</code> would be to vectorize it with    respect to size. Doing so would allow you to generate multiple samples in    one call.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sample2 &lt;- Vectorize(sample, &quot;size&quot;, SIMPLIFY = FALSE)</span><br><span class="line">str(sample2(1:5, c(1, 1, 3)))</span><br><span class="line">str(sample2(1:5, 5:3))</span><br></pre></td></tr></table></figure>
<p>In this example we have used <code>SIMPLIFY = FALSE</code> to ensure that our newly    vectorised function always returns a list. This is usually what you want.</p>
</li>
<li><p><code>splat()</code> converts a function that takes multiple arguments to a function    that takes a single list of arguments.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">splat &lt;- function (f) &#123;</span><br><span class="line">  force(f)</span><br><span class="line">  function(args) &#123;</span><br><span class="line">    do.call(f, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> This is useful if you want to invoke a function with varying arguments:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(NA, runif(100), 1000)</span><br><span class="line">args &lt;- list(</span><br><span class="line">  list(x),</span><br><span class="line">  list(x, na.rm = TRUE),</span><br><span class="line">  list(x, na.rm = TRUE, trim = 0.1)</span><br><span class="line">)</span><br><span class="line">lapply(args, splat(mean))</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>plyr::colwise()</code> converts a vector function to one that works with data   frames:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">median(mtcars)</span><br><span class="line">median(mtcars$mpg)</span><br><span class="line">plyr::colwise(median)(mtcars)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Exercises-33"><a href="#Exercises-33" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Our previous <code>download()</code> function only downloads a single file. How can    you use <code>partial()</code> and <code>lapply()</code> to create a function that downloads    multiple files at once? What are the pros and cons of using <code>partial()</code> vs.    writing a function by hand?</li>
<li>Read the source code for <code>plyr::colwise()</code>. How does the code work? What    are <code>colwise()</code>âs three main tasks? How could you make <code>colwise()</code> simpler    by implementing each task as a function operator? (Hint: think about    <code>partial()</code>.)</li>
<li>Write FOs that convert a function to return a matrix instead of a data    frame, or a data frame instead of a matrix. If you understand S3,    call them <code>as.data.frame.function()</code> and <code>as.matrix.function()</code>.</li>
<li>Youâve seen five functions that modify a function to change its output    from one form to another. What are they? Draw a table of the various    combinations of types of outputs: what should go in the rows and what    should go in the columns? What function operators might you want to write    to fill in the missing cells? Come up with example use cases.</li>
<li>Look at all the examples of using an anonymous function to partially    apply a function in this and the previous chapter. Replace the anonymous    function with <code>partial()</code>. What do you think of the result? Is it easier or    harder to read?</li>
</ol>
<h2 id="Combining-FOs"><a href="#Combining-FOs" class="headerlink" title="Combining FOs"></a><a href="id=&quot;combining-fos&quot;">Combining FOs</a></h2><p>Besides just operating on single functions, function operators can take multiple functions as input. One simple example of this is <code>plyr::each()</code>. It takes a list of vectorised functions and combines them into a single function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">summaries &lt;- plyr::each(mean, sd, median)</span><br><span class="line">summaries(1:10)</span><br></pre></td></tr></table></figure>
<p>Two more complicated examples are combining functions through composition, or through boolean algebra. These capabilities are the glue that allow us to join multiple functions together.</p>
<h3 id="Function-composition"><a href="#Function-composition" class="headerlink" title="Function composition"></a>Function composition</h3><p>An important way of combining functions is through composition: <code>f(g(x))</code>. Composition takes a list of functions and applies them sequentially to the input. Itâs a replacement for the common pattern of anonymous function that chains multiple functions together to get the result you want:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sapply(mtcars, function(x) length(unique(x)))</span><br></pre></td></tr></table></figure>
<p>A simple version of compose looks like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compose &lt;- function(f, g) &#123;</span><br><span class="line">  function(...) f(g(...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(<code>pryr::compose()</code> provides a more full-featured alternative that can accept multiple functions and is used for the rest of the examples.)</p>
<p>This allows us to write:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sapply(mtcars, compose(length, unique))</span><br></pre></td></tr></table></figure>
<p>Mathematically, function composition is often denoted with the infix operator, o, <code>(f o g)(x)</code>. Haskell, a popular functional programming language, uses <code>.</code> to the same end. In R, we can create our own infix composition function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;%o%&quot; &lt;- compose</span><br><span class="line">sapply(mtcars, length %o% unique)</span><br><span class="line"></span><br><span class="line">sqrt(1 + 8)</span><br><span class="line">compose(sqrt, `+`)(1, 8)</span><br><span class="line">(sqrt %o% `+`)(1, 8)</span><br></pre></td></tr></table></figure>
<p>Compose also allows for a very succinct implementation of <code>Negate</code>, which is just a partially evaluated version of <code>compose()</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Negate &lt;- partial(compose, `!`)</span><br></pre></td></tr></table></figure>
<p>We could implement the population standard deviation with function composition:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">square &lt;- function(x) x^2</span><br><span class="line">deviation &lt;- function(x) x - mean(x)</span><br><span class="line"></span><br><span class="line">sd2 &lt;- sqrt %o% mean %o% square %o% deviation</span><br><span class="line">sd2(1:10)</span><br></pre></td></tr></table></figure>
<p>This type of programming is called tacit or point-free programming. (The term point-free comes from the use of âpointâ to refer to values in topology; this style is also derogatorily known as pointless). In this style of programming, you donât explicitly refer to variables. Instead, you focus on the high-level composition of functions rather than the low-level flow of data. The focus is on whatâs being done, not on objects itâs being done to. Since weâre using only functions and not parameters, we use verbs and not nouns. This style is common in Haskell, and is the typical style in stack based programming languages like Forth and Factor. Itâs not a terribly natural or elegant style in R, but it is fun to play with.</p>
<p><code>compose()</code> is particularly useful in conjunction with <code>partial()</code>, because <code>partial()</code> allows you to supply additional arguments to the functions being composed. One nice side effect of this style of programming is that it keeps a functionâs arguments near its name. This is important because as the size of the chunk of code you have to hold in your head grows code becomes harder to understand.</p>
<p>Below I take the example from the first section of the chapter and modify it to use the two styles of function composition described above. Both results are longer than the original code, but they may be easier to understand because the function and its arguments are closer together. Note that we still have to read them from right to left (bottom to top): the first function called is the last one written. We could define <code>compose()</code> to work in the opposite direction, but in the long run, this is likely to lead to confusion since weâd create a small part of the langugage that reads differently from every other part.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">download &lt;- dot_every(10, memoise(delay_by(1, download_file)))</span><br><span class="line"></span><br><span class="line">download &lt;- pryr::compose(</span><br><span class="line">  partial(dot_every, 10),</span><br><span class="line">  memoise,</span><br><span class="line">  partial(delay_by, 1),</span><br><span class="line">  download_file</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">download &lt;- partial(dot_every, 10) %o%</span><br><span class="line">  memoise %o%</span><br><span class="line">  partial(delay_by, 1) %o%</span><br><span class="line">  download_file</span><br></pre></td></tr></table></figure>
<h3 id="Logical-predicates-and-boolean-algebra"><a href="#Logical-predicates-and-boolean-algebra" class="headerlink" title="Logical predicates and boolean algebra"></a>Logical predicates and boolean algebra</h3><p>When I use <code>Filter()</code> and other functionals that work with logical predicates, I often find myself using anonymous functions to combine multiple conditions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Filter(function(x) is.character(x) || is.factor(x), iris)</span><br></pre></td></tr></table></figure>
<p>As an alternative, we could define function operators that combine logical predicates:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">and &lt;- function(f1, f2) &#123;</span><br><span class="line">  force(f1); force(f2)</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    f1(...) &amp;&amp; f2(...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">or &lt;- function(f1, f2) &#123;</span><br><span class="line">  force(f1); force(f2)</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    f1(...) || f2(...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">not &lt;- function(f) &#123;</span><br><span class="line">  force(f)</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    !f(...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This would allow us to write:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Filter(or(is.character, is.factor), iris)</span><br><span class="line">Filter(not(is.numeric), iris)</span><br></pre></td></tr></table></figure>
<p>And we now have a boolean algebra on functions, not on the results of functions.</p>
<h3 id="Exercises-34"><a href="#Exercises-34" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Implement your own version of <code>compose()</code> using <code>Reduce</code> and <code>%o%</code>. For    bonus points, do it without calling <code>function</code>.</li>
<li>Extend <code>and()</code> and <code>or()</code> to deal with any number of input functions. Can    you do it with <code>Reduce()</code>? Can you keep them lazy (e.g., for <code>and()</code>, the    function returns once it sees the first <code>FALSE</code>)?</li>
<li>Implement the <code>xor()</code> binary operator. Implement it using the existing    <code>xor()</code> function. Implement it as a combination of <code>and()</code> and <code>or()</code>. What    are the advantages and disadvantages of each approach? Also think about    what youâll call the resulting function to avoid a clash with the existing    <code>xor()</code> function, and how you might change the names of <code>and()</code>, <code>not()</code>,    and <code>or()</code> to keep them consistent.</li>
<li>Above, we implemented boolean algebra for functions that return a logical    function. Implement elementary algebra (<code>plus()</code>, <code>minus()</code>, <code>multiply()</code>,    <code>divide()</code>, <code>exponentiate()</code>, <code>log()</code>) for functions that return numeric    vectors.</li>
</ol>
<hr>
<h1 id="Non-standard-evaluation"><a href="#Non-standard-evaluation" class="headerlink" title="Non-standard evaluation"></a><a href="id=&quot;nse&quot;">Non-standard evaluation</a></h1><blockquote>
<p>âFlexibility in syntax, if it does not lead to ambiguity, would seem a<br>reasonable thing to ask of an interactive programming language.â</p>
<p>â Kent Pitman</p>
</blockquote>
<p>R has powerful tools for computing not only on values, but also on the actions that lead to those values. If youâre coming from another programming language, they are one of the most surprising features of R. Consider the following simple snippet of code that plots a sine curve:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- seq(0, 2 * pi, length = 100)</span><br><span class="line">sinx &lt;- sin(x)</span><br><span class="line">plot(x, sinx, type = &quot;l&quot;)</span><br></pre></td></tr></table></figure>
<p>Look at the labels on the axes. How did R know that the variable on the x axis is called <code>x</code> and the variable on the y axis is called <code>sinx</code>? In most programming languages, you can only access the values of a functionâs arguments. In R, you can also access the code used to compute them. This makes it possible to evaluate code in non-standard ways: to use what is known as <strong>non-standard evaluation</strong>, or NSE for short. NSE is particularly useful for functions when doing interactive data analysis because it can dramatically reduce the amount of typing.</p>
<h5 id="Outline-9"><a href="#Outline-9" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#capturing-expressions">Capturing expressions</a> teaches you how to  capture unevaluated expressions using <code>substitute()</code>.</li>
<li><a href="#subset">Non-standard evaluation</a> shows you <code>subset()</code> works with  combining <code>substitute()</code> with <code>eval()</code> to allow you to succinctly select  rows from a data frame.</li>
<li><a href="#scoping-issues">Scoping issues</a> discusses scoping issues specific to  NSE, and will show you how to resolve them.</li>
<li><a href="#calling-from-another-function">Calling from another function</a> shows why  every function that uses NSE should have an escape hatch, a version that  uses regular evaluation.</li>
<li><a href="#substitute">Substitute</a> teaches you how to use <code>substitute()</code> to work  with functions that donât have an escape hatch.</li>
<li><a href="#nse-downsides">The downsides</a> finishes off the chapter with a discussion  of the downsides of NSE.</li>
</ul>
<h5 id="Prerequisites-5"><a href="#Prerequisites-5" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><p>Before reading this chapter, make sure youâre familiar with environments (<a href="#environments">Environments</a>) and lexical scoping (<a href="#lexical-scoping">Lexical scoping</a>). Youâll also need to install the pryr package with <code>install.packages(&quot;pryr&quot;)</code>. Some exercises require the plyr package, which you can install from CRAN with <code>install.packages(&quot;plyr&quot;)</code>.</p>
<h2 id="Capturing-expressions"><a href="#Capturing-expressions" class="headerlink" title="Capturing expressions"></a><a href="id=&quot;capturing-expressions&quot;">Capturing expressions</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_uses(&quot;package:base&quot;, c(&quot;substitute&quot;, &quot;deparse&quot;))</span><br></pre></td></tr></table></figure>
<p><code>substitute()</code> makes non-standard evaluation possible. It looks at a function argument and instead of seeing the value, it sees the code used to compute the value:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) &#123;</span><br><span class="line">  substitute(x)</span><br><span class="line">&#125;</span><br><span class="line">f(1:10)</span><br><span class="line"></span><br><span class="line">x &lt;- 10</span><br><span class="line">f(x)</span><br><span class="line"></span><br><span class="line">y &lt;- 13</span><br><span class="line">f(x + y^2)</span><br></pre></td></tr></table></figure>
<p>For now, we wonât worry about exactly what <code>substitute()</code> returns (thatâs the topic of <a href="#metaprogramming">the following chapter</a>), but weâll call it an expression.</p>
<p><code>substitute()</code> works because function arguments are represented by a special type of object called a <strong>promise</strong>. A promise captures the expression needed to compute the value and the environment in which to compute it. Youâre not normally aware of promises because the first time you access a promise its code is evaluated in its environment, yielding a value.</p>
<p><code>substitute()</code> is often paired with <code>deparse()</code>. That function takes the result of <code>substitute()</code>, an expression, and turns it into a character vector.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g &lt;- function(x) deparse(substitute(x))</span><br><span class="line">g(1:10)</span><br><span class="line">g(x)</span><br><span class="line">g(x + y^2)</span><br></pre></td></tr></table></figure>
<p>There are a lot of functions in Base R that use these ideas. Some use them to avoid quotes:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(ggplot2)</span><br><span class="line"># the same as</span><br><span class="line">library(&quot;ggplot2&quot;)</span><br></pre></td></tr></table></figure>
<p>Other functions, like <code>plot.default()</code>, use them to provide default labels. <code>data.frame()</code> labels variables with the expression used to compute them:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1:4</span><br><span class="line">y &lt;- letters[1:4]</span><br><span class="line">names(data.frame(x, y))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm(x, y)</span><br></pre></td></tr></table></figure>
<p>Weâll learn about the ideas that underlie all these examples by looking at one particularly useful application of NSE: <code>subset()</code>.</p>
<h3 id="Exercises-35"><a href="#Exercises-35" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>One important feature of <code>deparse()</code> to be aware of when programming is that    it can return multiple strings if the input is too long. For example, the    following call produces a vector of length two:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g(a + b + c + d + e + f + g + h + i + j + k + l + m +</span><br><span class="line">  n + o + p + q + r + s + t + u + v + w + x + y + z)</span><br></pre></td></tr></table></figure>
<p>Why does this happen? Carefully read the documentation for <code>?deparse</code>. Can you write a    wrapper around <code>deparse()</code> so that it always returns a single string?</p>
</li>
<li><p>Why does <code>as.Date.default()</code> use <code>substitute()</code> and <code>deparse()</code>?    Why does <code>pairwise.t.test()</code> use them? Read the source code.</p>
</li>
<li><p><code>pairwise.t.test()</code> assumes that <code>deparse()</code> always returns a length one    character vector. Can you construct an input that violates this expectation?    What happens?</p>
</li>
<li><p><code>f()</code>, defined above, just calls <code>substitute()</code>. Why canât we use it    to define <code>g()</code>? In other words, what will the following code return?    First make a prediction. Then run the code and think about the results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) substitute(x)</span><br><span class="line">g &lt;- function(x) deparse(f(x))</span><br><span class="line">g(1:10)</span><br><span class="line">g(x)</span><br><span class="line">g(x + y ^ 2 / z + exp(a * sin(b)))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Non-standard-evaluation-in-subset"><a href="#Non-standard-evaluation-in-subset" class="headerlink" title="Non-standard evaluation in subset"></a><a href="id=&quot;subset&quot;">Non-standard evaluation in subset</a></h2><p>While printing out the code supplied to an argument value can be useful, we can actually do more with the unevaluated code. Take <code>subset()</code>, for example. Itâs a useful interactive shortcut for subsetting data frames: instead of repeating the name of data frame many times, you can save some typing:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sample_df &lt;- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 1, 4, 1))</span><br><span class="line"></span><br><span class="line">subset(sample_df, a &gt;= 4)</span><br><span class="line"># equivalent to:</span><br><span class="line"># sample_df[sample_df$a &gt;= 4, ]</span><br><span class="line"></span><br><span class="line">subset(sample_df, b == c)</span><br><span class="line"># equivalent to:</span><br><span class="line"># sample_df[sample_df$b == sample_df$c, ]</span><br></pre></td></tr></table></figure>
<p><code>subset()</code> is special because it implements different scoping rules: the expressions <code>a &gt;= 4</code> or <code>b == c</code> are evaluated in the specified data frame rather than in the current or global environments. This is the essence of non-standard evaluation.</p>
<p>How does <code>subset()</code> work? Weâve already seen how to capture an argumentâs expression rather than its result, so we just need to figure out how to evaluate that expression in the right context. Specifically, we want <code>x</code> to be interpreted as <code>sample_df$x</code>, not <code>globalenv()$x</code>. To do this, we need <code>eval()</code>. This function takes an expression and evaluates it in the specified environment.</p>
<p>Before we can explore <code>eval()</code>, we need one more useful function: <code>quote()</code>. It captures an unevaluated expression like <code>substitute()</code>, but doesnât do any of the advanced transformations that can make <code>substitute()</code> confusing. <code>quote()</code> always returns its input as is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quote(1:10)</span><br><span class="line">quote(x)</span><br><span class="line">quote(x + y^2)</span><br></pre></td></tr></table></figure>
<p>We need <code>quote()</code> to experiment with <code>eval()</code> because <code>eval()</code>âs first argument is an expression. So if you only provide one argument, it will evaluate the expression in the current environment. This makes <code>eval(quote(x))</code> exactly equivalent to <code>x</code>, regardless of what <code>x</code> is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eval(quote(x &lt;- 1))</span><br><span class="line">eval(quote(x))</span><br><span class="line"></span><br><span class="line">eval(quote(y))</span><br></pre></td></tr></table></figure>
<p><code>quote()</code> and <code>eval()</code> are opposites. In the example below, each <code>eval()</code> peels off one layer of <code>quote()</code>âs.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">quote(2 + 2)</span><br><span class="line">eval(quote(2 + 2))</span><br><span class="line"></span><br><span class="line">quote(quote(2 + 2))</span><br><span class="line">eval(quote(quote(2 + 2)))</span><br><span class="line">eval(eval(quote(quote(2 + 2))))</span><br></pre></td></tr></table></figure>
<p><code>eval()</code>âs second argument specifies the environment in which the code is executed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 10</span><br><span class="line">eval(quote(x))</span><br><span class="line"></span><br><span class="line">e &lt;- new.env()</span><br><span class="line">e$x &lt;- 20</span><br><span class="line">eval(quote(x), e)</span><br></pre></td></tr></table></figure>
<p>Because lists and data frames bind names to values in a similar way to environments, <code>eval()</code>âs second argument need not be limited to an environment: it can also be a list or a data frame.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval(quote(x), list(x = 30))</span><br><span class="line">eval(quote(x), data.frame(x = 40))</span><br></pre></td></tr></table></figure>
<p>This gives us one part of <code>subset()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval(quote(a &gt;= 4), sample_df)</span><br><span class="line">eval(quote(b == c), sample_df)</span><br></pre></td></tr></table></figure>
<p>A common mistake when using <code>eval()</code> is to forget to quote the first argument. Compare the results below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- 10</span><br><span class="line">eval(quote(a), sample_df)</span><br><span class="line">eval(a, sample_df)</span><br><span class="line"></span><br><span class="line">eval(quote(b), sample_df)</span><br><span class="line">eval(b, sample_df)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm(a)</span><br></pre></td></tr></table></figure>
<p>We can use <code>eval()</code> and <code>substitute()</code> to write <code>subset()</code>. We first capture the call representing the condition, then we evaluate it in the context of the data frame and, finally, we use the result for subsetting:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">subset2 &lt;- function(x, condition) &#123;</span><br><span class="line">  condition_call &lt;- substitute(condition)</span><br><span class="line">  r &lt;- eval(condition_call, x)</span><br><span class="line">  x[r, ]</span><br><span class="line">&#125;</span><br><span class="line">subset2(sample_df, a &gt;= 4)</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-36"><a href="#Exercises-36" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>Predict the results of the following lines of code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval(quote(eval(quote(eval(quote(2 + 2))))))</span><br><span class="line">eval(eval(quote(eval(quote(eval(quote(2 + 2)))))))</span><br><span class="line">quote(eval(quote(eval(quote(eval(quote(2 + 2)))))))</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>subset2()</code> has a bug if you use it with a single column data frame.    What should the following code return? How can you modify <code>subset2()</code>    so it returns the correct type of object?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sample_df2 &lt;- data.frame(x = 1:10)</span><br><span class="line">subset2(sample_df2, x &gt; 8)</span><br></pre></td></tr></table></figure>
</li>
<li><p>The real subset function (<code>subset.data.frame()</code>) removes missing    values in the condition. Modify <code>subset2()</code> to do the same: drop the    offending rows.</p>
</li>
<li>What happens if you use <code>quote()</code> instead of <code>substitute()</code> inside of    <code>subset2()</code>?</li>
<li><p>The second argument in <code>subset()</code> allows you to select variables. It    treats variable names as if they were positions. This allows you to do    things like <code>subset(mtcars, , -cyl)</code> to drop the cylinder variable, or    <code>subset(mtcars, , disp:drat)</code> to select all the variables between <code>disp</code>    and <code>drat</code>. How does this work? Iâve made this easier to understand by    extracting it out into its own function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select &lt;- function(df, vars) &#123;</span><br><span class="line">  vars &lt;- substitute(vars)</span><br><span class="line">  var_pos &lt;- setNames(as.list(seq_along(df)), names(df))</span><br><span class="line">  pos &lt;- eval(vars, var_pos)</span><br><span class="line">  df[, pos, drop = FALSE]</span><br><span class="line">&#125;</span><br><span class="line">select(mtcars, -cyl)</span><br></pre></td></tr></table></figure>
</li>
<li><p>What does <code>evalq()</code> do? Use it to reduce the amount of typing for the    examples above that use both <code>eval()</code> and <code>quote()</code>.</p>
</li>
</ol>
<h2 id="Scoping-issues"><a href="#Scoping-issues" class="headerlink" title="Scoping issues"></a><a href="id=&quot;scoping-issues&quot;">Scoping issues</a></h2><p>It certainly looks like our <code>subset2()</code> function works. But since weâre working with expressions instead of values, we need to test things more extensively. For example, the following applications of <code>subset2()</code> should all return the same value because the only difference between them is the name of a variable:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">y &lt;- 4</span><br><span class="line">x &lt;- 4</span><br><span class="line">condition &lt;- 4</span><br><span class="line">condition_call &lt;- 4</span><br><span class="line"></span><br><span class="line">subset2(sample_df, a == 4)</span><br><span class="line">subset2(sample_df, a == y)</span><br><span class="line">subset2(sample_df, a == x)</span><br><span class="line">subset2(sample_df, a == condition)</span><br><span class="line">subset2(sample_df, a == condition_call)</span><br></pre></td></tr></table></figure>
<p>What went wrong? You can get a hint from the variable names Iâve chosen: they are all names of variables defined inside <code>subset2()</code>. If <code>eval()</code> canât find the variable inside the data frame (its second argument), it looks in the environment of <code>subset2()</code>. Thatâs obviously not what we want, so we need some way to tell <code>eval()</code> where to look if it canât find the variables in the data frame.</p>
<p>The key is the third argument to <code>eval()</code>: <code>enclos</code>. This allows us to specify a parent (or enclosing) environment for objects that donât have one (like lists and data frames). If the binding is not found in <code>env</code>, <code>eval()</code> will next look in <code>enclos</code>, and then in the parents of <code>enclos</code>. <code>enclos</code> is ignored if <code>env</code> is a real environment. We want to look for <code>x</code> in the environment from which <code>subset2()</code> was called. In R terminology this is called the <strong>parent frame</strong> and is accessed with <code>parent.frame()</code>. This is an example of <a href="http://en.wikipedia.org/wiki/Scope_%28programming%29#Dynamic_scoping" target="_blank" rel="external">dynamic scope</a>: the values come from the location where the function was called, not where it was defined.</p>
<p>With this modification our function now works:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subset2 &lt;- function(x, condition) &#123;</span><br><span class="line">  condition_call &lt;- substitute(condition)</span><br><span class="line">  r &lt;- eval(condition_call, x, parent.frame())</span><br><span class="line">  x[r, ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x &lt;- 4</span><br><span class="line">subset2(sample_df, a == x)</span><br></pre></td></tr></table></figure>
<p>Using <code>enclos</code> is just a shortcut for converting a list or data frame to an environment. We can get the same behaviour by using <code>list2env()</code>. It turns a list into an environment with an explicit parent:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">subset2a &lt;- function(x, condition) &#123;</span><br><span class="line">  condition_call &lt;- substitute(condition)</span><br><span class="line">  env &lt;- list2env(x, parent = parent.frame())</span><br><span class="line">  r &lt;- eval(condition_call, env)</span><br><span class="line">  x[r, ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x &lt;- 5</span><br><span class="line">subset2a(sample_df, a == x)</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-37"><a href="#Exercises-37" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><code>plyr::arrange()</code> works similarly to <code>subset()</code>, but instead of selecting    rows, it reorders them. How does it work? What does    <code>substitute(order(...))</code> do? Create a function that does only that    and experiment with it.</li>
<li>What does <code>transform()</code> do? Read the documentation. How does it work?    Read the source code for <code>transform.data.frame()</code>. What does    <code>substitute(list(...))</code> do?</li>
<li><p><code>plyr::mutate()</code> is similar to <code>transform()</code> but it applies the    transformations sequentially so that transformation can refer to columns    that were just created:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(x = 1:5)</span><br><span class="line">transform(df, x2 = x * x, x3 = x2 * x)</span><br><span class="line">plyr::mutate(df, x2 = x * x, x3 = x2 * x)</span><br></pre></td></tr></table></figure>
<p>How does mutate work? Whatâs the key difference between <code>mutate()</code> and    <code>transform()</code>?</p>
</li>
<li><p>What does <code>with()</code> do? How does it work? Read the source code for    <code>with.default()</code>. What does <code>within()</code> do? How does it work? Read the    source code for <code>within.data.frame()</code>. Why is the code so much more    complex than <code>with()</code>?</p>
</li>
</ol>
<h2 id="Calling-from-another-function"><a href="#Calling-from-another-function" class="headerlink" title="Calling from another function"></a><a href="id=&quot;calling-from-another-function&quot;">Calling from another function</a></h2><p>Typically, computing on the language is most useful when functions are called directly by users and less useful when they are called by other functions. While <code>subset()</code> saves typing, itâs actually difficult to use non-interactively. For example, imagine we want to create a function that randomly reorders a subset of rows of data. A nice way to do that would be to compose a function that reorders with another that selects. Letâs try that:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">subset2 &lt;- function(x, condition) &#123;</span><br><span class="line">  condition_call &lt;- substitute(condition)</span><br><span class="line">  r &lt;- eval(condition_call, x, parent.frame())</span><br><span class="line">  x[r, ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scramble &lt;- function(x) x[sample(nrow(x)), ]</span><br><span class="line"></span><br><span class="line">subscramble &lt;- function(x, condition) &#123;</span><br><span class="line">  scramble(subset2(x, condition))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>But it doesnât work:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subscramble(sample_df, a &gt;= 4)</span><br><span class="line"># Error in eval(expr, envir, enclos) : object &apos;a&apos; not found</span><br><span class="line">traceback()</span><br><span class="line">#&gt; 5: eval(expr, envir, enclos)</span><br><span class="line">#&gt; 4: eval(condition_call, x, parent.frame()) at #3</span><br><span class="line">#&gt; 3: subset2(x, condition) at #1</span><br><span class="line">#&gt; 2: scramble(subset2(x, condition)) at #2</span><br><span class="line">#&gt; 1: subscramble(sample_df, a &gt;= 4)</span><br></pre></td></tr></table></figure>
<p>Whatâs gone wrong? To figure it out, let us <code>debug()</code> <code>subset2()</code> and work through the code line-by-line:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">debugonce(subset2)</span><br><span class="line">subscramble(sample_df, a &gt;= 4)</span><br><span class="line">#&gt; debugging in: subset2(x, condition)</span><br><span class="line">#&gt; debug at #1: &#123;</span><br><span class="line">#&gt;     condition_call &lt;- substitute(condition)</span><br><span class="line">#&gt;     r &lt;- eval(condition_call, x, parent.frame())</span><br><span class="line">#&gt;     x[r, ]</span><br><span class="line">#&gt; &#125;</span><br><span class="line">n</span><br><span class="line">#&gt; debug at #2: condition_call &lt;- substitute(condition)</span><br><span class="line">n</span><br><span class="line">#&gt; debug at #3: r &lt;- eval(condition_call, x, parent.frame())</span><br><span class="line">r &lt;- eval(condition_call, x, parent.frame())</span><br><span class="line">#&gt; Error in eval(expr, envir, enclos) : object &apos;a&apos; not found</span><br><span class="line">condition_call</span><br><span class="line">#&gt; condition</span><br><span class="line">eval(condition_call, x)</span><br><span class="line">#&gt; Error in eval(expr, envir, enclos) : object &apos;a&apos; not found</span><br><span class="line">Q</span><br></pre></td></tr></table></figure>
<p>Can you see what the problem is? <code>condition_call</code> contains the expression <code>condition</code>. So when we evaluate <code>condition_call</code> it also evaluates <code>condition</code>, which has the value <code>a &gt;= 4</code>. However, this canât be computed because thereâs no object called <code>a</code> in the parent environment. But, if <code>a</code> were set in the global environment, even more confusing things can happen:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- 4</span><br><span class="line">subscramble(sample_df, a == 4)</span><br><span class="line"></span><br><span class="line">a &lt;- c(1, 1, 4, 4, 4, 4)</span><br><span class="line">subscramble(sample_df, a &gt;= 4)</span><br></pre></td></tr></table></figure>
<p>This is an example of the general tension between functions that are designed for interactive use and functions that are safe to program with. A function that uses <code>substitute()</code> might reduce typing, but it can be difficult to call from another function.</p>
<p>As a developer, you should always provide an escape hatch: an alternative version of the function that uses standard evaluation. In this case, we could write a version of <code>subset2()</code> that takes an already quoted expression:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subset2_q &lt;- function(x, condition) &#123;</span><br><span class="line">  r &lt;- eval(condition, x, parent.frame())</span><br><span class="line">  x[r, ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here I use the suffix <code>_q</code> to indicate that it takes a quoted expression. Most users wonât need this function so the name can be a little longer.</p>
<p>We can then rewrite both <code>subset2()</code> and <code>subscramble()</code> to use <code>subset2_q()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">subset2 &lt;- function(x, condition) &#123;</span><br><span class="line">  subset2_q(x, substitute(condition))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subscramble &lt;- function(x, condition) &#123;</span><br><span class="line">  condition &lt;- substitute(condition)</span><br><span class="line">  scramble(subset2_q(x, condition))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subscramble(sample_df, a &gt;= 3)</span><br><span class="line">subscramble(sample_df, a &gt;= 3)</span><br></pre></td></tr></table></figure>
<p>Base R functions tend to use a different sort of escape hatch. They often have an argument that turns off NSE. For example, <code>require()</code> has <code>character.only = TRUE</code>. I donât think itâs a good idea to use an argument to change the behaviour of another argument because it makes function calls harder to understand.</p>
<h3 id="Exercises-38"><a href="#Exercises-38" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>The following R functions all use NSE. For each, describe how it uses NSE,    and read the documentation to determine its escape hatch.</p>
<ul>
<li><code>rm()</code></li>
<li><code>library()</code> and <code>require()</code></li>
<li><code>substitute()</code></li>
<li><code>data()</code></li>
<li><code>data.frame()</code></li>
</ul>
</li>
<li><p>Base functions <code>match.fun()</code>, <code>page()</code>, and <code>ls()</code> all try to    automatically determine whether you want standard or non-standard    evaluation. Each uses a different approach. Figure out the essence    of each approach then compare and contrast.</p>
</li>
<li>Add an escape hatch to <code>plyr::mutate()</code> by splitting it into two functions.    One function should capture the unevaluated inputs. The other should take a    data frame and list of expressions and perform the computation.</li>
<li>Whatâs the escape hatch for <code>ggplot2::aes()</code>? What about <code>plyr::.()</code>?    What do they have in common? What are the advantages and disadvantages    of their differences?</li>
<li><p>The version of <code>subset2_q()</code> I presented is a simplification of real    code. Why is the following version better?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subset2_q &lt;- function(x, cond, env = parent.frame()) &#123;</span><br><span class="line">  r &lt;- eval(cond, x, env)</span><br><span class="line">  x[r, ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rewrite <code>subset2()</code> and <code>subscramble()</code> to use this improved version.</p>
</li>
</ol>
<h2 id="Substitute"><a href="#Substitute" class="headerlink" title="Substitute"></a><a href="id=&quot;substitute&quot;">Substitute</a></h2><p>Most functions that use non-standard evaluation provide an escape hatch. But what happens if you want to call a function that doesnât have one? For example, imagine you want to create a lattice graphic given the names of two variables:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">library(lattice)</span><br><span class="line">xyplot(mpg ~ disp, data = mtcars)</span><br><span class="line"></span><br><span class="line">x &lt;- quote(mpg)</span><br><span class="line">y &lt;- quote(disp)</span><br><span class="line">xyplot(x ~ y, data = mtcars)</span><br></pre></td></tr></table></figure>
<p>We might turn to <code>substitute()</code> and use it for another purpose: to modify an expression. Unfortunately <code>substitute()</code> has a feature that makes modifying calls interactively a bit of a pain. When run from the global environment, it never does substitutions: in fact, in this situation it behaves just like <code>quote()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- 1</span><br><span class="line">b &lt;- 2</span><br><span class="line">substitute(a + b + z)</span><br><span class="line">#&gt; a + b + z</span><br></pre></td></tr></table></figure>
<p>However, if you run it inside a function, <code>substitute()</code> does substitute and leaves everything else as is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function() &#123;</span><br><span class="line">  a &lt;- 1</span><br><span class="line">  b &lt;- 2</span><br><span class="line">  substitute(a + b + z)</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>To make it easier to experiment with <code>substitute()</code>, <code>pryr</code> provides the <code>subs()</code> function. It works exactly the same way as <code>substitute()</code> except it has a shorter name and it works in the global environment. These two features make experimentation easier:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- 1</span><br><span class="line">b &lt;- 2</span><br><span class="line">subs(a + b + z)</span><br></pre></td></tr></table></figure>
<p>The second argument (of both <code>subs()</code> and <code>substitute()</code>) can override the use of the current environment, and provide an alternative via a list of name-value pairs. The following example uses this technique to show some variations on substituting a string, variable name, or function call:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subs(a + b, list(a = &quot;y&quot;))</span><br><span class="line">subs(a + b, list(a = quote(y)))</span><br><span class="line">subs(a + b, list(a = quote(y())))</span><br></pre></td></tr></table></figure>
<p>Remember that every action in R is a function call, so we can also replace <code>+</code> with another function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subs(a + b, list(&quot;+&quot; = quote(f)))</span><br><span class="line">subs(a + b, list(&quot;+&quot; = quote(`*`)))</span><br></pre></td></tr></table></figure>
<p>You can also make nonsense code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subs(y &lt;- y + 1, list(y = 1))</span><br></pre></td></tr></table></figure>
<p>Formally, substitution takes place by examining all the names in the expression. If the name refers to:</p>
<ol>
<li>an ordinary variable, itâs replaced by the value of the variable.</li>
<li>a promise (a function argument), itâs replaced by the expression associated  with the promise.</li>
<li><code>...</code>, itâs replaced by the contents of <code>...</code>.</li>
</ol>
<p>Otherwise itâs left as is.</p>
<p>We can use this to create the right call to <code>xyplot()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- quote(mpg)</span><br><span class="line">y &lt;- quote(disp)</span><br><span class="line">subs(xyplot(x ~ y, data = mtcars))</span><br></pre></td></tr></table></figure>
<p>Itâs even simpler inside a function, because we donât need to explicitly quote the x and y variables (rule 2 above):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xyplot2 &lt;- function(x, y, data = data) &#123;</span><br><span class="line">  substitute(xyplot(x ~ y, data = data))</span><br><span class="line">&#125;</span><br><span class="line">xyplot2(mpg, disp, data = mtcars)</span><br></pre></td></tr></table></figure>
<p>If we include <code>...</code> in the call to substitute, we can add additional arguments to the call:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xyplot3 &lt;- function(x, y, ...) &#123;</span><br><span class="line">  substitute(xyplot(x ~ y, ...))</span><br><span class="line">&#125;</span><br><span class="line">xyplot3(mpg, disp, data = mtcars, col = &quot;red&quot;, aspect = &quot;xy&quot;)</span><br></pre></td></tr></table></figure>
<p>To create the plot, weâd then <code>eval()</code> this call.</p>
<h3 id="Adding-an-escape-hatch-to-substitute"><a href="#Adding-an-escape-hatch-to-substitute" class="headerlink" title="Adding an escape hatch to substitute"></a>Adding an escape hatch to substitute</h3><p><code>substitute()</code> is itself a function that uses non-standard evaluation and doesnât have an escape hatch. This means we canât use <code>substitute()</code> if we already have an expression saved in a variable:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- quote(a + b)</span><br><span class="line">substitute(x, list(a = 1, b = 2))</span><br></pre></td></tr></table></figure>
<p>Although <code>substitute()</code> doesnât have a built-in escape hatch, we can use the function itself to create one:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">substitute_q &lt;- function(x, env) &#123;</span><br><span class="line">  call &lt;- substitute(substitute(y, env), list(y = x))</span><br><span class="line">  eval(call)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x &lt;- quote(a + b)</span><br><span class="line">substitute_q(x, list(a = 1, b = 2))</span><br></pre></td></tr></table></figure>
<p>The implementation of <code>substitute_q()</code> is short, but deep. Letâs work through the example above: <code>substitute_q(x, list(a = 1, b = 2))</code>. Itâs a little tricky because <code>substitute()</code> uses NSE so we canât use the usual technique of working through the parentheses inside-out.</p>
<ol>
<li>First <code>substitute(substitute(y, env), list(y = x))</code> is evaluated.    The expression <code>substitute(y, env)</code> is captured and <code>y</code> is replaced by the    value of <code>x</code>. Because weâve put <code>x</code> inside a list, it will be evaluated and    the rules of substitute will replace <code>y</code> with its value. This yields the    expression <code>substitute(a + b, env)</code></li>
<li>Next we evaluate that expression inside the current function.    <code>substitute()</code> evaluates its first argument, and looks for name    value pairs in <code>env</code>. Here, it evaluates as <code>list(a = 1, b = 2)</code>. Since    these are both values (not promises), the result will be <code>1 + 2</code></li>
</ol>
<p>A slightly more rigorous version of <code>substitute_q()</code> is provided by the pryr package.</p>
<h3 id="Capturing-unevaluated-â¦"><a href="#Capturing-unevaluated-â¦" class="headerlink" title="Capturing unevaluated â¦"></a><a href="id=&quot;capturing-dots&quot;">Capturing unevaluated â¦</a></h3><p>Another useful technique is to capture all of the unevaluated expressions in <code>...</code>. Base R functions do this in many ways, but thereâs one technique that works well across a wide variety of situations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dots &lt;- function(...) &#123;</span><br><span class="line">  eval(substitute(alist(...)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This uses the <code>alist()</code> function which simply captures all its arguments. This function is the same as <code>pryr::dots()</code>. Pryr also provides <code>pryr::named_dots()</code>, which, by using deparsed expressions as default names, ensures that all arguments are named (just like <code>data.frame()</code>).</p>
<h3 id="Exercises-39"><a href="#Exercises-39" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>Use <code>subs()</code> to convert the LHS to the RHS for each of the following pairs:</p>
<ul>
<li><code>a + b + c</code> -&gt; <code>a * b * c</code></li>
<li><code>f(g(a, b), c)</code> -&gt; <code>(a + b) * c</code></li>
<li><code>f(a &lt; b, c, d)</code> -&gt; <code>if (a &lt; b) c else d</code></li>
</ul>
</li>
<li><p>For each of the following pairs of expressions, describe why you canât    use <code>subs()</code> to convert one to the other.</p>
<ul>
<li><code>a + b + c</code> -&gt; <code>a + b * c</code></li>
<li><code>f(a, b)</code> -&gt; <code>f(a, b, c)</code></li>
<li><code>f(a, b, c)</code> -&gt; <code>f(a, b)</code></li>
</ul>
</li>
<li><p>How does <code>pryr::named_dots()</code> work? Read the source.</p>
</li>
</ol>
<h2 id="The-downsides-of-non-standard-evaluation"><a href="#The-downsides-of-non-standard-evaluation" class="headerlink" title="The downsides of non-standard evaluation"></a><a href="id=&quot;nse-downsides&quot;">The downsides of non-standard evaluation</a></h2><p>The biggest downside of NSE is that functions that use it are no longer <a href="http://en.wikipedia.org/wiki/Referential_transparency_(computer_science" target="_blank" rel="external">referentially transparent</a>). A function is <strong>referentially transparent</strong> if you can replace its arguments with their values and its behaviour doesnât change. For example, if a function, <code>f()</code>, is referentially transparent and both <code>x</code> and <code>y</code> are 10, then <code>f(x)</code>, <code>f(y)</code>, and <code>f(10)</code> will all return the same result. Referentially transparent code is easier to reason about because the names of objects donât matter, and because you can always work from the innermost parentheses outwards.</p>
<p>There are many important functions that by their very nature are not referentially transparent. Take the assignment operator. You canât take <code>a &lt;- 1</code> and replace <code>a</code> by its value and get the same behaviour. This is one reason that people usually write assignments at the top-level of functions. Itâs hard to reason about code like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- 1</span><br><span class="line">b &lt;- 2</span><br><span class="line">if ((b &lt;- a + 1) &gt; (a &lt;- b - 1)) &#123;</span><br><span class="line">  b &lt;- b + 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using NSE prevents a function from being referentially transparent. This makes the mental model needed to correctly predict the output much more complicated. So, itâs only worthwhile to use NSE if there is significant gain. For example, <code>library()</code> and <code>require()</code> can be called either with or without quotes, because internally they use <code>deparse(substitute(x))</code> plus some other tricks. This means that these two lines do exactly the same thing:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library(ggplot2)</span><br><span class="line">library(&quot;ggplot2&quot;)</span><br></pre></td></tr></table></figure>
<p>Things start to get complicated if the variable is associated with a value. What package will this load?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ggplot2 &lt;- &quot;plyr&quot;</span><br><span class="line">library(ggplot2)</span><br></pre></td></tr></table></figure>
<p>There are a number of other R functions that work in this way, like <code>ls()</code>, <code>rm()</code>, <code>data()</code>, <code>demo()</code>, <code>example()</code>, and <code>vignette()</code>. To me, eliminating two keystrokes is not worth the loss of referential transparency, and I donât recommend you use NSE for this purpose.</p>
<p>One situation where non-standard evaluation is worthwhile is <code>data.frame()</code>. If not explicitly supplied, it uses the input to automatically name the output variables:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 10</span><br><span class="line">y &lt;- &quot;a&quot;</span><br><span class="line">df &lt;- data.frame(x, y)</span><br><span class="line">names(df)</span><br></pre></td></tr></table></figure>
<p>I think itâs worthwhile because it eliminates a lot of redundancy in the common scenario when youâre creating a data frame from existing variables. More importantly, if needed, itâs easy to override this behaviour by supplying names for each variable.</p>
<p>Non-standard evaluation allows you to write functions that are extremely powerful. However, they are harder to understand and to program with. As well as always providing an escape hatch, carefully consider both the costs and benefits of NSE before using it in a new domain.</p>
<hr>
<p>Add!</p>
<h2 id="Formulas"><a href="#Formulas" class="headerlink" title="Formulas"></a>Formulas</h2><p>There is one other important tool of non-standard evaluation: the formula. The formula operator, <code>~</code>, is used extensively by modelling functions, but also by some graphics functions (e.g. lattice and <code>plot</code>) and a few data manipulation functions (e.g. <code>xtabs()</code> and <code>aggregate()</code>).</p>
<h2 id="Formula-as-a-quoting-function"><a href="#Formula-as-a-quoting-function" class="headerlink" title="Formula as a quoting function"></a>Formula as a quoting function</h2><p>There are two advantages for using <code>~</code> over <code>quote()</code>:</p>
<ul>
<li>It is shorter</li>
<li>It captures both the expression and the environment in which it was evaluated</li>
</ul>
<p>The disadvantage of using <code>~</code> is that most people are used to its role in models, and may be surprised if the semantics you imply from it are substantially different from standard modelling formulas.</p>
<p>The formula object is a call that knows in which environment it was evaluated. You can use <code>length()</code> to determine if it is one-sided or two-sided, and <code>[[</code> to extract the various pieces.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f1 &lt;- ~ a + b</span><br><span class="line">length(f1)</span><br><span class="line">f1[[<span class="number">1</span>]]</span><br><span class="line">f1[[<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">f2 &lt;- y ~ a + b</span><br><span class="line">length(f2)</span><br><span class="line">f2[[<span class="number">1</span>]]</span><br><span class="line">f2[[<span class="number">2</span>]]</span><br><span class="line">f2[[<span class="number">3</span>]]</span><br></pre></td></tr></table></figure>
<p>You can extract the environment of a formula with <code>environment()</code>, as demonstrated with this implementation of <code>subset()</code>:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">subset_f &lt;- <span class="keyword">function</span>(x, f) &#123;</span><br><span class="line">  stopifnot(inherits(f, <span class="string">"formula"</span>), length(f) == <span class="number">2</span>)</span><br><span class="line">  r &lt;- eval(f[[<span class="number">2</span>]], x, environment(f))</span><br><span class="line">  x[r, ]</span><br><span class="line">&#125;</span><br><span class="line">subset_f(mtcars, ~ cyl == <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>Note that because the code is evaluated in the environment associated with the formula, the semantics are a little different if youâre creating the formula in a function:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- <span class="keyword">function</span>(x) ~ cyl == x</span><br><span class="line">subset_f(mtcars, f(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h3 id="xtabs"><a href="#xtabs" class="headerlink" title="xtabs()"></a><code>xtabs()</code></h3><p>Is a pretty horrible example because of itâs combination of call mangling and tangles with sparse matrices.</p>
<h2 id="Formulas-for-modelling"><a href="#Formulas-for-modelling" class="headerlink" title="Formulas for modelling"></a>Formulas for modelling</h2><p>Keep it brief: focus on main concepts (possibly showing complete lm implmentation using Rcpp), and pointing to documentation where necessary.  Need to discuss specials (e.g. offset/Error) and how splines work?</p>
<p>White book.</p>
<p>Patsy: <a href="http://patsy.readthedocs.org/en/latest/R-comparison.html" target="_blank" rel="external">http://patsy.readthedocs.org/en/latest/R-comparison.html</a></p>
<p>Formula package (<a href="http://cran.r-project.org/web/packages/Formula/vignettes/Formula.pdf" target="_blank" rel="external">http://cran.r-project.org/web/packages/Formula/vignettes/Formula.pdf</a>)</p>
<p>Models use two steps: first converting the formula into matrices, and then manipulating using matrix algebra.</p>
<ul>
<li>RcppEigen:::fastLm.formula</li>
<li><a href="http://developer.r-project.org/model-fitting-functions.txt" target="_blank" rel="external">http://developer.r-project.org/model-fitting-functions.txt</a></li>
<li>terms, terms.object, terms.formula</li>
<li>model.response, model.weights</li>
<li>model.matrix, model.frame</li>
<li>lm.fit</li>
</ul>
<hr>
<h3 id="Exercises-40"><a href="#Exercises-40" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>What does the following function do? Whatâs the escape hatch?    Do you think that this is an appropriate use of NSE?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nl &lt;- function(...) &#123;</span><br><span class="line">  dots &lt;- named_dots(...)</span><br><span class="line">  lapply(dots, eval, parent.frame())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Instead of relying on promises, you can use formulas created with <code>~</code>    to explicitly capture an expression and its environment. What are the    advantages and disadvantages of making quoting explicit? How does it    impact referential transparency?</p>
</li>
<li>Read the standard non-standard evaluation rules found at    <a href="http://developer.r-project.org/nonstandard-eval.pdf" target="_blank" rel="external">http://developer.r-project.org/nonstandard-eval.pdf</a>.</li>
</ol>
<hr>
<h1 id="Expressions"><a href="#Expressions" class="headerlink" title="Expressions"></a><a href="id=&quot;metaprogramming&quot;">Expressions</a></h1><p>In <a href="#nse">non-standard evaluation</a>, you learned the basics of accessing and evaluating the expressions underlying computation in R. In this chapter, youâll learn how to manipulate these expressions with code. Youâre going to learn how to metaprogram: how to create programs with other programs!</p>
<h5 id="Outline-10"><a href="#Outline-10" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#structure-of-expressions">Structure of expressions</a> begins with a deep  dive into the structure of expressions. Youâll learn about the four  components of an expression: constants, names, calls, and pairlists.</li>
<li><a href="#names">Names</a> goes into further details about names.</li>
<li><a href="#calls">Calls</a> gives more details about calls.</li>
<li><a href="#capturing-call">Capturing the current call</a> takes a minor detour to  discuss some common uses of calls in base R.</li>
<li><a href="#pairlists">Pairlists</a> completes the discussion of the four major  components of an expression, and shows how you can create functions from  their component pieces.</li>
<li><a href="#parsing-and-deparsing">Parsing and deparsing</a> discusses how to convert  back and forth between expressions and text.</li>
<li><a href="#ast-funs">Walking the call tree with recursive functions</a> concludes  the chapter, combining everything youâve learned about writing functions  that can compute on and modify arbitrary R code.</li>
</ul>
<h5 id="Prerequisites-6"><a href="#Prerequisites-6" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><p>Throughout this chapter weâre going to use tools from the <code>pryr</code> package to help see whatâs going on. If you donât already have it, install it by running <code>install.packages(&quot;pryr&quot;)</code>.</p>
<h2 id="Structure-of-expressions"><a href="#Structure-of-expressions" class="headerlink" title="Structure of expressions"></a><a href="id=&quot;structure-of-expressions&quot;">Structure of expressions</a></h2><p>To compute on the language, we first need to understand the structure of the language. That will require some new vocabulary, some new tools, and some new ways of thinking about R code. The first thing youâll need to understand is the distinction between an operation and a result:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 4</span><br><span class="line">y &lt;- x * 10</span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<p>We want to distinguish the action of multiplying <code>x</code> by 10 and assigning that result to <code>y</code> from the actual result (40). As weâve seen in the previous chapter, we can capture the action with <code>quote()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z &lt;- quote(y &lt;- x * 10)</span><br><span class="line">z</span><br></pre></td></tr></table></figure>
<p><code>quote()</code> returns an <strong>expression</strong>: an object that represents an action that can be performed by R. (Unfortunately <code>expression()</code> does not return an expression in this sense. Instead, it returns something more like a list of expressions. See <a href="#parsing-and-deparsing">parsing and deparsing</a> for more details.)</p>
<p>An expression is also called an abstract syntax tree (AST) because it represents the hierarchical tree structure of the code. Weâll use <code>pryr::ast()</code> to see this more clearly:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ast(y &lt;- x * 10)</span><br></pre></td></tr></table></figure>
<p>There are four possible components of an expression: constants, names, calls, and pairlists.</p>
<ul>
<li><p><strong>constants</strong> are length one atomic vectors, like <code>&quot;a&quot;</code> or <code>10</code>.  <code>ast()</code> displays them as is.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ast(&quot;a&quot;)</span><br><span class="line">ast(1)</span><br><span class="line">ast(1L)</span><br><span class="line">ast(TRUE)</span><br></pre></td></tr></table></figure>
<p>  Quoting a constant returns it unchanged:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">identical(1, quote(1))</span><br><span class="line">identical(&quot;test&quot;, quote(&quot;test&quot;))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>names</strong>, or symbols, represent the name of an object rather than its value.   <code>ast()</code> prefixes names with a backtick.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ast(x)</span><br><span class="line">ast(mean)</span><br><span class="line">ast(`an unusual name`)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>calls</strong> represent the action of calling a function. Like lists, calls are  recursive: they can contain constants, names, pairlists, and other calls.  <code>ast()</code> prints <code>()</code> and then lists the children. The first child is the  function that is called, and the remaining children are the functionâs  arguments.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ast(f())</span><br><span class="line">ast(f(1, 2))</span><br><span class="line">ast(f(a, b))</span><br><span class="line">ast(f(g(), h(1, a)))</span><br></pre></td></tr></table></figure>
<p>  As mentioned in    <a href="#all-calls">every operation is a function call</a>,    even things that donât look like function calls still have this    hierarchical structure:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ast(a + b)</span><br><span class="line">ast(if (x &gt; 1) x else 1/x)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>pairlists</strong>, short for dotted pair lists, are a legacy of Râs past.  They are only used in one place: the formal arguments of a function.  <code>ast()</code> prints <code>[]</code> at the top-level of a pairlist. Like calls, pairlists  are also recursive and can contain constants, names, and calls.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ast(function(x = 1, y) x)</span><br><span class="line">ast(function(x = 1, y = x * 2) &#123;x / y&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Note that <code>str()</code> does not follow these naming conventions when describing objects. Instead, it describes names as symbols and calls as language objects:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str(quote(a))</span><br><span class="line">str(quote(a + b))</span><br></pre></td></tr></table></figure>
<p>Using low-level functions, it is possible to create call trees that contain objects other than constants, names, calls, and pairlists. The following example uses <code>substitute()</code> to insert a data frame into a call tree. This is a bad idea, however, because the object does not print correctly: the printed call looks like it should return âlistâ but when evaluated, it returns âdata.frameâ.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class_df &lt;- substitute(class(df), list(df = data.frame(x = 10)))</span><br><span class="line">class_df</span><br><span class="line">eval(class_df)</span><br></pre></td></tr></table></figure>
<p>Together these four components define the structure of all R code. They are explained in more detail in the following sections.</p>
<h3 id="Exercises-41"><a href="#Exercises-41" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Thereâs no existing base function that checks if an element is    a valid component of an expression (i.e., itâs a constant, name,    call, or pairlist). Implement one by guessing the names of the âisâ    functions for calls, names, and pairlists.</li>
<li><code>pryr::ast()</code> uses non-standard evaluation. Whatâs its escape hatch to    standard evaluation?</li>
<li>What does the call tree of an if statement with multiple else conditions    look like?</li>
<li>Compare <code>ast(x + y %+% z)</code> to <code>ast(x ^ y %+% z)</code>. What do they    tell you about the precedence of custom infix functions?</li>
<li>Why canât an expression contain an atomic vector of length greater than one?    Which one of the six types of atomic vector canât appear in an expression?    Why?</li>
</ol>
<h2 id="Names-1"><a href="#Names-1" class="headerlink" title="Names"></a><a href="id=&quot;names&quot;">Names</a></h2><p>Typically, we use <code>quote()</code> to capture names. You can also convert a string to a name with <code>as.name()</code>. However, this is most useful only when your function receives strings as input. Otherwise it involves more typing than using <code>quote()</code>. (You can use <code>is.name()</code> to test if an object is a name.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">as.name(&quot;name&quot;)</span><br><span class="line">identical(quote(name), as.name(&quot;name&quot;))</span><br><span class="line"></span><br><span class="line">is.name(&quot;name&quot;)</span><br><span class="line">is.name(quote(name))</span><br><span class="line">is.name(quote(f(name)))</span><br></pre></td></tr></table></figure>
<p>(Names are also called symbols. <code>as.symbol()</code> and <code>is.symbol()</code> are identical to <code>as.name()</code> and <code>is.name()</code>.)</p>
<p>Names that would otherwise be invalid are automatically surrounded by backticks:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">as.name(&quot;a b&quot;)</span><br><span class="line">as.name(&quot;if&quot;)</span><br></pre></td></tr></table></figure>
<p>Thereâs one special name that needs a little extra discussion: the empty name. It is used to represent missing arguments. This object behaves strangely. You canât bind it to a variable. If you do, it triggers an error about missing arguments. Itâs only useful if you want to programmatically create a function with missing arguments.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) 10</span><br><span class="line">formals(f)$x</span><br><span class="line">is.name(formals(f)$x)</span><br><span class="line">as.character(formals(f)$x)</span><br><span class="line"></span><br><span class="line">missing_arg &lt;- formals(f)$x</span><br><span class="line"># Doesn&apos;t work!</span><br><span class="line">is.name(missing_arg)</span><br></pre></td></tr></table></figure>
<p>To explicitly create it when needed, call <code>quote()</code> with a named argument:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quote(expr =)</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-42"><a href="#Exercises-42" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>You can use <code>formals()</code> to both get and set the arguments of a function.    Use <code>formals()</code> to modify the following function so that the default value    of <code>x</code> is missing and <code>y</code> is 10.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g &lt;- function(x = 20, y) &#123;</span><br><span class="line">  x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Write an equivalent to <code>get()</code> using <code>as.name()</code> and <code>eval()</code>. Write an    equivalent to <code>assign()</code> using <code>as.name()</code>, <code>substitute()</code>, and <code>eval()</code>.    (Donât worry about the multiple ways of choosing an environment; assume    that the user supplies it explicitly.)</p>
</li>
</ol>
<h2 id="Calls"><a href="#Calls" class="headerlink" title="Calls"></a><a href="id=&quot;calls&quot;">Calls</a></h2><p>A call is very similar to a list. It has <code>length</code>, <code>[[</code> and <code>[</code> methods, and is recursive because calls can contain other calls. The first element of the call is the function that gets called. Itâs usually the <em>name</em> of a function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- quote(read.csv(&quot;important.csv&quot;, row.names = FALSE))</span><br><span class="line">x[[1]]</span><br><span class="line">is.name(x[[1]])</span><br></pre></td></tr></table></figure>
<p>But it can also be another call:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y &lt;- quote(add(10)(20))</span><br><span class="line">y[[1]]</span><br><span class="line">is.call(y[[1]])</span><br></pre></td></tr></table></figure>
<p>The remaining elements are the arguments. They can be extracted by name or by position.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- quote(read.csv(&quot;important.csv&quot;, row.names = FALSE))</span><br><span class="line">x[[2]]</span><br><span class="line">x$row.names</span><br><span class="line">names(x)</span><br></pre></td></tr></table></figure>
<p>The length of a call minus 1 gives the number of arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length(x) - 1</span><br></pre></td></tr></table></figure>
<h3 id="Modifying-a-call"><a href="#Modifying-a-call" class="headerlink" title="Modifying a call"></a>Modifying a call</h3><p>You can add, modify, and delete elements of the call with the standard replacement operators, <code>$&lt;-</code> and <code>[[&lt;-</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">y &lt;- quote(read.csv(&quot;important.csv&quot;, row.names = FALSE))</span><br><span class="line">y$row.names &lt;- TRUE</span><br><span class="line">y$col.names &lt;- FALSE</span><br><span class="line">y</span><br><span class="line"></span><br><span class="line">y[[2]] &lt;- quote(paste0(filename, &quot;.csv&quot;))</span><br><span class="line">y[[4]] &lt;- NULL</span><br><span class="line">y</span><br><span class="line"></span><br><span class="line">y$sep &lt;- &quot;,&quot;</span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<p>Calls also support the <code>[</code> method. But use it with care. Removing the first element is unlikely to create a useful call.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x[-3] # remove the second argument</span><br><span class="line">x[-1] # remove the function name - but it&apos;s still a call!</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<p>If you want a list of the unevaluated arguments (expressions), use explicit coercion:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># A list of the unevaluated arguments</span><br><span class="line">as.list(x[-1])</span><br></pre></td></tr></table></figure>
<p>Generally speaking, because Râs function calling semantics are so flexible, getting or setting arguments by position is dangerous. For example, even though the values at each position are different, the following three calls all have the same effect:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1 &lt;- quote(read.delim(&quot;data.txt&quot;, sep = &quot;|&quot;))</span><br><span class="line">m2 &lt;- quote(read.delim(s = &quot;|&quot;, &quot;data.txt&quot;))</span><br><span class="line">m3 &lt;- quote(read.delim(file = &quot;data.txt&quot;, , &quot;|&quot;))</span><br></pre></td></tr></table></figure>
<p>To work around this problem, pryr provides <code>standardise_call()</code>. It uses the base <code>match.call()</code> function to convert all positional arguments to named arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">standardise_call(m1)</span><br><span class="line">standardise_call(m2)</span><br><span class="line">standardise_call(m3)</span><br></pre></td></tr></table></figure>
<h3 id="Creating-a-call-from-its-components"><a href="#Creating-a-call-from-its-components" class="headerlink" title="Creating a call from its components"></a>Creating a call from its components</h3><p>To create a new call from its components, you can use <code>call()</code> or <code>as.call()</code>. The first argument to <code>call()</code> is a string which gives a function name. The other arguments are expressions that represent the arguments of the call.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call(&quot;:&quot;, 1, 10)</span><br><span class="line">call(&quot;mean&quot;, quote(1:10), na.rm = TRUE)</span><br></pre></td></tr></table></figure>
<p><code>as.call()</code> is a minor variant of <code>call()</code> that takes a single list as input. The first element is a name or call. The subsequent elements are the arguments.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">as.call(list(quote(mean), quote(1:10)))</span><br><span class="line">as.call(list(quote(adder(10)), 20))</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-43"><a href="#Exercises-43" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>The following two calls look the same, but are actually different:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a &lt;- call(&quot;mean&quot;, 1:10))</span><br><span class="line">(b &lt;- call(&quot;mean&quot;, quote(1:10)))</span><br><span class="line">identical(a, b)</span><br></pre></td></tr></table></figure>
<p>Whatâs the difference? Which one should you prefer?</p>
</li>
<li>Implement a pure R version of <code>do.call()</code>.</li>
<li><p>Concatenating a call and an expression with <code>c()</code> creates a list. Implement    <code>concat()</code> so that the following code works to combine a call and    an additional argument.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">concat(quote(f), a = 1, b = quote(mean(a)))</span><br><span class="line">#&gt; f(a = 1, b = mean(a))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Since <code>list()</code>s donât belong in expressions, we could create a more    convenient call constructor that automatically combines lists into the    arguments. Implement <code>make_call()</code> so that the following code works.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make_call(quote(mean), list(quote(x), na.rm = TRUE))</span><br><span class="line">#&gt; mean(x, na.rm = TRUE)</span><br><span class="line">make_call(quote(mean), quote(x), na.rm = TRUE)</span><br><span class="line">#&gt; mean(x, na.rm = TRUE)</span><br></pre></td></tr></table></figure>
</li>
<li><p>How does <code>mode&lt;-</code> work? How does it use <code>call()</code>?</p>
</li>
<li>Read the source for <code>pryr::standardise_call()</code>. How does it work?    Why is <code>is.primitive()</code> needed?</li>
<li><p><code>standardise_call()</code> doesnât work so well for the following calls.    Why?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">standardise_call(quote(mean(1:10, na.rm = TRUE)))</span><br><span class="line">standardise_call(quote(mean(n = T, 1:10)))</span><br><span class="line">standardise_call(quote(mean(x = 1:10, , TRUE)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Read the documentation for <code>pryr::modify_call()</code>. How do you think    it works? Read the source code.</p>
</li>
<li>Use <code>ast()</code> and experimentation to figure out the three arguments in an    <code>if()</code> call. Which components are required? What are the arguments to    the <code>for()</code> and <code>while()</code> calls?</li>
</ol>
<h2 id="Capturing-the-current-call"><a href="#Capturing-the-current-call" class="headerlink" title="Capturing the current call"></a><a href="id=&quot;capturing-call&quot;">Capturing the current call</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std &lt;- c(&quot;package:base&quot;, &quot;package:utils&quot;, &quot;package:stats&quot;)</span><br><span class="line">names(find_uses(std, &quot;sys.call&quot;))</span><br><span class="line">names(find_uses(std, &quot;match.call&quot;))</span><br></pre></td></tr></table></figure>
<p>Many base R functions use the current call: the expression that caused the current function to be run. There are two ways to capture a current call:</p>
<ul>
<li><code>sys.call()</code> captures exactly what the user typed.</li>
<li><code>match.call()</code> makes a call that only uses named arguments. Itâs like  automatically calling <code>pryr::standardise_call()</code> on the result of  <code>sys.call()</code></li>
</ul>
<p>The following example illustrates the difference between the two:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(abc = 1, def = 2, ghi = 3) &#123;</span><br><span class="line">  list(sys = sys.call(), match = match.call())</span><br><span class="line">&#125;</span><br><span class="line">f(d = 2, 2)</span><br></pre></td></tr></table></figure>
<p>Modelling functions often use <code>match.call()</code> to capture the call used to create the model. This makes it possible to <code>update()</code> a model, re-fitting the model after modifying some of original arguments. Hereâs an example of <code>update()</code> in action:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mod &lt;- lm(mpg ~ wt, data = mtcars)</span><br><span class="line">update(mod, formula = . ~ . + cyl)</span><br></pre></td></tr></table></figure>
<p>How does <code>update()</code> work? We can rewrite it using some tools from pryr to focus on the essence of the algorithm.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">update_call &lt;- function (object, formula., ...) &#123;</span><br><span class="line">  call &lt;- object$call</span><br><span class="line"></span><br><span class="line">  # Use update.formula to deal with formulas like . ~ .</span><br><span class="line">  if (!missing(formula.)) &#123;</span><br><span class="line">    call$formula &lt;- update.formula(formula(object), formula.)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modify_call(call, dots(...))</span><br><span class="line">&#125;</span><br><span class="line">update_model &lt;- function(object, formula., ...) &#123;</span><br><span class="line">  call &lt;- update_call(object, formula., ...)</span><br><span class="line">  eval(call, parent.frame())</span><br><span class="line">&#125;</span><br><span class="line">update_model(mod, formula = . ~ . + cyl)</span><br></pre></td></tr></table></figure>
<p>The original <code>update()</code> has an <code>evaluate</code> argument that controls whether the function returns the call or the result. But I think itâs better, on principle, that a function returns only one type of object, rather than different types depending on the functionâs arguments.</p>
<p>This rewrite also allows us to fix a small bug in <code>update()</code>: it re-evaluates the call in the global environment, when what we really want is to re-evaluate it in the environment where the model was originally fit â in the formula.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function() &#123;</span><br><span class="line">  n &lt;- 3</span><br><span class="line">  lm(mpg ~ poly(wt, n), data = mtcars)</span><br><span class="line">&#125;</span><br><span class="line">mod &lt;- f()</span><br><span class="line">update(mod, data = mtcars)</span><br><span class="line"></span><br><span class="line">update_model &lt;- function(object, formula., ...) &#123;</span><br><span class="line">  call &lt;- update_call(object, formula., ...)</span><br><span class="line">  eval(call, environment(formula(object)))</span><br><span class="line">&#125;</span><br><span class="line">update_model(mod, data = mtcars)</span><br></pre></td></tr></table></figure>
<p>This is an important principle to remember: if you want to re-run code captured with <code>match.call()</code>, you also need to capture the environment in which it was evaluated, usually the <code>parent.frame()</code>. The downside to this is that capturing the environment also means capturing any large objects which happen to be in that environment, which prevents their memory from being released. This topic is explored in more detail in <a href="#gc">garbage collection</a>.</p>
<p>Some base R functions use <code>match.call()</code> where itâs not necessary. For example,  <code>write.csv()</code> captures the call to <code>write.csv()</code> and mangles it to call <code>write.table()</code> instead:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">write.csv &lt;- function(...) &#123;</span><br><span class="line">  Call &lt;- match.call(expand.dots = TRUE)</span><br><span class="line">  for (arg in c(&quot;append&quot;, &quot;col.names&quot;, &quot;sep&quot;, &quot;dec&quot;, &quot;qmethod&quot;)) &#123;</span><br><span class="line">    if (!is.null(Call[[arg]])) &#123;</span><br><span class="line">      warning(gettextf(&quot;attempt to set &apos;%s&apos; ignored&quot;, arg))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  rn &lt;- eval.parent(Call$row.names)</span><br><span class="line">  Call$append &lt;- NULL</span><br><span class="line">  Call$col.names &lt;- if (is.logical(rn) &amp;&amp; !rn) TRUE else NA</span><br><span class="line">  Call$sep &lt;- &quot;,&quot;</span><br><span class="line">  Call$dec &lt;- &quot;.&quot;</span><br><span class="line">  Call$qmethod &lt;- &quot;double&quot;</span><br><span class="line">  Call[[1L]] &lt;- as.name(&quot;write.table&quot;)</span><br><span class="line">  eval.parent(Call)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To fix this, we could implement <code>write.csv()</code> using regular function call semantics:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">write.csv &lt;- function(x, file = &quot;&quot;, sep = &quot;,&quot;, qmethod = &quot;double&quot;,</span><br><span class="line">                      ...) &#123;</span><br><span class="line">  write.table(x = x, file = file, sep = sep, qmethod = qmethod,</span><br><span class="line">    ...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is much easier to understand: itâs just calling <code>write.table()</code> with different defaults. This also fixes a subtle bug in the original <code>write.csv()</code>: <code>write.csv(mtcars, row = FALSE)</code> raises an error, but <code>write.csv(mtcars, row.names = FALSE)</code> does not. The lesson here is that itâs always better to solve a problem with the simplest tool possible.</p>
<h3 id="Exercises-44"><a href="#Exercises-44" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Compare and contrast <code>update_model()</code> with <code>update.default()</code>.</li>
<li>Why doesnât <code>write.csv(mtcars, &quot;mtcars.csv&quot;, row = FALSE)</code> work?    What property of argument matching has the original author forgotten?</li>
<li>Rewrite <code>update.formula()</code> to use R code instead of C code.</li>
<li>Sometimes itâs necessary to uncover the function that called the    function that called the current function (i.e., the grandparent, not    the parent). How can you use <code>sys.call()</code> or <code>match.call()</code> to find    this function?</li>
</ol>
<h2 id="Pairlists"><a href="#Pairlists" class="headerlink" title="Pairlists"></a><a href="id=&quot;pairlists&quot;">Pairlists</a></h2><p>Pairlists are a holdover from Râs past. They behave identically to lists, but have a different internal representation (as a linked list rather than a vector). Pairlists have been replaced by lists everywhere except in function arguments.</p>
<p>The only place you need to care about the difference between a list and a pairlist is if youâre going to construct functions by hand. For example, the following function allows you to construct a function from its component pieces: a list of formal arguments, a body, and an environment. The function uses <code>as.pairlist()</code> to ensure that the <code>function()</code> has the pairlist of <code>args</code> it needs.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make_function &lt;- function(args, body, env = parent.frame()) &#123;</span><br><span class="line">  args &lt;- as.pairlist(args)</span><br><span class="line"></span><br><span class="line">  eval(call(&quot;function&quot;, args, body), env)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function is also available in pryr, where it does a little extra checking of arguments. <code>make_function()</code> is best used in conjunction with <code>alist()</code>, the <strong>a</strong>rgument list function. <code>alist()</code> doesnât evaluate its arguments so that <code>alist(x = a)</code> is shorthand for <code>list(x = quote(a))</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add &lt;- make_function(alist(a = 1, b = 2), quote(a + b))</span><br><span class="line">add(1)</span><br><span class="line">add(1, 2)</span><br><span class="line"></span><br><span class="line"># To have an argument with no default, you need an explicit =</span><br><span class="line">make_function(alist(a = , b = a), quote(a + b))</span><br><span class="line"># To take `...` as an argument put it on the LHS of =</span><br><span class="line">make_function(alist(a = , b = , ... =), quote(a + b))</span><br></pre></td></tr></table></figure>
<p><code>make_function()</code> has one advantage over using closures to construct functions: with it, you can easily read the source code. For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adder &lt;- function(x) &#123;</span><br><span class="line">  make_function(alist(y =), substitute(&#123;x + y&#125;), parent.frame())</span><br><span class="line">&#125;</span><br><span class="line">adder(10)</span><br></pre></td></tr></table></figure>
<p>One useful application of <code>make_function()</code> is in functions like <code>curve()</code>. <code>curve()</code> allows you to plot a mathematical function without creating an explicit R function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curve(sin(exp(4 * x)), n = 1000)</span><br></pre></td></tr></table></figure>
<p>Here <code>x</code> is a pronoun. <code>x</code> doesnât represent a single concrete value, but is instead a placeholder that varies over the range of the plot. One way to implement <code>curve()</code> would be with <code>make_function()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curve2 &lt;- function(expr, xlim = c(0, 1), n = 100,</span><br><span class="line">                   env = parent.frame()) &#123;</span><br><span class="line">  f &lt;- make_function(alist(x = ), substitute(expr), env)</span><br><span class="line"></span><br><span class="line">  x &lt;- seq(xlim[1], xlim[2], length = n)</span><br><span class="line">  y &lt;- f(x)</span><br><span class="line"></span><br><span class="line">  plot(x, y, type = &quot;l&quot;, ylab = deparse(substitute(expr)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Functions that use a pronoun are called <a href="http://en.wikipedia.org/wiki/Anaphora_(linguistics" target="_blank" rel="external">anaphoric</a>) functions. They are used in <a href="http://www.arcfn.com/doc/anaphoric.html" target="_blank" rel="external">Arc</a> (a lisp like language), <a href="http://www.perlmonks.org/index.pl?node_id=666047" target="_blank" rel="external">Perl</a>, and <a href="http://amalloy.hubpages.com/hub/Unhygenic-anaphoric-Clojure-macros-for-fun-and-profit" target="_blank" rel="external">Clojure</a>.</p>
<h3 id="Exercises-45"><a href="#Exercises-45" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>How are <code>alist(a)</code> and <code>alist(a = )</code> different? Think about both the    input and the output.</li>
<li>Read the documentation and source code for <code>pryr::partial()</code>. What does it    do? How does it work? Read the documentation and source code for    <code>pryr::unenclose()</code>. What does it do and how does it work?</li>
<li><p>The actual implementation of <code>curve()</code> looks more like</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curve3 &lt;- function(expr, xlim = c(0, 1), n = 100,</span><br><span class="line">                   env = parent.frame()) &#123;</span><br><span class="line">  env2 &lt;- new.env(parent = env)</span><br><span class="line">  env2$x &lt;- seq(xlim[1], xlim[2], length = n)</span><br><span class="line"></span><br><span class="line">  y &lt;- eval(substitute(expr), env2)</span><br><span class="line">  plot(env2$x, y, type = &quot;l&quot;,</span><br><span class="line">    ylab = deparse(substitute(expr)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How does this approach differ from <code>curve2()</code> defined above?</p>
</li>
</ol>
<h2 id="Parsing-and-deparsing"><a href="#Parsing-and-deparsing" class="headerlink" title="Parsing and deparsing"></a><a href="id=&quot;parsing-and-deparsing&quot;">Parsing and deparsing</a></h2><p>Sometimes code is represented as a string, rather than as an expression. You can convert a string to an expression with <code>parse()</code>. <code>parse()</code> is the opposite of <code>deparse()</code>: it takes a character vector and returns an expression object. The primary use of <code>parse()</code> is parsing files of code to disk, so the first argument is a file path. Note that if you have code in a character vector, you need to use the <code>text</code> argument:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z &lt;- quote(y &lt;- x * 10)</span><br><span class="line">deparse(z)</span><br><span class="line"></span><br><span class="line">parse(text = deparse(z))</span><br></pre></td></tr></table></figure>
<p>Because there might be many top-level calls in a file, <code>parse()</code> doesnât return just a single expression. Instead, it returns an expression object, which is essentially a list of expressions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">exp &lt;- parse(text = c(&quot;</span><br><span class="line">  x &lt;- 4</span><br><span class="line">  x</span><br><span class="line">  5</span><br><span class="line">&quot;))</span><br><span class="line">length(exp)</span><br><span class="line">typeof(exp)</span><br><span class="line"></span><br><span class="line">exp[[1]]</span><br><span class="line">exp[[2]]</span><br></pre></td></tr></table></figure>
<p>You can create expression objects by hand with <code>expression()</code>, but I wouldnât recommend it. Thereâs no need to learn about this esoteric data structure if you already know how to use expressions.</p>
<p>With <code>parse()</code> and <code>eval()</code>, itâs possible to write a simple version of <code>source()</code>. We read in the file from disk, <code>parse()</code> it and then <code>eval()</code> each component in a specified environment. This version defaults to a new environment, so it doesnât affect existing objects. <code>source()</code> invisibly returns the result of the last expression in the file, so <code>simple_source()</code> does the same.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">simple_source &lt;- function(file, envir = new.env()) &#123;</span><br><span class="line">  stopifnot(file.exists(file))</span><br><span class="line">  stopifnot(is.environment(envir))</span><br><span class="line"></span><br><span class="line">  lines &lt;- readLines(file, warn = FALSE)</span><br><span class="line">  exprs &lt;- parse(text = lines)</span><br><span class="line"></span><br><span class="line">  n &lt;- length(exprs)</span><br><span class="line">  if (n == 0L) return(invisible())</span><br><span class="line"></span><br><span class="line">  for (i in seq_len(n - 1)) &#123;</span><br><span class="line">    eval(exprs[i], envir)</span><br><span class="line">  &#125;</span><br><span class="line">  invisible(eval(exprs[n], envir))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The real <code>source()</code> is considerably more complicated because it can <code>echo</code> input and output, and also has many additional settings to control behaviour.</p>
<h3 id="Exercises-46"><a href="#Exercises-46" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>What are the differences between <code>quote()</code> and <code>expression()</code>?</li>
<li>Read the help for <code>deparse()</code> and construct a call that <code>deparse()</code>    and <code>parse()</code> do not operate symmetrically on.</li>
<li>Compare and contrast <code>source()</code> and <code>sys.source()</code>.</li>
<li>Modify <code>simple_source()</code> so it returns the result of <em>every</em> expression,    not just the last one.</li>
<li>The code generated by <code>simple_source()</code> lacks source references. Read    the source code for <code>sys.source()</code> and the help for <code>srcfilecopy()</code>,    then modify <code>simple_source()</code> to preserve source references. You can    test your code by sourcing a function that contains a comment. If    successful, when you look at the function, youâll see the comment and    not just the source code.</li>
</ol>
<h2 id="Walking-the-AST-with-recursive-functions"><a href="#Walking-the-AST-with-recursive-functions" class="headerlink" title="Walking the AST with recursive functions"></a><a href="id=&quot;ast-funs&quot;">Walking the AST with recursive functions</a></h2><p>Itâs easy to modify a single call with <code>substitute()</code> or <code>pryr::modify_call()</code>. For more complicated tasks we need to work directly with the AST. The base <code>codetools</code> package provides some useful motivating examples of how we can do this:</p>
<ul>
<li><code>findGlobals()</code> locates all global variables used by a function. This  can be useful if you want to check that your function doesnât inadvertently  rely on variables defined in their parent environment.</li>
<li><code>checkUsage()</code> checks for a range of common problems including  unused local variables, unused parameters, and the use of partial  argument matching.</li>
</ul>
<p>To write functions like <code>findGlobals()</code> and <code>checkUsage()</code>, weâll need a new tool. Because expressions have a tree structure, using a recursive function would be the natural choice. The key to doing that is getting the recursion right. This means making sure that you know what the base case is and figuring out how to combine the results from the recursive case. For calls, there are two base cases (atomic vectors and names) and two recursive cases (calls and pairlists). This means that a function for working with expressions will look like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">recurse_call &lt;- function(x) &#123;</span><br><span class="line">  if (is.atomic(x)) &#123;</span><br><span class="line">    # Return a value</span><br><span class="line">  &#125; else if (is.name(x)) &#123;</span><br><span class="line">    # Return a value</span><br><span class="line">  &#125; else if (is.call(x)) &#123;</span><br><span class="line">    # Call recurse_call recursively</span><br><span class="line">  &#125; else if (is.pairlist(x)) &#123;</span><br><span class="line">    # Call recurse_call recursively</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    # User supplied incorrect input</span><br><span class="line">    stop(&quot;Don&apos;t know how to handle type &quot;, typeof(x),</span><br><span class="line">      call. = FALSE)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Finding-F-and-T"><a href="#Finding-F-and-T" class="headerlink" title="Finding F and T"></a>Finding F and T</h3><p>Weâll start simple with a function that determines whether a function uses the logical abbreviations <code>T</code> and <code>F</code>. Using <code>T</code> and <code>F</code> is generally considered to be poor coding practice, and is something that <code>R CMD check</code> will warn about. Letâs first compare the AST for <code>T</code> vs. <code>TRUE</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ast(TRUE)</span><br><span class="line">ast(T)</span><br></pre></td></tr></table></figure>
<p><code>TRUE</code> is parsed as a logical vector of length one, while <code>T</code> is parsed as a name. This tells us how to write our base cases for the recursive function: while an atomic vector will never be a logical abbreviation, a name might, so weâll need to test for both <code>T</code> and <code>F</code>. The recursive cases can be combined because they do the same thing in both cases: they recursively call <code>logical_abbr()</code> on each element of the object.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">logical_abbr &lt;- function(x) &#123;</span><br><span class="line">  if (is.atomic(x)) &#123;</span><br><span class="line">    FALSE</span><br><span class="line">  &#125; else if (is.name(x)) &#123;</span><br><span class="line">    identical(x, quote(T)) || identical(x, quote(F))</span><br><span class="line">  &#125; else if (is.call(x) || is.pairlist(x)) &#123;</span><br><span class="line">    for (i in seq_along(x)) &#123;</span><br><span class="line">      if (logical_abbr(x[[i]])) return(TRUE)</span><br><span class="line">    &#125;</span><br><span class="line">    FALSE</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    stop(&quot;Don&apos;t know how to handle type &quot;, typeof(x),</span><br><span class="line">      call. = FALSE)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logical_abbr(quote(TRUE))</span><br><span class="line">logical_abbr(quote(T))</span><br><span class="line">logical_abbr(quote(mean(x, na.rm = T)))</span><br><span class="line">logical_abbr(quote(function(x, na.rm = T) FALSE))</span><br></pre></td></tr></table></figure>
<h3 id="Finding-all-variables-created-by-assignment"><a href="#Finding-all-variables-created-by-assignment" class="headerlink" title="Finding all variables created by assignment"></a>Finding all variables created by assignment</h3><p><code>logical_abbr()</code> is very simple: it only returns a single <code>TRUE</code> or <code>FALSE</code>. The next task, listing all variables created by assignment, is a little more complicated. Weâll start simply, and then make the function progressively more rigorous.</p>
<p>Again, we start by looking at the AST for assignment:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ast(x &lt;- 10)</span><br></pre></td></tr></table></figure>
<p>Assignment is a call where the first element is the name <code>&lt;-</code>, the second is the object the name is assigned to, and the third is the value to be assigned. This makes the base cases simple: constants and names donât create assignments, so they return <code>NULL</code>. The recursive cases arenât too hard either. We <code>lapply()</code> over pairlists and over calls to functions other than <code>&lt;-</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">find_assign &lt;- function(x) &#123;</span><br><span class="line">  if (is.atomic(x) || is.name(x)) &#123;</span><br><span class="line">    NULL</span><br><span class="line">  &#125; else if (is.call(x)) &#123;</span><br><span class="line">    if (identical(x[[1]], quote(`&lt;-`))) &#123;</span><br><span class="line">      x[[2]]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      lapply(x, find_assign)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (is.pairlist(x)) &#123;</span><br><span class="line">    lapply(x, find_assign)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    stop(&quot;Don&apos;t know how to handle type &quot;, typeof(x),</span><br><span class="line">      call. = FALSE)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">find_assign(quote(a &lt;- 1))</span><br><span class="line">find_assign(quote(&#123;</span><br><span class="line">  a &lt;- 1</span><br><span class="line">  b &lt;- 2</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>This function works for these simple cases, but the output is rather verbose and includes some extraneous <code>NULL</code>s. Instead of returning a list, letâs keep it simple and use a character vector. Weâll also test it with two slightly more complicated examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">find_assign2 &lt;- function(x) &#123;</span><br><span class="line">  if (is.atomic(x) || is.name(x)) &#123;</span><br><span class="line">    character()</span><br><span class="line">  &#125; else if (is.call(x)) &#123;</span><br><span class="line">    if (identical(x[[1]], quote(`&lt;-`))) &#123;</span><br><span class="line">      as.character(x[[2]])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      unlist(lapply(x, find_assign2))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (is.pairlist(x)) &#123;</span><br><span class="line">    unlist(lapply(x, find_assign2))</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    stop(&quot;Don&apos;t know how to handle type &quot;, typeof(x),</span><br><span class="line">      call. = FALSE)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find_assign2(quote(&#123;</span><br><span class="line">  a &lt;- 1</span><br><span class="line">  b &lt;- 2</span><br><span class="line">  a &lt;- 3</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">find_assign2(quote(&#123;</span><br><span class="line">  system.time(x &lt;- print(y &lt;- 5))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>This is better, but we have two problems: dealing with repeated names and neglecting assignments inside other assignments. The fix for the first problem is easy. We need to wrap <code>unique()</code> around the recursive case to remove duplicate assignments. The fix for the second problem is a bit more tricky. We also need to recurse when the call is to <code>&lt;-</code>. <code>find_assign3()</code> implements both strategies:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">find_assign3 &lt;- function(x) &#123;</span><br><span class="line">  if (is.atomic(x) || is.name(x)) &#123;</span><br><span class="line">    character()</span><br><span class="line">  &#125; else if (is.call(x)) &#123;</span><br><span class="line">    if (identical(x[[1]], quote(`&lt;-`))) &#123;</span><br><span class="line">      lhs &lt;- as.character(x[[2]])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      lhs &lt;- character()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unique(c(lhs, unlist(lapply(x, find_assign3))))</span><br><span class="line">  &#125; else if (is.pairlist(x)) &#123;</span><br><span class="line">    unique(unlist(lapply(x, find_assign3)))</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    stop(&quot;Don&apos;t know how to handle type &quot;, typeof(x),</span><br><span class="line">      call. = FALSE)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find_assign3(quote(&#123;</span><br><span class="line">  a &lt;- 1</span><br><span class="line">  b &lt;- 2</span><br><span class="line">  a &lt;- 3</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">find_assign3(quote(&#123;</span><br><span class="line">  system.time(x &lt;- print(y &lt;- 5))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>We also need to test subassignment:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_assign3(quote(&#123;</span><br><span class="line">  l &lt;- list()</span><br><span class="line">  l$a &lt;- 5</span><br><span class="line">  names(l) &lt;- &quot;b&quot;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>We only want assignment of the object itself, not assignment that modifies a property of the object. Drawing the tree for the quoted object will help us see what condition to test for. The second element of the call to <code>&lt;-</code> should be a name, not another call.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ast(l$a &lt;- 5)</span><br><span class="line">ast(names(l) &lt;- &quot;b&quot;)</span><br></pre></td></tr></table></figure>
<p>Now we have a complete version:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">find_assign4 &lt;- function(x) &#123;</span><br><span class="line">  if (is.atomic(x) || is.name(x)) &#123;</span><br><span class="line">    character()</span><br><span class="line">  &#125; else if (is.call(x)) &#123;</span><br><span class="line">    if (identical(x[[1]], quote(`&lt;-`)) &amp;&amp; is.name(x[[2]])) &#123;</span><br><span class="line">      lhs &lt;- as.character(x[[2]])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      lhs &lt;- character()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unique(c(lhs, unlist(lapply(x, find_assign4))))</span><br><span class="line">  &#125; else if (is.pairlist(x)) &#123;</span><br><span class="line">    unique(unlist(lapply(x, find_assign4)))</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    stop(&quot;Don&apos;t know how to handle type &quot;, typeof(x),</span><br><span class="line">      call. = FALSE)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find_assign4(quote(&#123;</span><br><span class="line">  l &lt;- list()</span><br><span class="line">  l$a &lt;- 5</span><br><span class="line">  names(l) &lt;- &quot;b&quot;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>While the complete version of this function is quite complicated, itâs important to remember we wrote it by working our way up by writing simple component parts.</p>
<h3 id="Modifying-the-call-tree"><a href="#Modifying-the-call-tree" class="headerlink" title="Modifying the call tree"></a><a href="id=&quot;modifying-code&quot;">Modifying the call tree</a></h3><p>The next step up in complexity is returning a modified call tree, like what you get with <code>bquote()</code>. <code>bquote()</code> is a slightly more flexible form of quote: it allows you to optionally quote and unquote some parts of an expression (itâs similar to the backtick operator in Lisp). Everything is quoted, <em>unless</em> itâs encapsulated in <code>.()</code> in which case itâs evaluated and the result is inserted:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- 1</span><br><span class="line">b &lt;- 3</span><br><span class="line">bquote(a + b)</span><br><span class="line">bquote(a + .(b))</span><br><span class="line">bquote(.(a) + .(b))</span><br><span class="line">bquote(.(a + b))</span><br></pre></td></tr></table></figure>
<p>This provides a fairly easy way to control what gets evaluated and when. How does <code>bquote()</code> work? Below, Iâve rewritten <code>bquote()</code> to use the same style as our other functions: it expects input to be quoted already, and makes the base and recursive cases more explicit:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bquote2 &lt;- function (x, where = parent.frame()) &#123;</span><br><span class="line">  if (is.atomic(x) || is.name(x)) &#123;</span><br><span class="line">    # Leave unchanged</span><br><span class="line">    x</span><br><span class="line">  &#125; else if (is.call(x)) &#123;</span><br><span class="line">    if (identical(x[[1]], quote(.))) &#123;</span><br><span class="line">      # Call to .(), so evaluate</span><br><span class="line">      eval(x[[2]], where)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      # Otherwise apply recursively, turning result back into call</span><br><span class="line">      as.call(lapply(x, bquote2, where = where))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (is.pairlist(x)) &#123;</span><br><span class="line">    as.pairlist(lapply(x, bquote2, where = where))</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    # User supplied incorrect input</span><br><span class="line">    stop(&quot;Don&apos;t know how to handle type &quot;, typeof(x),</span><br><span class="line">      call. = FALSE)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x &lt;- 1</span><br><span class="line">y &lt;- 2</span><br><span class="line">bquote2(quote(x == .(x)))</span><br><span class="line">bquote2(quote(function(x = .(x)) &#123;</span><br><span class="line">  x + .(y)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>The main difference between this and the previous recursive functions is that after we process each element of calls and pairlists, we need to coerce them back to their original types.</p>
<p>Note that functions that modify the source tree are most useful for creating expressions that are used at run-time, rather than those that are saved back to the original source file. This is because all non-code information is lost:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bquote2(quote(function(x = .(x)) &#123;</span><br><span class="line">  # This is a comment</span><br><span class="line">  x +  # funky spacing</span><br><span class="line">    .(y)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>These tools are somewhat similar to Lisp macros, as discussed in <a href="http://www.r-project.org/doc/Rnews/Rnews_2001-3.pdf#page=10" target="_blank" rel="external">Programmerâs Niche: Macros in R</a> by Thomas Lumley. However, macros are run at compile-time, which doesnât have any meaning in R, and always return expressions. Theyâre also somewhat like Lisp <a href="http://en.wikipedia.org/wiki/Fexpr" target="_blank" rel="external">fexprs</a>. A fexpr is a function where the arguments are not evaluated by default. The terms macro and fexpr are useful to know when looking for useful techniques from other languages.</p>
<h3 id="Exercises-47"><a href="#Exercises-47" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Why does <code>logical_abbr()</code> use a for loop instead of a functional    like <code>lapply()</code>?</li>
<li><p><code>logical_abbr()</code> works when given quoted objects, but doesnât work when    given an existing function, as in the example below. Why not? How could    you modify <code>logical_abbr()</code> to work with functions? Think about what    components make up a function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x = TRUE) &#123;</span><br><span class="line">  g(x + T)</span><br><span class="line">&#125;</span><br><span class="line">logical_abbr(f)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Write a function called <code>ast_type()</code> that returns either âconstantâ,    ânameâ, âcallâ, or âpairlistâ. Rewrite <code>logical_abbr()</code>, <code>find_assign()</code>,    and <code>bquote2()</code> to use this function with <code>switch()</code> instead of nested if    statements.</p>
</li>
<li>Write a function that extracts all calls to a function. Compare your    function to <code>pryr::fun_calls()</code>.</li>
<li>Write a wrapper around <code>bquote2()</code> that does non-standard evaluation    so that you donât need to explicitly <code>quote()</code> the input.</li>
<li><p>Compare <code>bquote2()</code> to <code>bquote()</code>. There is a subtle bug in <code>bquote()</code>:    it wonât replace calls to functions with no arguments. Why?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bquote(.(x)(), list(x = quote(f)))</span><br><span class="line">bquote(.(x)(1), list(x = quote(f)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Improve the base <code>recurse_call()</code> template to also work with lists of    functions and expressions (e.g., as from <code>parse(path_to_file))</code>.</p>
</li>
</ol>
<hr>
<h1 id="Domain-specific-languages"><a href="#Domain-specific-languages" class="headerlink" title="Domain specific languages"></a><a href="id=&quot;dsl&quot;">Domain specific languages</a></h1><p>The combination of first class environments, lexical scoping, non-standard evaluation, and metaprogramming gives us a powerful toolkit for creating embedded domain specific languages (DSLs) in R. Embedded DSLs take advantage of a host languageâs parsing and execution framework, but adjust the semantics to make them more suitable for a specific task. DSLs are a very large topic, and this chapter will only scratch the surface, focussing on important implementation techniques rather than on how you might come up with the language in the first place. If youâre interested in learning more, I highly recommend <a href="http://amzn.com/0321712943?tag=devtools-20" target="_blank" rel="external"><em>Domain Specific Languages</em></a> by Martin Fowler. It discusses many options for creating a DSL and provides many examples of different languages.</p>
<p>Râs most popular DSL is the formula specification, which provides a succinct way of describing the relationship between predictors and the response in a model. Other examples include ggplot2 (for visualisation) and plyr (for data manipulation). Another package that makes extensive use of these ideas is dplyr, which provides <code>translate_sql()</code> to convert R expressions into SQL:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">library(dplyr)</span><br><span class="line">translate_sql(sin(x) + tan(y))</span><br><span class="line">translate_sql(x &lt; 5 &amp; !(y &gt;= 5))</span><br><span class="line">translate_sql(first %like% &quot;Had*&quot;)</span><br><span class="line">translate_sql(first %in% c(&quot;John&quot;, &quot;Roger&quot;, &quot;Robert&quot;))</span><br><span class="line">translate_sql(like == 7)</span><br></pre></td></tr></table></figure>
<p>This chapter will develop two simple, but useful DSLs: one to generate HTML, and the other to turn mathematical expressions expressed in R code into LaTeX.</p>
<h5 id="Prerequisites-7"><a href="#Prerequisites-7" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><p>This chapter together pulls together many techniques discussed elsewhere in the book. In particular, youâll need to understand environments, functionals, non-standard evaluation, and metaprogramming.</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a><a href="id=&quot;html&quot;">HTML</a></h2><p>HTML (hypertext markup language) is the language that underlies the majority of the web. Itâs a special case of SGML (standard generalised markup language), and itâs similar but not identical to XML (extensible markup language). HTML looks like this:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">'first'</span>&gt;</span>A heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Some text &amp;amp; <span class="tag">&lt;<span class="name">b</span>&gt;</span>some bold text.<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'myimg.png'</span> <span class="attr">width</span>=<span class="string">'100'</span> <span class="attr">height</span>=<span class="string">'100'</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Even if youâve never looked at HTML before, you can still see that the key component of its coding structure is tags, <code>&lt;tag&gt;&lt;/tag&gt;</code>. Tags can be contained inside other tags and intermingled with text. Generally, HTML ignores whitespaces (a sequence of whitespace is equivalent to a single space) so you could put the previous example on a single line and it would still display the same in a browser:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">'first'</span>&gt;</span>A heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Some text &amp;amp; <span class="tag">&lt;<span class="name">b</span>&gt;</span>some bold</span><br><span class="line">text.<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'myimg.png'</span> <span class="attr">width</span>=<span class="string">'100'</span> <span class="attr">height</span>=<span class="string">'100'</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>However, like R code, you usually want to indent HTML to make the structure more obvious.</p>
<p>There are over 100 HTML tags. But to illustrate HTML, weâre going to focus on just a few:</p>
<ul>
<li><code>&lt;body&gt;</code>: the top-level tag that all content is enclosed within</li>
<li><code>&lt;h1&gt;</code>: creates a heading-1, the top level heading</li>
<li><code>&lt;p&gt;</code>: creates a paragraph</li>
<li><code>&lt;b&gt;</code>: emboldens text</li>
<li><code>&lt;img&gt;</code>: embeds an image</li>
</ul>
<p>(You probably guessed what these did already!)</p>
<p>Tags can also have named attributes. They look like <code>&lt;tag a=&quot;a&quot; b=&quot;b&quot;&gt;&lt;/tag&gt;</code>. Tag values should always be enclosed in either single or double quotes. Two important attributes used with just about every tag are <code>id</code> and <code>class</code>. These are used in conjunction with CSS (cascading style sheets) in order to control the style of the document.</p>
<p>Some tags, like <code>&lt;img&gt;</code>, canât have any content. These are called <strong>void tags</strong> and have a slightly different syntax. Instead of writing <code>&lt;img&gt;&lt;/img&gt;</code>, you write <code>&lt;img /&gt;</code>. Since they have no content, attributes are more important. In fact, <code>img</code> has three that are used for almost every image: <code>src</code> (where the image lives), <code>width</code>, and <code>height</code>.</p>
<p>Because <code>&lt;</code> and <code>&gt;</code> have special meanings in HTML, you canât write them directly. Instead you have to use the HTML escapes: <code>&amp;gt;</code> and <code>&amp;lt;</code>. And, since those escapes use <code>&amp;</code>, if you want a literal ampersand you have to escape with <code>&amp;amp;</code>.</p>
<h3 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h3><p>Our goal is to make it easy to generate HTML from R. To give a concrete example, we want to generate the following HTML with code that looks as similar to the HTML as possible.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">'first'</span>&gt;</span>A heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Some text &amp;amp; <span class="tag">&lt;<span class="name">b</span>&gt;</span>some bold text.<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'myimg.png'</span> <span class="attr">width</span>=<span class="string">'100'</span> <span class="attr">height</span>=<span class="string">'100'</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>To do so, we will work our way up to the following DSL:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with_html(body(</span><br><span class="line">  h1(&quot;A heading&quot;, id = &quot;first&quot;),</span><br><span class="line">  p(&quot;Some text &amp;&quot;, b(&quot;some bold text.&quot;)),</span><br><span class="line">  img(src = &quot;myimg.png&quot;, width = 100, height = 100)</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>Note that the nesting of function calls is the same as the nesting of tags: unnamed arguments become the content of the tag, and named arguments become their attributes. Because tags and text are clearly distinct in this API, we can automatically escape <code>&amp;</code> and other special characters.</p>
<h3 id="Escaping"><a href="#Escaping" class="headerlink" title="Escaping"></a>Escaping</h3><p>Escaping is so fundamental to DSLs that itâll be our first topic. To create a way of escaping characters, we need to give â&amp;â a special meaning without ending up double-escaping. The easiest way to do this is to create an S3 class that distinguishes between regular text (that needs escaping) and HTML (that doesnât).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html &lt;- function(x) structure(x, class = &quot;html&quot;)</span><br><span class="line">print.html &lt;- function(x, ...) &#123;</span><br><span class="line">  out &lt;- paste0(&quot;&lt;HTML&gt; &quot;, x)</span><br><span class="line">  cat(paste(strwrap(out), collapse = &quot;\n&quot;), &quot;\n&quot;, sep = &quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knit_print.html &lt;- function(x, ...) print(x)</span><br></pre></td></tr></table></figure>
<p>We then write an escape method that leaves HTML unchanged and escapes the special characters (<code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>) for ordinary text. We also add a list method for convenience.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">escape &lt;- function(x) UseMethod(&quot;escape&quot;)</span><br><span class="line">escape.html &lt;- function(x) x</span><br><span class="line">escape.character &lt;- function(x) &#123;</span><br><span class="line">  x &lt;- gsub(&quot;&amp;&quot;, &quot;&amp;amp;&quot;, x)</span><br><span class="line">  x &lt;- gsub(&quot;&lt;&quot;, &quot;&amp;lt;&quot;, x)</span><br><span class="line">  x &lt;- gsub(&quot;&gt;&quot;, &quot;&amp;gt;&quot;, x)</span><br><span class="line"></span><br><span class="line">  html(x)</span><br><span class="line">&#125;</span><br><span class="line">escape.list &lt;- function(x) &#123;</span><br><span class="line">  lapply(x, escape)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Now we check that it works</span><br><span class="line">escape(&quot;This is some text.&quot;)</span><br><span class="line">escape(&quot;x &gt; 1 &amp; y &lt; 2&quot;)</span><br><span class="line"></span><br><span class="line"># Double escaping is not a problem</span><br><span class="line">escape(escape(&quot;This is some text. 1 &gt; 2&quot;))</span><br><span class="line"></span><br><span class="line"># And text we know is HTML doesn&apos;t get escaped.</span><br><span class="line">escape(html(&quot;&lt;hr /&gt;&quot;))</span><br></pre></td></tr></table></figure>
<p>Escaping is an important component for many DSLs.</p>
<h3 id="Basic-tag-functions"><a href="#Basic-tag-functions" class="headerlink" title="Basic tag functions"></a>Basic tag functions</h3><p>Next, weâll write a few simple tag functions and then figure out how to generalise this function to cover all possible HTML tags. Letâs start with <code>&lt;p&gt;</code>. HTML tags can have both attributes (e.g., id or class) and children (like <code>&lt;b&gt;</code> or <code>&lt;i&gt;</code>). We need some way of separating these in the function call. Given that attributes are named values and children donât have names, it seems natural to separate using named arguments from unnamed ones. For example, a call to <code>p()</code> might look like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p(&quot;Some text.&quot;, b(&quot;some bold text&quot;), class = &quot;mypara&quot;)</span><br></pre></td></tr></table></figure>
<p>We could list all the possible attributes of the <code>&lt;p&gt;</code> tag in the function definition. However, thatâs hard not only because there are many attributes, but also because itâs possible to use <a href="http://html5doctor.com/html5-custom-data-attributes/" target="_blank" rel="external">custom attributes</a>. Instead, weâll just use <code>...</code> and separate the components based on whether or not they are named. To do this correctly, we need to be aware of an inconsistency in <code>names()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names(c(a = 1, b = 2))</span><br><span class="line">names(c(a = 1, 2))</span><br><span class="line">names(c(1, 2))</span><br></pre></td></tr></table></figure>
<p>With this in mind, we create two helper functions to extract the named and unnamed components of a vector:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">named &lt;- function(x) &#123;</span><br><span class="line">  if (is.null(names(x))) return(NULL)</span><br><span class="line">  x[names(x) != &quot;&quot;]</span><br><span class="line">&#125;</span><br><span class="line">unnamed &lt;- function(x) &#123;</span><br><span class="line">  if (is.null(names(x))) return(x)</span><br><span class="line">  x[names(x) == &quot;&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can now create our <code>p()</code> function. Notice that thereâs one new function here: <code>html_attributes()</code>. It uses a list of name-value pairs to create the correct specification of HTML attributes. Itâs a little complicated (in part, because it deals with some idiosyncracies of HTML that I havenât mentioned.). However, because itâs not that important and doesnât introduce any new ideas, I wonât discuss it here (you can find the source online).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">source(&quot;dsl-html-attributes.r&quot;, local = TRUE)</span><br><span class="line">p &lt;- function(...) &#123;</span><br><span class="line">  args &lt;- list(...)</span><br><span class="line">  attribs &lt;- html_attributes(named(args))</span><br><span class="line">  children &lt;- unlist(escape(unnamed(args)))</span><br><span class="line"></span><br><span class="line">  html(paste0(</span><br><span class="line">    &quot;&lt;p&quot;, attribs, &quot;&gt;&quot;,</span><br><span class="line">    paste(children, collapse = &quot;&quot;),</span><br><span class="line">    &quot;&lt;/p&gt;&quot;</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p(&quot;Some text&quot;)</span><br><span class="line">p(&quot;Some text&quot;, id = &quot;myid&quot;)</span><br><span class="line">p(&quot;Some text&quot;, image = NULL)</span><br><span class="line">p(&quot;Some text&quot;, class = &quot;important&quot;, &quot;data-value&quot; = 10)</span><br></pre></td></tr></table></figure>
<h3 id="Tag-functions"><a href="#Tag-functions" class="headerlink" title="Tag functions"></a>Tag functions</h3><p>With this definition of <code>p()</code>, itâs pretty easy to see how we can apply this approach to different tags: we just need to replace <code>&quot;p&quot;</code> with a variable.  Weâll use a closure to make it easy to generate a tag function given a tag name:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tag &lt;- function(tag) &#123;</span><br><span class="line">  force(tag)</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    args &lt;- list(...)</span><br><span class="line">    attribs &lt;- html_attributes(named(args))</span><br><span class="line">    children &lt;- unlist(escape(unnamed(args)))</span><br><span class="line"></span><br><span class="line">    html(paste0(</span><br><span class="line">      &quot;&lt;&quot;, tag, attribs, &quot;&gt;&quot;,</span><br><span class="line">      paste(children, collapse = &quot;&quot;),</span><br><span class="line">      &quot;&lt;/&quot;, tag, &quot;&gt;&quot;</span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(Weâre forcing the evaluation of <code>tag</code> with the expectation that weâll be calling this function from a loop. This will help to avoid potential bugs caused by lazy evaluation.)</p>
<p>Now we can run our earlier example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- tag(&quot;p&quot;)</span><br><span class="line">b &lt;- tag(&quot;b&quot;)</span><br><span class="line">i &lt;- tag(&quot;i&quot;)</span><br><span class="line">p(&quot;Some text.&quot;, b(&quot;Some bold text&quot;), i(&quot;Some italic text&quot;),</span><br><span class="line">  class = &quot;mypara&quot;)</span><br></pre></td></tr></table></figure>
<p>Before we continue writing functions for every possible HTML tag, we need to create a variant of <code>tag()</code> for void tags. It can be very similar to <code>tag()</code>, but if there are any unnamed tags, it needs to throw an error. Also note that the tag itself will look slightly different:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void_tag &lt;- function(tag) &#123;</span><br><span class="line">  force(tag)</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    args &lt;- list(...)</span><br><span class="line">    if (length(unnamed(args)) &gt; 0) &#123;</span><br><span class="line">      stop(&quot;Tag &quot;, tag, &quot; can not have children&quot;, call. = FALSE)</span><br><span class="line">    &#125;</span><br><span class="line">    attribs &lt;- html_attributes(named(args))</span><br><span class="line"></span><br><span class="line">    html(paste0(&quot;&lt;&quot;, tag, attribs, &quot; /&gt;&quot;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img &lt;- void_tag(&quot;img&quot;)</span><br><span class="line">img(src = &quot;myimage.png&quot;, width = 100, height = 100)</span><br></pre></td></tr></table></figure>
<h3 id="Processing-all-tags"><a href="#Processing-all-tags" class="headerlink" title="Processing all tags"></a>Processing all tags</h3><p>Next we need a list of all the HTML tags:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tags &lt;- c(&quot;a&quot;, &quot;abbr&quot;, &quot;address&quot;, &quot;article&quot;, &quot;aside&quot;, &quot;audio&quot;,</span><br><span class="line">  &quot;b&quot;,&quot;bdi&quot;, &quot;bdo&quot;, &quot;blockquote&quot;, &quot;body&quot;, &quot;button&quot;, &quot;canvas&quot;,</span><br><span class="line">  &quot;caption&quot;,&quot;cite&quot;, &quot;code&quot;, &quot;colgroup&quot;, &quot;data&quot;, &quot;datalist&quot;,</span><br><span class="line">  &quot;dd&quot;, &quot;del&quot;,&quot;details&quot;, &quot;dfn&quot;, &quot;div&quot;, &quot;dl&quot;, &quot;dt&quot;, &quot;em&quot;,</span><br><span class="line">  &quot;eventsource&quot;,&quot;fieldset&quot;, &quot;figcaption&quot;, &quot;figure&quot;, &quot;footer&quot;,</span><br><span class="line">  &quot;form&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;, &quot;head&quot;, &quot;header&quot;,</span><br><span class="line">  &quot;hgroup&quot;, &quot;html&quot;, &quot;i&quot;,&quot;iframe&quot;, &quot;ins&quot;, &quot;kbd&quot;, &quot;label&quot;,</span><br><span class="line">  &quot;legend&quot;, &quot;li&quot;, &quot;mark&quot;, &quot;map&quot;,&quot;menu&quot;, &quot;meter&quot;, &quot;nav&quot;,</span><br><span class="line">  &quot;noscript&quot;, &quot;object&quot;, &quot;ol&quot;, &quot;optgroup&quot;, &quot;option&quot;, &quot;output&quot;,</span><br><span class="line">  &quot;p&quot;, &quot;pre&quot;, &quot;progress&quot;, &quot;q&quot;, &quot;ruby&quot;, &quot;rp&quot;,&quot;rt&quot;, &quot;s&quot;, &quot;samp&quot;,</span><br><span class="line">  &quot;script&quot;, &quot;section&quot;, &quot;select&quot;, &quot;small&quot;, &quot;span&quot;, &quot;strong&quot;,</span><br><span class="line">  &quot;style&quot;, &quot;sub&quot;, &quot;summary&quot;, &quot;sup&quot;, &quot;table&quot;, &quot;tbody&quot;, &quot;td&quot;,</span><br><span class="line">  &quot;textarea&quot;, &quot;tfoot&quot;, &quot;th&quot;, &quot;thead&quot;, &quot;time&quot;, &quot;title&quot;, &quot;tr&quot;,</span><br><span class="line">  &quot;u&quot;, &quot;ul&quot;, &quot;var&quot;, &quot;video&quot;)</span><br><span class="line"></span><br><span class="line">void_tags &lt;- c(&quot;area&quot;, &quot;base&quot;, &quot;br&quot;, &quot;col&quot;, &quot;command&quot;, &quot;embed&quot;,</span><br><span class="line">  &quot;hr&quot;, &quot;img&quot;, &quot;input&quot;, &quot;keygen&quot;, &quot;link&quot;, &quot;meta&quot;, &quot;param&quot;,</span><br><span class="line">  &quot;source&quot;, &quot;track&quot;, &quot;wbr&quot;)</span><br></pre></td></tr></table></figure>
<p>If you look at this list carefully, youâll see there are quite a few tags that have the same name as base R functions (<code>body</code>, <code>col</code>, <code>q</code>, <code>source</code>, <code>sub</code>, <code>summary</code>, <code>table</code>), and others that have the same name as popular packages (e.g., <code>map</code>). This means we donât want to make all the functions available by default, in either the global environment or the package environment. Instead, weâll put them in a list and add some additional code to make it easy to use them when desired. First, we make a named list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag_fs &lt;- c(</span><br><span class="line">  setNames(lapply(tags, tag), tags),</span><br><span class="line">  setNames(lapply(void_tags, void_tag), void_tags)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>This gives us an explicit (but verbose) way to call tag functions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tag_fs$p(&quot;Some text.&quot;, tag_fs$b(&quot;Some bold text&quot;),</span><br><span class="line">  tag_fs$i(&quot;Some italic text&quot;))</span><br></pre></td></tr></table></figure>
<p>We can then finish off our HTML DSL with a function that allows us to evaluate code in the context of that list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with_html &lt;- function(code) &#123;</span><br><span class="line">  eval(substitute(code), tag_fs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This gives us a succinct API which allows us to write HTML when we need it but doesnât clutter up the namespace when we donât.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with_html(body(</span><br><span class="line">  h1(&quot;A heading&quot;, id = &quot;first&quot;),</span><br><span class="line">  p(&quot;Some text &amp;&quot;, b(&quot;some bold text.&quot;)),</span><br><span class="line">  img(src = &quot;myimg.png&quot;, width = 100, height = 100)</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>If you want to access the R function overridden by an HTML tag with the same name inside <code>with_html()</code>, you can use the full <code>package::function</code> specification.</p>
<h3 id="Exercises-48"><a href="#Exercises-48" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>The escaping rules for <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tags are different: you    donât want to escape angle brackets or ampersands, but you do want to    escape <code>&lt;/script&gt;</code> or <code>&lt;/style&gt;</code>.  Adapt the code above to follow these    rules.</li>
<li><p>The use of <code>...</code> for all functions has some big downsides. Thereâs no    input validation and there will be little information in the    documentation or autocomplete about how they are used in the function.    Create a new function that, when given a named list of tags and their    attribute names (like below), creates functions which address this problem.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list(</span><br><span class="line">  a = c(&quot;href&quot;),</span><br><span class="line">  img = c(&quot;src&quot;, &quot;width&quot;, &quot;height&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>All tags should get <code>class</code> and <code>id</code> attributes.</p>
</li>
<li><p>Currently the HTML doesnât look terribly pretty, and itâs hard to see the   structure. How could you adapt <code>tag()</code> to do indenting and formatting?</p>
</li>
</ol>
<h2 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a><a href="id=&quot;latex&quot;">LaTeX</a></h2><p>The next DSL will convert R expressions into their LaTeX math equivalents. (This is a bit like <code>?plotmath</code>, but for text instead of plots.) LaTeX is the lingua franca of mathematicians and statisticians: whenever you want to describe an equation in text (e.g., in an email), you write it as a LaTeX equation. Since many reports are produced using both R and LaTeX, it might be useful to be able to automatically convert mathematical expressions from one language to the other.</p>
<p>Because we need to convert both functions and names, this mathematical DSL will be more complicated than the HTML DSL. Weâll also need to create a âdefaultâ conversion, so that functions we donât know about get a standard conversion. Like the HTML DSL, weâll also write functionals to make it easier to generate the translators.</p>
<p>Before we begin, letâs quickly cover how formulas are expressed in LaTeX.</p>
<h3 id="LaTeX-mathematics"><a href="#LaTeX-mathematics" class="headerlink" title="LaTeX mathematics"></a>LaTeX mathematics</h3><p>LaTeX mathematics are complex. Fortunately, they are <a href="http://en.wikibooks.org/wiki/LaTeX/Mathematics" target="_blank" rel="external">well documented</a>. That said, they have a fairly simple structure:</p>
<ul>
<li>Most simple mathematical equations are written in the same way youâd type  them in R: <code>x * y</code>, <code>z ^ 5</code>. Subscripts are written using <code>_</code> (e.g., <code>x_1</code>).</li>
<li>Special characters start with a <code>\</code>: <code>\pi</code> = Ï, <code>\pm</code> = Â±, and so on.  There are a huge number of symbols available in LaTeX. Googling for  <code>latex math symbols</code> will return many  <a href="http://www.sunilpatel.co.uk/latex-type/latex-math-symbols/" target="_blank" rel="external">lists</a>.  Thereâs even <a href="http://detexify.kirelabs.org/classify.html" target="_blank" rel="external">a service</a> that  will look up the symbol you sketch in the browser.</li>
<li>More complicated functions look like <code>\name{arg1}{arg2}</code>. For example, to  write a fraction youâd use <code>\frac{a}{b}</code>. To write a square root, youâd use  <code>\sqrt{a}</code>.</li>
<li>To group elements together use <code>{}</code>: i.e., <code>x ^ a + b</code> vs. <code>x ^ {a + b}</code>.</li>
<li>In good math typesetting, a distinction is made between variables and  functions. But without extra information, LaTeX doesnât know whether  <code>f(a * b)</code> represents calling the function <code>f</code> with input <code>a * b</code>,  or is shorthand for <code>f * (a * b)</code>. If <code>f</code> is a function, you can tell  LaTeX to typeset it using an upright font with <code>\textrm{f}(a * b)</code>.</li>
</ul>
<h3 id="Goal-1"><a href="#Goal-1" class="headerlink" title="Goal"></a>Goal</h3><p>Our goal is to use these rules to automatically convert an R expression to its appropriate LaTeX representation. Weâll tackle this in four stages:</p>
<ul>
<li>Convert known symbols: <code>pi</code> -&gt; <code>\pi</code></li>
<li>Leave other symbols unchanged: <code>x</code> -&gt; <code>x</code>, <code>y</code> -&gt; <code>y</code></li>
<li>Convert known functions to their special forms: <code>sqrt(frac(a, b))</code> -&gt;  <code>\sqrt{\frac{a, b}}</code></li>
<li>Wrap unknown functions with <code>\textrm</code>: <code>f(a)</code> -&gt; <code>\textrm{f}(a)</code></li>
</ul>
<p>Weâll code this translation in the opposite direction of what we did with the HTML DSL. Weâll start with infrastructure, because that makes it easy to experiment with our DSL, and then work our way back down to generate the desired output.</p>
<h3 id="to-math"><a href="#to-math" class="headerlink" title="to_math"></a><code>to_math</code></h3><p>To begin, we need a wrapper function that will convert R expressions into LaTeX math expressions. This will work the same way as <code>to_html()</code>: capture the unevaluated expression and evaluate it in a special environment. However, the special environment is no longer fixed. It will vary depending on the expression. We do this in order to be able to deal with symbols and functions that we havenât yet seen.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">to_math &lt;- function(x) &#123;</span><br><span class="line">  expr &lt;- substitute(x)</span><br><span class="line">  eval(expr, latex_env(expr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Known-symbols"><a href="#Known-symbols" class="headerlink" title="Known symbols"></a>Known symbols</h3><p>Our first step is to create an environment that will convert the special LaTeX symbols used for Greek, e.g., <code>pi</code> to <code>\pi</code>. This is the same basic trick used in <code>subset</code> that makes it possible to select column ranges by name (<code>subset(mtcars, , cyl:wt)</code>): bind a name to a string in a special environment.</p>
<p>We create that environment by naming a vector, converting the vector into a list, and converting the list into an environment.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">greek &lt;- c(</span><br><span class="line">  &quot;alpha&quot;, &quot;theta&quot;, &quot;tau&quot;, &quot;beta&quot;, &quot;vartheta&quot;, &quot;pi&quot;, &quot;upsilon&quot;,</span><br><span class="line">  &quot;gamma&quot;, &quot;gamma&quot;, &quot;varpi&quot;, &quot;phi&quot;, &quot;delta&quot;, &quot;kappa&quot;, &quot;rho&quot;,</span><br><span class="line">  &quot;varphi&quot;, &quot;epsilon&quot;, &quot;lambda&quot;, &quot;varrho&quot;, &quot;chi&quot;, &quot;varepsilon&quot;,</span><br><span class="line">  &quot;mu&quot;, &quot;sigma&quot;, &quot;psi&quot;, &quot;zeta&quot;, &quot;nu&quot;, &quot;varsigma&quot;, &quot;omega&quot;, &quot;eta&quot;,</span><br><span class="line">  &quot;xi&quot;, &quot;Gamma&quot;, &quot;Lambda&quot;, &quot;Sigma&quot;, &quot;Psi&quot;, &quot;Delta&quot;, &quot;Xi&quot;,</span><br><span class="line">  &quot;Upsilon&quot;, &quot;Omega&quot;, &quot;Theta&quot;, &quot;Pi&quot;, &quot;Phi&quot;)</span><br><span class="line">greek_list &lt;- setNames(paste0(&quot;\\&quot;, greek), greek)</span><br><span class="line">greek_env &lt;- list2env(as.list(greek_list), parent = emptyenv())</span><br></pre></td></tr></table></figure>
<p>We can then check it:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">latex_env &lt;- function(expr) &#123;</span><br><span class="line">  greek_env</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to_math(pi)</span><br><span class="line">to_math(beta)</span><br></pre></td></tr></table></figure>
<h3 id="Unknown-symbols"><a href="#Unknown-symbols" class="headerlink" title="Unknown symbols"></a>Unknown symbols</h3><p>If a symbol isnât Greek, we want to leave it as is. This is tricky because we donât know in advance what symbols will be used, and we canât possibly generate them all. So weâll use a little bit of metaprogramming to find out what symbols are present in an expression. The <code>all_names</code> function takes an expression and does the following: if itâs a name, it converts it to a string; if itâs a call, it recurses down through its arguments.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">all_names &lt;- function(x) &#123;</span><br><span class="line">  if (is.atomic(x)) &#123;</span><br><span class="line">    character()</span><br><span class="line">  &#125; else if (is.name(x)) &#123;</span><br><span class="line">    as.character(x)</span><br><span class="line">  &#125; else if (is.call(x) || is.pairlist(x)) &#123;</span><br><span class="line">    children &lt;- lapply(x[-1], all_names)</span><br><span class="line">    unique(unlist(children))</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    stop(&quot;Don&apos;t know how to handle type &quot;, typeof(x),</span><br><span class="line">      call. = FALSE)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">all_names(quote(x + y + f(a, b, c, 10)))</span><br></pre></td></tr></table></figure>
<p>We now want to take that list of symbols, and convert it to an environment so that each symbol is mapped to its corresponding string representation (e.g., so <code>eval(quote(x), env)</code> yields <code>&quot;x&quot;</code>). We again use the pattern of converting a named character vector to a list, then converting the list to an environment.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">latex_env &lt;- function(expr) &#123;</span><br><span class="line">  names &lt;- all_names(expr)</span><br><span class="line">  symbol_list &lt;- setNames(as.list(names), names)</span><br><span class="line">  symbol_env &lt;- list2env(symbol_list)</span><br><span class="line"></span><br><span class="line">  symbol_env</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to_math(x)</span><br><span class="line">to_math(longvariablename)</span><br><span class="line">to_math(pi)</span><br></pre></td></tr></table></figure>
<p>This works, but we need to combine it with the Greek symbols environment. Since we want to give preference to Greek over defaults (e.g., <code>to_math(pi)</code> should give <code>&quot;\\pi&quot;</code>, not <code>&quot;pi&quot;</code>), <code>symbol_env</code> needs to be the parent of <code>greek_env</code>. To do that, we need to make a copy of <code>greek_env</code> with a new parent. While R doesnât come with a function for cloning environments, we can easily create one by combining two existing functions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clone_env &lt;- function(env, parent = parent.env(env)) &#123;</span><br><span class="line">  list2env(as.list(env), parent = parent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This gives us a function that can convert both known (Greek) and unknown symbols.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">latex_env &lt;- function(expr) &#123;</span><br><span class="line">  # Unknown symbols</span><br><span class="line">  names &lt;- all_names(expr)</span><br><span class="line">  symbol_list &lt;- setNames(as.list(names), names)</span><br><span class="line">  symbol_env &lt;- list2env(symbol_list)</span><br><span class="line"></span><br><span class="line">  # Known symbols</span><br><span class="line">  clone_env(greek_env, symbol_env)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to_math(x)</span><br><span class="line">to_math(longvariablename)</span><br><span class="line">to_math(pi)</span><br></pre></td></tr></table></figure>
<h3 id="Known-functions"><a href="#Known-functions" class="headerlink" title="Known functions"></a>Known functions</h3><p>Next weâll add functions to our DSL. Weâll start with a couple of helper closures that make it easy to add new unary and binary operators. These functions are very simple: they only assemble strings. (Again we use <code>force()</code> to make sure the arguments are evaluated at the right time.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unary_op &lt;- function(left, right) &#123;</span><br><span class="line">  force(left)</span><br><span class="line">  force(right)</span><br><span class="line">  function(e1) &#123;</span><br><span class="line">    paste0(left, e1, right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">binary_op &lt;- function(sep) &#123;</span><br><span class="line">  force(sep)</span><br><span class="line">  function(e1, e2) &#123;</span><br><span class="line">    paste0(e1, sep, e2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using these helpers, we can map a few illustrative examples of converting R to LaTeX. Note that with Râs lexical scoping rules helping us, we can easily provide new meanings for standard functions like <code>+</code>, <code>-</code>, and <code>*</code>, and even <code>(</code> and <code>{</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Binary operators</span><br><span class="line">f_env &lt;- new.env(parent = emptyenv())</span><br><span class="line">f_env$&quot;+&quot; &lt;- binary_op(&quot; + &quot;)</span><br><span class="line">f_env$&quot;-&quot; &lt;- binary_op(&quot; - &quot;)</span><br><span class="line">f_env$&quot;*&quot; &lt;- binary_op(&quot; * &quot;)</span><br><span class="line">f_env$&quot;/&quot; &lt;- binary_op(&quot; / &quot;)</span><br><span class="line">f_env$&quot;^&quot; &lt;- binary_op(&quot;^&quot;)</span><br><span class="line">f_env$&quot;[&quot; &lt;- binary_op(&quot;_&quot;)</span><br><span class="line"></span><br><span class="line"># Grouping</span><br><span class="line">f_env$&quot;&#123;&quot; &lt;- unary_op(&quot;\\left&#123; &quot;, &quot; \\right&#125;&quot;)</span><br><span class="line">f_env$&quot;(&quot; &lt;- unary_op(&quot;\\left( &quot;, &quot; \\right)&quot;)</span><br><span class="line">f_env$paste &lt;- paste</span><br><span class="line"></span><br><span class="line"># Other math functions</span><br><span class="line">f_env$sqrt &lt;- unary_op(&quot;\\sqrt&#123;&quot;, &quot;&#125;&quot;)</span><br><span class="line">f_env$sin &lt;- unary_op(&quot;\\sin(&quot;, &quot;)&quot;)</span><br><span class="line">f_env$log &lt;- unary_op(&quot;\\log(&quot;, &quot;)&quot;)</span><br><span class="line">f_env$abs &lt;- unary_op(&quot;\\left| &quot;, &quot;\\right| &quot;)</span><br><span class="line">f_env$frac &lt;- function(a, b) &#123;</span><br><span class="line">  paste0(&quot;\\frac&#123;&quot;, a, &quot;&#125;&#123;&quot;, b, &quot;&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Labelling</span><br><span class="line">f_env$hat &lt;- unary_op(&quot;\\hat&#123;&quot;, &quot;&#125;&quot;)</span><br><span class="line">f_env$tilde &lt;- unary_op(&quot;\\tilde&#123;&quot;, &quot;&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>We again modify <code>latex_env()</code> to include this environment. It should be the last environment R looks for names in: in other words, <code>sin(sin)</code> should work.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">latex_env &lt;- function(expr) &#123;</span><br><span class="line">  # Known functions</span><br><span class="line">  f_env</span><br><span class="line"></span><br><span class="line">  # Default symbols</span><br><span class="line">  names &lt;- all_names(expr)</span><br><span class="line">  symbol_list &lt;- setNames(as.list(names), names)</span><br><span class="line">  symbol_env &lt;- list2env(symbol_list, parent = f_env)</span><br><span class="line"></span><br><span class="line">  # Known symbols</span><br><span class="line">  greek_env &lt;- clone_env(greek_env, parent = symbol_env)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to_math(sin(x + pi))</span><br><span class="line">to_math(log(x_i ^ 2))</span><br><span class="line">to_math(sin(sin))</span><br></pre></td></tr></table></figure>
<h3 id="Unknown-functions"><a href="#Unknown-functions" class="headerlink" title="Unknown functions"></a>Unknown functions</h3><p>Finally, weâll add a default for functions that we donât yet know about. Like the unknown names, we canât know in advance what these will be, so we again use a little metaprogramming to figure them out:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">all_calls &lt;- function(x) &#123;</span><br><span class="line">  if (is.atomic(x) || is.name(x)) &#123;</span><br><span class="line">    character()</span><br><span class="line">  &#125; else if (is.call(x)) &#123;</span><br><span class="line">    fname &lt;- as.character(x[[1]])</span><br><span class="line">    children &lt;- lapply(x[-1], all_calls)</span><br><span class="line">    unique(c(fname, unlist(children)))</span><br><span class="line">  &#125; else if (is.pairlist(x)) &#123;</span><br><span class="line">    unique(unlist(lapply(x[-1], all_calls), use.names = FALSE))</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    stop(&quot;Don&apos;t know how to handle type &quot;, typeof(x), call. = FALSE)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">all_calls(quote(f(g + b, c, d(a))))</span><br></pre></td></tr></table></figure>
<p>And we need a closure that will generate the functions for each unknown call.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unknown_op &lt;- function(op) &#123;</span><br><span class="line">  force(op)</span><br><span class="line">  function(...) &#123;</span><br><span class="line">    contents &lt;- paste(..., collapse = &quot;, &quot;)</span><br><span class="line">    paste0(&quot;\\mathrm&#123;&quot;, op, &quot;&#125;(&quot;, contents, &quot;)&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And again we update <code>latex_env()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">latex_env &lt;- function(expr) &#123;</span><br><span class="line">  calls &lt;- all_calls(expr)</span><br><span class="line">  call_list &lt;- setNames(lapply(calls, unknown_op), calls)</span><br><span class="line">  call_env &lt;- list2env(call_list)</span><br><span class="line"></span><br><span class="line">  # Known functions</span><br><span class="line">  f_env &lt;- clone_env(f_env, call_env)</span><br><span class="line"></span><br><span class="line">  # Default symbols</span><br><span class="line">  symbols &lt;- all_names(expr)</span><br><span class="line">  symbol_list &lt;- setNames(as.list(symbols), symbols)</span><br><span class="line">  symbol_env &lt;- list2env(symbol_list, parent = f_env)</span><br><span class="line"></span><br><span class="line">  # Known symbols</span><br><span class="line">  greek_env &lt;- clone_env(greek_env, parent = symbol_env)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to_math(f(a * b))</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-49"><a href="#Exercises-49" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Add escaping. The special symbols that should be escaped by adding a backslash    in front of them are <code>\</code>, <code>$</code>, and <code>%</code>. Just as with HTML, youâll need to    make sure you donât end up double-escaping. So youâll need to create a small    S3 class and then use that in function operators. That will also allow you    to embed arbitrary LaTeX if needed.</li>
<li>Complete the DSL to support all the functions that <code>plotmath</code> supports.</li>
<li>Thereâs a repeating pattern in <code>latex_env()</code>: we take a character vector,    do something to each piece, convert it to a list, and then convert the list    to an environment. Write a function that automates this task, and then rewrite    <code>latex_env()</code>.</li>
<li>Study the source code for <code>dplyr</code>. An important part of its structure is    <code>partial_eval()</code> which helps manage expressions when some of the    components refer to variables in the database while others refer to local R    objects. Note that you could use very similar ideas if you needed to    translate small R expressions into other languages, like JavaScript or    Python.</li>
</ol>
<hr>
<h1 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a><a href="id=&quot;performance&quot;">Performance</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source(&quot;performance-microbenchmark.R&quot;)</span><br><span class="line">options(&quot;microbenchmark.unit&quot; = &quot;ns&quot;)</span><br></pre></td></tr></table></figure>
<p>R is not a fast language. This is not an accident. R was purposely designed to make data analysis and statistics easier for you to do. It was not designed to make life easier for your computer. While R is slow compared to other programming languages, for most purposes, itâs fast enough.</p>
<p>The goal of this part of the book is to give you a deeper understanding of Râs performance characteristics. In this chapter, youâll learn about some of the trade-offs that R has made, valuing flexibility over performance. The following four chapters will give you the skills to improve the speed of your code when you need to:</p>
<ul>
<li>In <a href="#profiling">Profiling</a>, youâll learn how to systematically make your  code faster. First you figure whatâs slow, and then you apply some general  techniques to make the slow parts faster.</li>
<li>In <a href="#memory">Memory</a>, youâll learn about how R uses memory, and how  garbage collection and copy-on-modify affect performance and memory usage.</li>
<li>For really high-performance code, you can move outside of R and use  another programming language. <a href="#rcpp">Rcpp</a> will teach you the absolute  minimum you need to know about C++ so you can write fast code using the  Rcpp package.</li>
<li>To really understand the performance of built-in base functions,  youâll need to learn a little bit about Râs C API. In <a href="#c-api">Râs C  interface</a>, youâll learn a little about Râs C internals.</li>
</ul>
<p>Letâs get started by learning more about why R is slow.</p>
<h2 id="Why-is-R-slow"><a href="#Why-is-R-slow" class="headerlink" title="Why is R slow?"></a><a href="id=&quot;why-is-r-slow&quot;">Why is R slow?</a></h2><p>To understand Râs performance, it helps to think about R as both a language and as an implementation of that language. The R-language is abstract: it defines what R code means and how it should work. The implementation is concrete: it reads R code and computes a result. The most popular implementation is the one from <a href="http://r-project.org" target="_blank" rel="external">r-project.org</a>. Iâll call that implementation GNU-R to distinguish it from R-language, and from the other implementations Iâll discuss later in the chapter.</p>
<p>The distinction between R-language and GNU-R is a bit murky because the R-language is not formally defined. While there is the <a href="http://cran.r-project.org/doc/manuals/R-lang.html" target="_blank" rel="external">R language definition</a>, it is informal and incomplete. The R-language is mostly defined in terms of how GNU-R works. This is in contrast to other languages, like <a href="http://isocpp.org/std/the-standard" target="_blank" rel="external">C++</a> and <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank" rel="external">javascript</a>, that make a clear distinction between language and implementation by laying out formal specifications that describe in minute detail how every aspect of the language should work. Nevertheless, the distinction between R-language and GNU-R is still useful: poor performance due to the language is hard to fix without breaking existing code; fixing poor performance due to the implementation is easier.</p>
<p>In <a href="#language-performance">Language performance</a>, I discuss some of the ways in which the design of the R-language imposes fundamental constraints on Râs speed. In <a href="#implementation-performance">Implementation performance</a>, I discuss why GNU-R is currently far from the theoretical maximum, and why improvements in performance happen so slowly. While itâs hard to know exactly how much faster a better implementation could be, a &gt;10x improvement in speed seems achievable. In <a href="#faster-r">alternative implementations</a>, I discuss some of the promising new implementations of R, and describe one important technique they use to make R code run faster.</p>
<p>Beyond performance limitations due to design and implementation, it has to be said that a lot of R code is slow simply because itâs poorly written. Few R users have any formal training in programming or software development. Fewer still write R code for a living. Most people use R to understand data: itâs more important to get an answer quickly than to develop a system that will work in a wide variety of situations. This means that itâs relatively easy to make most R code much faster, as weâll see in the following chapters.</p>
<p>Before we examine some of the slower parts of the R-language and GNU-R, we need to learn a little about benchmarking so that we can give our intuitions about performance a concrete foundation.</p>
<h2 id="Microbenchmarking"><a href="#Microbenchmarking" class="headerlink" title="Microbenchmarking"></a><a href="id=&quot;microbenchmarking&quot;">Microbenchmarking</a></h2><p>A microbenchmark is a measurement of the performance of a very small piece of code, something that might take microseconds (Âµs) or nanoseconds (ns) to run. Iâm going to use microbenchmarks to demonstrate the performance of very low-level pieces of R code, which help develop your intuition for how R works. This intuition, by-and-large, is not useful for increasing the speed of real code. The observed differences in microbenchmarks will typically be dominated by higher-order effects in real code; a deep understanding of subatomic physics is not very helpful when baking. Donât change the way you code because of these microbenchmarks. Instead wait until youâve read the practical advice in the following chapters.</p>
<p>The best tool for microbenchmarking in R is the <a href="http://cran.r-project.org/web/packages/microbenchmark/" target="_blank" rel="external">microbenchmark</a> package. It provides very precise timings, making it possible to compare operations that only take a tiny amount of time. For example, the following code compares the speed of two ways of computing a square root.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library(microbenchmark)</span><br><span class="line"></span><br><span class="line">x &lt;- runif(100)</span><br><span class="line">microbenchmark(</span><br><span class="line">  sqrt(x),</span><br><span class="line">  x ^ 0.5</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>By default, <code>microbenchmark()</code> runs each expression 100 times (controlled by the <code>times</code> parameter). In the process, it also randomises the order of the expressions. It summarises the results with a minimum (<code>min</code>), lower quartile (<code>lq</code>), median, upper quartile (<code>uq</code>), and maximum (<code>max</code>). Focus on the median, and use the upper and lower quartiles (<code>lq</code> and <code>uq</code>) to get a feel for the variability. In this example, you can see that using the special purpose <code>sqrt()</code> function is faster than the general exponentiation operator.</p>
<p>As with all microbenchmarks, pay careful attention to the units: each computation takes about 800 ns, 800 billionths of a second. To help calibrate the impact of a microbenchmark on run time, itâs useful to think about how many times a function needs to run before it takes a second. If a microbenchmark takes:</p>
<ul>
<li>1 ms, then one thousand calls takes a second</li>
<li>1 Âµs, then one million calls takes a second</li>
<li>1 ns, then one billion calls takes a second</li>
</ul>
<p>The <code>sqrt()</code> function takes about 800 ns, or 0.8 Âµs, to compute the square root of 100 numbers. That means if you repeated the operation a million times, it would take 0.8 s. So changing the way you compute the square root is unlikely to significantly affect real code.</p>
<h3 id="Exercises-50"><a href="#Exercises-50" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>Instead of using <code>microbenchmark()</code>, you could use the built-in function   <code>system.time()</code>. But <code>system.time()</code> is much less precise, so youâll   need to repeat each operation many times with a loop, and then divide   to find the average time of each operation, as in the code below.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n &lt;- 1:1e6</span><br><span class="line">system.time(for (i in n) sqrt(x)) / length(n)</span><br><span class="line">system.time(for (i in n) x ^ 0.5) / length(n)</span><br></pre></td></tr></table></figure>
<p> How do the estimates from <code>system.time()</code> compare to those from    <code>microbenchmark()</code>? Why are they different?</p>
</li>
<li><p>Here are two other ways to compute the square root of a vector. Which    do you think will be fastest? Which will be slowest? Use microbenchmarking    to test your answers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x ^ (1 / 2)</span><br><span class="line">exp(log(x) / 2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Use microbenchmarking to rank the basic arithmetic operators (<code>+</code>, <code>-</code>,    <code>*</code>, <code>/</code>, and <code>^</code>) in terms of their speed. Visualise the results. Compare    the speed of arithmetic on integers vs. doubles.</p>
</li>
<li>You can change the units in which the microbenchmark results are    expressed with the <code>unit</code> parameter. Use <code>unit = &quot;eps&quot;</code> to show    the number of evaluations needed to take 1 second. Repeat the benchmarks    above with the eps unit. How does this change your intuition for performance?</li>
</ol>
<h2 id="Language-performance"><a href="#Language-performance" class="headerlink" title="Language performance"></a><a href="id=&quot;language-performance&quot;">Language performance</a></h2><p>In this section, Iâll explore three trade-offs that limit the performance of the R-language: extreme dynamism, name lookup with mutable environments, and lazy evaluation of function arguments. Iâll illustrate each trade-off with a microbenchmark, showing how it slows GNU-R down. I benchmark GNU-R because you canât benchmark the R-language (it canât run code). This means that the results are only suggestive of the cost of these design decisions, but are nevertheless useful. Iâve picked these three examples to illustrate some of the trade-offs that are key to language design: the designer must balance speed, flexibility, and ease of implementation.</p>
<p>If youâd like to learn more about the performance characteristics of the R-language and how they affect real code, I highly recommend <a href="http://r.cs.purdue.edu/pub/ecoop12.pdf" target="_blank" rel="external">âEvaluating the Design of the R Languageâ</a> by Floreal Morandat, Brandon Hill, Leo Osvald, and Jan Vitek. It uses a powerful methodology that combines a modified R interpreter and a wide set of code found in the wild.</p>
<h3 id="Extreme-dynamism"><a href="#Extreme-dynamism" class="headerlink" title="Extreme dynamism"></a><a href="id=&quot;extreme-dynamism&quot;">Extreme dynamism</a></h3><p>R is an extremely dynamic programming language. Almost anything can be modified after it is created. To give just a few examples, you can:</p>
<ul>
<li>Change the body, arguments, and environment of functions.</li>
<li>Change the S4 methods for a generic.</li>
<li>Add new fields to an S3 object, or even change its class.</li>
<li>Modify objects outside of the local environment with <code>&lt;&lt;-</code>.</li>
</ul>
<p>Pretty much the only things you canât change are objects in sealed namespaces, which are created when you load a package.</p>
<p>The advantage of dynamism is that you need minimal upfront planning. You can change your mind at any time, iterating your way to a solution without having to start afresh. The disadvantage of dynamism is that itâs difficult to predict exactly what will happen with a given function call. This is a problem because the easier it is to predict whatâs going to happen, the easier it is for an interpreter or compiler to make an optimisation. (If youâd like more details, Charles Nutter expands on this idea at <a href="http://blog.headius.com/2013/05/on-languages-vms-optimization-and-way.html" target="_blank" rel="external">On Languages, VMs, Optimization, and the Way of the World</a>.) If an interpreter canât predict whatâs going to happen, it has to consider many options before it finds the right one. For example, the following loop is slow in R, because R doesnât know that <code>x</code> is always an integer. That means R has to look for the right <code>+</code> method (i.e., is it adding doubles, or integers?) in every iteration of the loop.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 0L</span><br><span class="line">for (i in 1:1e6) &#123;</span><br><span class="line">  x &lt;- x + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The cost of finding the right method is higher for non-primitive functions. The following microbenchmark illustrates the cost of method dispatch for S3, S4, and RC. I create a generic and a method for each OO system, then call the generic and see how long it takes to find and call the method. I also time how long it takes to call the bare function for comparison.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x) NULL</span><br><span class="line"></span><br><span class="line">s3 &lt;- function(x) UseMethod(&quot;s3&quot;)</span><br><span class="line">s3.integer &lt;- f</span><br><span class="line"></span><br><span class="line">A &lt;- setClass(&quot;A&quot;, representation(a = &quot;list&quot;))</span><br><span class="line">setGeneric(&quot;s4&quot;, function(x) standardGeneric(&quot;s4&quot;))</span><br><span class="line">setMethod(s4, &quot;A&quot;, f)</span><br><span class="line"></span><br><span class="line">B &lt;- setRefClass(&quot;B&quot;, methods = list(rc = f))</span><br><span class="line"></span><br><span class="line">a &lt;- A()</span><br><span class="line">b &lt;- B$new()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">microbenchmark(</span><br><span class="line">  fun = f(),</span><br><span class="line">  S3 = s3(1L),</span><br><span class="line">  S4 = s4(a),</span><br><span class="line">  RC = b$rc()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>On my computer, the bare function takes about 200 ns. S3 method dispatch takes an additional 2,000 ns; S4 dispatch, 11,000 ns; and RC dispatch, 10,000 ns. S3 and S4 method dispatch are expensive because R must search for the right method every time the generic is called; it might have changed between this call and the last. R could do better by caching methods between calls, but caching is hard to do correctly and a notorious source of bugs.</p>
<h3 id="Name-lookup-with-mutable-environments"><a href="#Name-lookup-with-mutable-environments" class="headerlink" title="Name lookup with mutable environments"></a>Name lookup with mutable environments</h3><p>Itâs surprisingly difficult to find the value associated with a name in the R-language. This is due to combination of lexical scoping and extreme dynamism. Take the following example. Each time we print <code>a</code> it comes from a different environment:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- 1</span><br><span class="line">f &lt;- function() &#123;</span><br><span class="line">  g &lt;- function() &#123;</span><br><span class="line">    print(a)</span><br><span class="line">    assign(&quot;a&quot;, 2, envir = parent.frame())</span><br><span class="line">    print(a)</span><br><span class="line">    a &lt;- 3</span><br><span class="line">    print(a)</span><br><span class="line">  &#125;</span><br><span class="line">  g()</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>This means that you canât do name lookup just once: you have to start from scratch each time. This problem is exacerbated by the fact that almost every operation is a lexically scoped function call. You might think the following simple function calls two functions: <code>+</code> and <code>^</code>. In fact, it calls four because <code>{</code> and <code>(</code> are regular functions in R.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(x, y) &#123;</span><br><span class="line">  (x + y) ^ 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since these functions are in the global environment, R has to look through every environment in the search path, which could easily be 10 or 20 environments. The following microbenchmark hints at the performance costs. We create four versions of <code>f()</code>, each with one more environment (containing 26 bindings) between the environment of <code>f()</code> and the base environment where <code>+</code>, <code>^</code>, <code>(</code>, and <code>{</code> are defined.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">random_env &lt;- function(parent = globalenv()) &#123;</span><br><span class="line">  letter_list &lt;- setNames(as.list(runif(26)), LETTERS)</span><br><span class="line">  list2env(letter_list, envir = new.env(parent = parent))</span><br><span class="line">&#125;</span><br><span class="line">set_env &lt;- function(f, e) &#123;</span><br><span class="line">  environment(f) &lt;- e</span><br><span class="line">  f</span><br><span class="line">&#125;</span><br><span class="line">f2 &lt;- set_env(f, random_env())</span><br><span class="line">f3 &lt;- set_env(f, random_env(environment(f2)))</span><br><span class="line">f4 &lt;- set_env(f, random_env(environment(f3)))</span><br><span class="line"></span><br><span class="line">microbenchmark(</span><br><span class="line">  f(1, 2),</span><br><span class="line">  f2(1, 2),</span><br><span class="line">  f3(1, 2),</span><br><span class="line">  f4(1, 2),</span><br><span class="line">  times = 10000</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Each additional environment between <code>f()</code> and the base environment makes the function slower by about 30 ns.</p>
<p>It might be possible to implement a caching system so that R only needs to look up the value of each name once. This is hard because there are so many ways to change the value associated with a name: <code>&lt;&lt;-</code>, <code>assign()</code>, <code>eval()</code>, and so on. Any caching system would have to know about these functions to make sure the cache was correctly invalidated and you didnât get an out-of-date value.</p>
<p>Another simple fix would be to add more built-in constants that you canât override. This, for example, would mean that R always knew exactly what <code>+</code>, <code>-</code>, <code>{</code>, and <code>(</code> meant, and you wouldnât have to repeatedly look up their definitions. That would make the interpreter more complicated (because there are more special cases) and hence harder to maintain, and the language less flexible. This would change the R-language, but it would be unlikely to affect much existing code because itâs such a bad idea to override functions like <code>{</code> and <code>(</code>.</p>
<h3 id="Lazy-evaluation-overhead"><a href="#Lazy-evaluation-overhead" class="headerlink" title="Lazy evaluation overhead"></a>Lazy evaluation overhead</h3><p>In R, function arguments are evaluated lazily (as discussed in <a href="#lazy-evaluation">lazy evaluation</a> and <a href="#capturing-expressions">capturing expressions</a>). To implement lazy evaluation, R uses a promise object that contains the expression needed to compute the result and the environment in which to perform the computation. Creating these objects has some overhead, so each additional argument to a function decreases its speed a little.</p>
<p>The following microbenchmark compares the runtime of a very simple function. Each version of the function has one additional argument. This suggests that adding an additional argument slows the function down by ~20 ns.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f0 &lt;- function() NULL</span><br><span class="line">f1 &lt;- function(a = 1) NULL</span><br><span class="line">f2 &lt;- function(a = 1, b = 1) NULL</span><br><span class="line">f3 &lt;- function(a = 1, b = 2, c = 3) NULL</span><br><span class="line">f4 &lt;- function(a = 1, b = 2, c = 4, d = 4) NULL</span><br><span class="line">f5 &lt;- function(a = 1, b = 2, c = 4, d = 4, e = 5) NULL</span><br><span class="line">microbenchmark(f0(), f1(), f2(), f3(), f4(), f5(), times = 10000)</span><br></pre></td></tr></table></figure>
<p>In most other programming languages there is little overhead for adding extra arguments. Many compiled languages will even warn you if arguments are never used (like in the above example), and automatically remove them from the function.</p>
<h3 id="Exercises-51"><a href="#Exercises-51" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><code>scan()</code> has the most arguments (21) of any base function. About how    much time does it take to make 21 promises each time scan is called?    Given a simple input (e.g., <code>scan(text = &quot;1 2 3&quot;, quiet = T)</code>) what    proportion of the total run time is due to creating those promises?</li>
<li>Read <a href="http://r.cs.purdue.edu/pub/ecoop12.pdf" target="_blank" rel="external">âEvaluating the Design of the R Languageâ</a>. What other aspects of the R-language slow it    down? Construct microbenchmarks to illustrate.</li>
<li>How does the performance of S3 method dispatch change with the length    of the class vector? How does performance of S4 method dispatch change    with number of superclasses? How about RC?</li>
<li>What is the cost of multiple inheritance and multiple dispatch on    S4 method dispatch?</li>
<li>Why is the cost of name lookup less for functions in the base package?</li>
</ol>
<h2 id="Implementation-performance"><a href="#Implementation-performance" class="headerlink" title="Implementation performance"></a><a href="id=&quot;implementation-performance&quot;">Implementation performance</a></h2><p>The design of the R language limits its maximum theoretical performance, but GNU-R is currently nowhere near that maximum. There are many things that can (and will) be done to improve performance. This section discusses some aspects of GNU-R that are slow not because of their definition, but because of their implementation.</p>
<p>R is over 20 years old. It contains nearly 800,000 lines of code (about 45% C, 19% R, and 17% Fortran). Changes to base R can only be made by members of the R Core Team (or R-core for short). Currently R-core has <a href="http://www.r-project.org/contributors.html" target="_blank" rel="external">twenty members</a>, but only six are active in day-to-day development. No one on R-core works full time on R. Most are statistics professors who can only spend a relatively small amount of their time on R. Because of the care that must be taken to avoid breaking existing code, R-core tends to be very conservative about accepting new code. It can be frustrating to see R-core reject proposals that would improve performance. However, the overriding concern for R-core is not to make R fast, but to build a stable platform for data analysis and statistics.</p>
<p>Below, Iâll show two small, but illustrative, examples of parts of R that are currently slow but could, with some effort, be made faster. They are not critical parts of base R, but they have been sources of frustration for me in the past. As with all microbenchmarks, these wonât affect the performance of most code, but can be important for special cases.</p>
<h3 id="Extracting-a-single-value-from-a-data-frame"><a href="#Extracting-a-single-value-from-a-data-frame" class="headerlink" title="Extracting a single value from a data frame"></a>Extracting a single value from a data frame</h3><p>The following microbenchmark shows seven ways to access a single value (the number in the bottom-right corner) from the built-in <code>mtcars</code> dataset. The variation in performance is startling: the slowest method takes 30x longer than the fastest. Thereâs no reason that there has to be such a huge difference in performance. Itâs simply that no one has had the time to fix it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">microbenchmark(</span><br><span class="line">  &quot;[32, 11]&quot;      = mtcars[32, 11],</span><br><span class="line">  &quot;$carb[32]&quot;     = mtcars$carb[32],</span><br><span class="line">  &quot;[[c(11, 32)]]&quot; = mtcars[[c(11, 32)]],</span><br><span class="line">  &quot;[[11]][32]&quot;    = mtcars[[11]][32],</span><br><span class="line">  &quot;.subset2&quot;      = .subset2(mtcars, 11)[32]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="ifelse-pmin-and-pmax"><a href="#ifelse-pmin-and-pmax" class="headerlink" title="ifelse(), pmin(), and pmax()"></a><code>ifelse()</code>, <code>pmin()</code>, and <code>pmax()</code></h3><p>Some base functions are known to be slow. For example, take the following three implementations of <code>squish()</code>, a function that ensures that the smallest value in a vector is at least <code>a</code> and its largest value is at most <code>b</code>. The first implementation, <code>squish_ife()</code>, uses <code>ifelse()</code>. <code>ifelse()</code> is known to be slow because it is relatively general and must evaluate all arguments fully. The second implementation, <code>squish_p()</code>, uses <code>pmin()</code> and <code>pmax()</code>. Because these two functions are so specialised, one might expect that they would be fast. However, theyâre actually rather slow. This is because they can take any number of arguments and they have to do some relatively complicated checks to determine which method to use. The final implementation uses basic subassignment.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">squish_ife &lt;- function(x, a, b) &#123;</span><br><span class="line">  ifelse(x &lt;= a, a, ifelse(x &gt;= b, b, x))</span><br><span class="line">&#125;</span><br><span class="line">squish_p &lt;- function(x, a, b) &#123;</span><br><span class="line">  pmax(pmin(x, b), a)</span><br><span class="line">&#125;</span><br><span class="line">squish_in_place &lt;- function(x, a, b) &#123;</span><br><span class="line">  x[x &lt;= a] &lt;- a</span><br><span class="line">  x[x &gt;= b] &lt;- b</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x &lt;- runif(100, -1.5, 1.5)</span><br><span class="line">microbenchmark(</span><br><span class="line">  squish_ife      = squish_ife(x, -1, 1),</span><br><span class="line">  squish_p        = squish_p(x, -1, 1),</span><br><span class="line">  squish_in_place = squish_in_place(x, -1, 1),</span><br><span class="line">  unit = &quot;us&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Using <code>pmin()</code> and <code>pmax()</code> is about 3x faster than <code>ifelse()</code>, and using subsetting directly is about twice as fast again. We can often do even better by using C++. The following example compares the best R implementation to a relatively simple, if verbose, implementation in C++. Even if youâve never used C++, you should still be able to follow the basic strategy: loop over every element in the vector and perform a different action depending on whether or not the value is less than <code>a</code> and/or greater than <code>b</code>. The C++ implementation is around 3x faster than the best pure R implementation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">NumericVector squish_cpp(NumericVector x, double a, double b) &#123;</span><br><span class="line">  int n = x.length();</span><br><span class="line">  NumericVector out(n);</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    double xi = x[i];</span><br><span class="line">    if (xi &lt; a) &#123;</span><br><span class="line">      out[i] = a;</span><br><span class="line">    &#125; else if (xi &gt; b) &#123;</span><br><span class="line">      out[i] = b;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      out[i] = xi;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(Youâll learn how to access this C++ code from R in <a href="#rcpp">Rcpp</a>.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">microbenchmark(</span><br><span class="line">  squish_in_place = squish_in_place(x, -1, 1),</span><br><span class="line">  squish_cpp      = squish_cpp(x, -1, 1),</span><br><span class="line">  unit = &quot;us&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-52"><a href="#Exercises-52" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>The performance characteristics of <code>squish_ife()</code>, <code>squish_p()</code>, and   <code>squish_in_place()</code> vary considerably with the size of <code>x</code>. Explore the   differences. Which sizes lead to the biggest and smallest differences?</li>
<li>Compare the performance costs of extracting an element from a list, a    column from a matrix, and a column from a data frame. Do the same for rows.</li>
</ol>
<h2 id="Alternative-R-implementations"><a href="#Alternative-R-implementations" class="headerlink" title="Alternative R implementations"></a><a href="id=&quot;faster-r&quot;">Alternative R implementations</a></h2><p>There are some exciting new implementations of R. While they all try to stick as closely as possible to the existing language definition, they improve speed by using ideas from modern interpreter design. The four most mature open-source projects are:</p>
<ul>
<li><a href="http://www.pqr-project.org/" target="_blank" rel="external">pqR</a> (pretty quick R) by Radford Neal. Built  on top of R 2.15.0, it fixes many obvious performance issues, and provides  better memory management and some support for automatic multithreading.</li>
<li><a href="http://www.renjin.org/" target="_blank" rel="external">Renjin</a> by BeDataDriven. Renjin uses the  Java virtual machine, and has an extensive  <a href="http://packages.renjin.org/" target="_blank" rel="external">test suite</a>.</li>
<li><a href="https://github.com/allr/fastr" target="_blank" rel="external">FastR</a> by a team from Purdue. FastR  is similar to Renjin, but it makes more ambitious optimisations and  is somewhat less mature.</li>
<li><a href="https://github.com/jtalbot/riposte" target="_blank" rel="external">Riposte</a> by Justin Talbot and  Zachary DeVito. Riposte is experimental and ambitious. For the parts of R it  implements, it is extremely fast. Riposte is described in more detail in  <a href="http://www.justintalbot.com/wp-content/uploads/2012/10/pact080talbot.pdf" target="_blank" rel="external">Riposte: A Trace-Driven Compiler and Parallel VM for Vector Code in  R</a>.</li>
</ul>
<p>These are roughly ordered from most practical to most ambitious. Another project, <a href="http://www.cs.kent.ac.uk/projects/cxxr/" target="_blank" rel="external">CXXR</a> by Andrew Runnalls, does not provide any performance improvements. Instead, it aims to refactor Râs internal C code in order to build a stronger foundation for future development, to keep behaviour identical to GNU-R, and to create better, more extensible documentation of its internals.</p>
<p>R is a huge language and itâs not clear whether any of these approaches will ever become mainstream. Itâs a hard task to make an alternative implementation run all R code in the same way as GNU-R. Can you imagine having to reimplement every function in base R to be not only faster, but also to have exactly the same documented bugs? However, even if these implementations never make a dent in the use of GNU-R, they still provide benefits:</p>
<ul>
<li>Simpler implementations make it easy to validate new approaches before  porting to GNU-R.</li>
<li>Knowing which aspects of the language can be changed with minimal  impact on existing code and maximal impact on performance can help to guide  us to where we should direct our attention.</li>
<li>Alternative implementations put pressure on the R-core to incorporate  performance improvements.</li>
</ul>
<p>One of the most important approaches that pqR, Renjin, FastR, and Riposte are exploring is the idea of deferred evaluation. As Justin Talbot, the author of Riposte, points out: âfor long vectors, Râs execution is completely memory bound. It spends almost all of its time reading and writing vector intermediates to memoryâ. If we could eliminate these intermediate vectors, we could improve performance and reduce memory usage.</p>
<p>The following example shows a very simple example of how deferred evaluation can help. We have three vectors, <code>x</code>, <code>y</code>, <code>z</code>, each containing 1 million elements, and we want to find the sum of <code>x</code> + <code>y</code> where <code>z</code> is TRUE. (This represents a simplification of a pretty common sort of data analysis question.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- runif(1e6)</span><br><span class="line">y &lt;- runif(1e6)</span><br><span class="line">z &lt;- sample(c(T, F), 1e6, rep = TRUE)</span><br><span class="line"></span><br><span class="line">sum((x + y)[z])</span><br></pre></td></tr></table></figure>
<p>In R, this creates two big temporary vectors: <code>x + y</code>, 1 million elements long, and <code>(x + y)[z]</code>, about 500,000 elements long. This means you need to have extra memory available for the intermediate calculation, and you have to shuttle the data back and forth between the CPU and memory. This slows computation down because the CPU canât work at maximum efficiency if itâs always waiting for more data to come in.</p>
<p>However, if we rewrote the function using a loop in a language like C++, we only need one intermediate value: the sum of all the values weâve seen:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">double cond_sum_cpp(NumericVector x, NumericVector y,</span><br><span class="line">                    LogicalVector z) &#123;</span><br><span class="line">  double sum = 0;</span><br><span class="line">  int n = x.length();</span><br><span class="line"></span><br><span class="line">  for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    if (!z[i]) continue;</span><br><span class="line">    sum += x[i] + y[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>On my computer, this approach is about eight times faster than the vectorised R equivalent, which is already pretty fast.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cond_sum_r &lt;- function(x, y, z) &#123;</span><br><span class="line">  sum((x + y)[z])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">microbenchmark(</span><br><span class="line">  cond_sum_cpp(x, y, z),</span><br><span class="line">  cond_sum_r(x, y, z),</span><br><span class="line">  unit = &quot;ms&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>The goal of deferred evaluation is to perform this transformation automatically, so you can write concise R code and have it automatically translated into efficient machine code. Sophisticated translators can also figure out how to make the most of multiple cores. In the above example, if you have four cores, you could split <code>x</code>, <code>y</code>, and <code>z</code> into four pieces performing the conditional sum on each core, then adding together the four individual results. Deferred evaluation can also work with for loops, automatically discovering operations that can be vectorised.</p>
<p>This chapter has discussed some of the fundamental reasons that R is slow. The following chapters will give you the tools to do something about it when it impacts your code.</p>
<hr>
<h1 id="Optimising-code"><a href="#Optimising-code" class="headerlink" title="Optimising code"></a><a href="id=&quot;profiling&quot;">Optimising code</a></h1><blockquote>
<p>âProgrammers waste enormous amounts of time thinking about, or worrying<br>about, the speed of noncritical parts of their programs, and these attempts<br>at efficiency actually have a strong negative impact when debugging and<br>maintenance are considered.â</p>
<p>â Donald Knuth.</p>
</blockquote>
<p>Optimising code to make it run faster is an iterative process:</p>
<ol>
<li>Find the biggest bottleneck (the slowest part of your code).</li>
<li>Try to eliminate it (you may not succeed but thatâs ok).</li>
<li>Repeat until your code is âfast enough.â</li>
</ol>
<p>This sounds easy, but itâs not.</p>
<p>Even experienced programmers have a hard time identifying bottlenecks in their code. Instead of relying on your intuition, you should <strong>profile</strong> your code: use realistic inputs and measure the run-time of each individual operation. Only once youâve identified the most important bottlenecks can you attempt to eliminate them. Itâs difficult to provide general advice on improving performance, but I try my best with six techniques that can be applied in many situations. Iâll also suggest a general strategy for performance optimisation that helps ensure that your faster code will still be correct code.</p>
<p>Itâs easy to get caught up in trying to remove all bottlenecks. Donât! Your time is valuable and is better spent analysing your data, not eliminating possible inefficiencies in your code. Be pragmatic: donât spend hours of your time to save seconds of computer time. To enforce this advice, you should set a goal time for your code and optimise only up to that goal. This means you will not eliminate all bottlenecks. Some you will not get to because youâve met your goal. Others you may need to pass over and accept either because there is no quick and easy solution or because the code is already well optimised and no significant improvement is possible. Accept these possibilities and move on to the next candidate.</p>
<h5 id="Outline-11"><a href="#Outline-11" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#measure-perf">Measuring performance</a> describes how to find the bottlenecks  in your code using line profiling.</li>
<li><a href="#improve-perf">Improving performance</a> outlines seven general strategies for  improving the performance of your code.</li>
<li><a href="#code-organisation">Code organisation</a> teaches you how to organise  your code to make optimisation as easy, and bug free, as possible.</li>
<li><a href="#already-solved">Already solved</a> reminds you to look for existing  solutions.</li>
<li><a href="#be-lazy">Do as little as possible</a> emphasises the importance of  being lazy: often the easiest way to make a function faster is to  let it to do less work.</li>
<li><a href="#vectorise">Vectorise</a> concisely defines vectorisation, and shows you  how to make the most of built-in functions.</li>
<li><a href="#avoid-copies">Avoid copies</a> discusses the performance perils of  copying data.</li>
<li><a href="#byte-code">Byte code compilation</a> shows you how to take advantage of  Râs byte code compiler.</li>
<li><a href="#t-test">Case study: t-test</a> pulls all the pieces together into a case  study showing how to speed up repeated t-tests by ~1000x.</li>
<li><a href="#parallelise">Parallelise</a> teaches you how to use parallelisation to  spread computation across all the cores in your computer.</li>
<li><a href="#more-techniques">Other techniques</a> finishes the chapter with pointers to  more resources that will help you write fast code.</li>
</ul>
<h5 id="Prerequisites-8"><a href="#Prerequisites-8" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><p>In this chapter weâll be using the <code>lineprof</code> package to understand the performance of R code. Get it with:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtools::install_github(&quot;hadley/lineprof&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="Measuring-performance"><a href="#Measuring-performance" class="headerlink" title="Measuring performance"></a><a href="id=&quot;measure-perf&quot;">Measuring performance</a></h2><p>To understand performance, you use a profiler. There are a number of different types of profilers. R uses a fairly simple type called a sampling or statistical profiler. A sampling profiler stops the execution of code every few milliseconds and records which function is currently executing (along with which function called that function, and so on). For example, consider <code>f()</code>, below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">library(lineprof)</span><br><span class="line">f &lt;- function() &#123;</span><br><span class="line">  pause(0.1)</span><br><span class="line">  g()</span><br><span class="line">  h()</span><br><span class="line">&#125;</span><br><span class="line">g &lt;- function() &#123;</span><br><span class="line">  pause(0.1)</span><br><span class="line">  h()</span><br><span class="line">&#125;</span><br><span class="line">h &lt;- function() &#123;</span><br><span class="line">  pause(0.1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(I use <code>pause()</code> instead of <code>Sys.sleep()</code> because <code>Sys.sleep()</code> does not appear in profiling outputs because as far as R can tell, it doesnât use up any computing time.)</p>
<p>If we profiled the execution of <code>f()</code>, stopping the execution of code every 0.1 s, weâd see a profile like below. Each line represents one âtickâ of the profiler (0.1 s in this case), and function calls are nested with <code>&gt;</code>. It shows that the code spends 0.1 s running <code>f()</code>, then 0.2 s running <code>g()</code>, then 0.1 s running <code>h()</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f()</span><br><span class="line">f() &gt; g()</span><br><span class="line">f() &gt; g() &gt; h()</span><br><span class="line">f() &gt; h()</span><br></pre></td></tr></table></figure>
<p>If we actually profile <code>f()</code>, using the code below, weâre unlikely to get such a clear result.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp &lt;- tempfile()</span><br><span class="line">Rprof(tmp, interval = 0.1)</span><br><span class="line">f()</span><br><span class="line">Rprof(NULL)</span><br></pre></td></tr></table></figure>
<p>Thatâs because profiling is hard to do accurately without slowing your code down by many orders of magnitude. The compromise that <code>RProf()</code> makes, sampling, only has minimal impact on the overall performance, but is fundamentally stochastic. Thereâs some variability in both the accuracy of the timer and in the time taken by each operation, so each time you profile youâll get a slightly different answer. Fortunately, pinpoint accuracy is not needed to identify the slowest parts of your code.</p>
<p>Rather than focussing on individual calls, weâll visualise aggregates using the lineprof package. There are a number of other options, like <code>summaryRprof()</code>, the proftools package, and the profr package, but these tools are beyond the scope of this book. I wrote the <code>lineprof</code> package as a simpler way to visualise profiling data. As the name suggests, the fundamental unit of analysis in <code>lineprof()</code> is a line of code. This makes lineprof less precise than the alternatives (because a line of code can contain multiple function calls), but itâs easier to understand the context.</p>
<p>To use <code>lineprof</code>, we first save the code in a file and <code>source()</code> it. Here <code>profiling-example.R</code> contains the definition of <code>f()</code>, <code>g()</code>, and <code>h()</code>. Note that you <em>must</em> use <code>source()</code> to load the code. This is because lineprof uses srcrefs to match up the code to the profile, and the needed srcrefs are only created when you load code from disk. We then use <code>lineprof()</code> to run our function and capture the timing output. Printing this object shows some basic information. For now, weâll just focus on the time column which estimates how long each line took to run and the ref column which tells us which line of code was run. The estimates arenât perfect, but the ratios look about right.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">library(lineprof)</span><br><span class="line">source(&quot;profiling-example.R&quot;)</span><br><span class="line">l &lt;- lineprof(f())</span><br><span class="line">l</span><br><span class="line">#&gt;    time alloc release dups           ref     src</span><br><span class="line">#&gt; 1 0.074 0.001       0    0 profiling.R#2 f/pause</span><br><span class="line">#&gt; 2 0.143 0.002       0    0 profiling.R#3 f/g</span><br><span class="line">#&gt; 3 0.071 0.000       0    0 profiling.R#4 f/h</span><br></pre></td></tr></table></figure>
<p>lineprof provides some functions to navigate through this data structure, but theyâre a bit clumsy. Instead, weâll start an interactive explorer using the shiny package. <code>shine(l)</code> will open a new web page (or if youâre using RStudio, a new pane) that shows your source code annotated with information about how long each line took to run. <code>shine()</code> starts a shiny app which âblocksâ your R session. To exit, youâll need to stop the process using escape or ctrl + c.</p>
<p><img src="screenshots/profiling-lineprof-f.png" alt=""></p>
<p>The <code>t</code> column visualises how much time is spent on each line. (Youâll learn about the other columns in <a href="#memory-profiling">memory profiling</a>.) While not precise, it allows you to spot bottlenecks, and you can get precise numbers by hovering over each bar. This shows that twice as much time is spent on <code>g()</code> as on <code>h()</code>, so it would make sense to drill down into <code>g()</code> for more details. To do so, click <code>g()</code>:</p>
<p><img src="screenshots/profiling-lineprof-g.png" alt=""></p>
<p>Then <code>h()</code>:</p>
<p><img src="screenshots/profiling-lineprof-h.png" alt=""></p>
<p>This technique should allow you to quickly identify the major bottlenecks in your code.</p>
<h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><p>There are some other limitations to profiling:</p>
<ul>
<li>Profiling does not extend to C code. You can see if your R code calls C/C++  code but not what functions are called inside of your C/C++ code. Unfortunately,  tools for profiling compiled code are beyond the scope of this book (i.e., I  have no idea how to do it).</li>
<li>Similarly, you canât see whatâs going on inside primitive functions or byte  code compiled code.</li>
<li>If youâre doing a lot of functional programming with anonymous functions,  it can be hard to figure out exactly which function is being called.  The easiest way to work around this is to name your functions.</li>
<li><p>Lazy evaluation means that arguments are often evaluated inside another  function. For example, in the following code, profiling would make it seem  like <code>i()</code> was called by <code>j()</code> because the argument isnât evaluated until itâs  needed by <code>j()</code>.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i &lt;- function() &#123;</span><br><span class="line">  pause(0.1)</span><br><span class="line">  10</span><br><span class="line">&#125;</span><br><span class="line">j &lt;- function(x) &#123;</span><br><span class="line">  x + 10</span><br><span class="line">&#125;</span><br><span class="line">j(i())</span><br></pre></td></tr></table></figure>
<p>  If this is confusing, you can create temporary variables to force    computation to happen earlier.</p>
</li>
</ul>
<h2 id="Improving-performance"><a href="#Improving-performance" class="headerlink" title="Improving performance"></a><a href="id=&quot;improve-perf&quot;">Improving performance</a></h2><blockquote>
<p>âWe should forget about small efficiencies, say about 97% of the time:<br>premature optimization is the root of all evil. Yet we should not pass up our<br>opportunities in that critical 3%. A good programmer will not be lulled<br>into complacency by such reasoning, he will be wise to look carefully at<br>the critical code; but only after that code has been identified.â</p>
<p>â Donald Knuth.</p>
</blockquote>
<p>Once youâve used profiling to identify a bottleneck, you need to make it faster. The following sections introduce you to a number of techniques that Iâve found broadly useful:</p>
<ol>
<li>Look for existing solutions.</li>
<li>Do less work.</li>
<li>Vectorise.</li>
<li>Parallelise.</li>
<li>Avoid copies.</li>
<li>Byte-code compile.</li>
</ol>
<p>A final technique is to rewrite in a faster language, like C++. Thatâs a big topic and is covered in <a href="#rcpp">Rcpp</a>.</p>
<p>Before we get into specific techniques, Iâll first describe a general strategy and organisational style thatâs useful when working on performance.</p>
<h2 id="Code-organisation"><a href="#Code-organisation" class="headerlink" title="Code organisation"></a><a href="id=&quot;code-organisation&quot;">Code organisation</a></h2><p>There are two traps that are easy to fall into when trying to make your code faster:</p>
<ol>
<li>Writing faster but incorrect code.</li>
<li>Writing code that you think is faster, but is actually no better.</li>
</ol>
<p>The strategy outlined below will help you avoid these pitfalls.</p>
<p>When tackling a bottleneck, youâre likely to come up with multiple approaches. Write a function for each approach, encapsulating all relevant behaviour. This makes it easier to check that each approach returns the correct result and to time how long it takes to run. To demonstrate the strategy, Iâll compare two approaches for computing the mean:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mean1 &lt;- function(x) mean(x)</span><br><span class="line">mean2 &lt;- function(x) sum(x) / length(x)</span><br></pre></td></tr></table></figure>
<p>I recommend that you keep a record of everything you try, even the failures. If a similar problem occurs in the future, itâll be useful to see everything youâve tried. To do this I often use R Markdown, which makes it easy to intermingle code with detailed comments and notes.</p>
<p>Next, generate a representative test case. The case should be big enough to capture the essence of your problem but small enough that it takes only a few seconds to run. You donât want it to take too long because youâll need to run the test case many times to compare approaches. On the other hand, you donât want the case to be too small because then results might not scale up to the real problem.</p>
<p>Use this test case to quickly check that all variants return the same result. An easy way to do so is with <code>stopifnot()</code> and <code>all.equal()</code>. For real problems with fewer possible outputs, you may need more tests to make sure that an approach doesnât accidentally return the correct answer. Thatâs unlikely for the mean.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- runif(100)</span><br><span class="line">stopifnot(all.equal(mean1(x), mean2(x)))</span><br></pre></td></tr></table></figure>
<p>Finally, use the <code>microbenchmark</code> package to compare how long each variation takes to run. For bigger problems, reduce the <code>times</code> parameter so that it only takes a couple of seconds to run. Focus on the median time, and use the upper and lower quartiles to gauge the variability of the measurement.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">microbenchmark(</span><br><span class="line">  mean1(x),</span><br><span class="line">  mean2(x)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>(You might be surprised by the results: <code>mean(x)</code> is considerably slower than <code>sum(x) / length(x)</code>. This is because, among other reasons, <code>mean(x)</code> makes two passes over the vector to be more numerically accurate.)</p>
<p>Before you start experimenting, you should have a target speed that defines when the bottleneck is no longer a problem. Setting such a goal is important because you donât want to spend valuable time over-optimising your code.</p>
<p>If youâd like to see this strategy in action, Iâve used it a few times on stackoverflow:</p>
<ul>
<li><a href="http://stackoverflow.com/questions/22515525#22518603" target="_blank" rel="external">http://stackoverflow.com/questions/22515525#22518603</a></li>
<li><a href="http://stackoverflow.com/questions/22515175#22515856" target="_blank" rel="external">http://stackoverflow.com/questions/22515175#22515856</a></li>
<li><a href="http://stackoverflow.com/questions/3476015#22511936" target="_blank" rel="external">http://stackoverflow.com/questions/3476015#22511936</a></li>
</ul>
<h2 id="Has-someone-already-solved-the-problem"><a href="#Has-someone-already-solved-the-problem" class="headerlink" title="Has someone already solved the problem?"></a><a href="id=&quot;already-solved&quot;">Has someone already solved the problem?</a></h2><p>Once youâve organised your code and captured all the variations you can think of, itâs natural to see what others have done. You are part of a large community, and itâs quite possible that someone has already tackled the same problem. If your bottleneck is a function in a package, itâs worth looking at other packages that do the same thing. Two good places to start are:</p>
<ul>
<li><a href="http://cran.rstudio.com/web/views/" target="_blank" rel="external">CRAN task views</a>. If thereâs a  CRAN task view related to your problem domain, itâs worth looking at  the packages listed there.</li>
<li>Reverse dependencies of Rcpp, as listed on its  <a href="http://cran.r-project.org/web/packages/Rcpp" target="_blank" rel="external">CRAN page</a>. Since these  packages use C++, itâs possible to find a solution to your bottleneck  written in a higher performance language.</li>
</ul>
<p>Otherwise, the challenge is describing your bottleneck in a way that helps you find related problems and solutions. Knowing the name of the problem or its synonyms will make this search much easier. But because you donât know what itâs called, itâs hard to search for it! By reading broadly about statistics and algorithms, you can build up your own knowledge base over time. Alternatively, ask others. Talk to your colleagues and brainstorm some possible names, then search on Google and stackoverflow. Itâs often helpful to restrict your search to R related pages. For Google, try <a href="http://www.rseek.org/" target="_blank" rel="external">rseek</a>. For stackoverflow, restrict your search by including the R tag, <code>[R]</code>, in your search.</p>
<p>As discussed above, record all solutions that you find, not just those that immediately appear to be faster. Some solutions might be initially slower, but because they are easier to optimise they end up being faster. You may also be able to combine the fastest parts from different approaches. If youâve found a solution thatâs fast enough, congratulations! If appropriate, you may want to share your solution with the R community. Otherwise, read on.</p>
<h3 id="Exercises-53"><a href="#Exercises-53" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>What are faster alternatives to <code>lm</code>? Which are specifically designed    to work with larger datasets?</li>
<li>What package implements a version of <code>match()</code> thatâs faster for    repeated lookups? How much faster is it?</li>
<li>List four functions (not just those in base R) that convert a string into a    date time object. What are their strengths and weaknesses?</li>
<li>How many different ways can you compute a 1d density estimate in R?</li>
<li>Which packages provide the ability to compute a rolling mean?</li>
<li>What are the alternatives to <code>optim()</code>?</li>
</ol>
<h2 id="Do-as-little-as-possible"><a href="#Do-as-little-as-possible" class="headerlink" title="Do as little as possible"></a><a href="id=&quot;be-lazy&quot;">Do as little as possible</a></h2><p>The easiest way to make a function faster is to let it do less work. One way to do that is use a function tailored to a more specific type of input or ouput, or a more specific problem. For example:</p>
<ul>
<li><code>rowSums()</code>, <code>colSums()</code>, <code>rowMeans()</code>, and <code>colMeans()</code> are faster than  equivalent invocations that use <code>apply()</code> because they are vectorised (the  topic of the next section).</li>
<li><code>vapply()</code> is faster than <code>sapply()</code> because it pre-specifies the output  type.</li>
<li>If you want to see if a vector contains a single value, <code>any(x == 10)</code>  is much faster than <code>10 %in% x</code>. This is because testing equality is simpler  than testing inclusion in a set.</li>
</ul>
<p>Having this knowledge at your fingertips requires knowing that alternative functions exist: you need to have a good vocabulary. Start with <a href="#vocabulary">the basics</a>, and expand your vocab by regularly reading R code. Good places to read code are the <a href="https://stat.ethz.ch/mailman/listinfo/r-help" target="_blank" rel="external">R-help mailing list</a> and <a href="http://stackoverflow.com/questions/tagged/r" target="_blank" rel="external">stackoverflow</a>.</p>
<p>Some functions coerce their inputs into a specific type. If your input is not the right type, the function has to do extra work. Instead, look for a function that works with your data as it is, or consider changing the way you store your data. The most common example of this problem is using <code>apply()</code> on a data frame. <code>apply()</code> always turns its input into a matrix. Not only is this error prone (because a data frame is more general than a matrix), it is also slower.</p>
<p>Other functions will do less work if you give them more information about the problem. Itâs always worthwhile to carefully read the documentation and experiment with different arguments. Some examples that Iâve discovered in the past include:</p>
<ul>
<li><code>read.csv()</code>: specify known column types with <code>colClasses</code>.</li>
<li><code>factor()</code>: specify known levels with <code>levels</code>.</li>
<li><code>cut()</code>: donât generate labels with <code>labels = FALSE</code> if you donât need them,  or, even better, use <code>findInterval()</code> as mentioned in the âsee alsoâ section  of the documentation.</li>
<li><code>unlist(x, use.names = FALSE)</code> is much faster than <code>unlist(x)</code>.</li>
<li><code>interaction()</code>: if you only need combinations that exist in the data, use  <code>drop = TRUE</code>.</li>
</ul>
<p>Sometimes you can make a function faster by avoiding method dispatch. As we saw in (<a href="#extreme-dynamism">Extreme dynamism</a>), method dispatch in R can be costly. If youâre calling a method in a tight loop, you can avoid some of the costs by doing the method lookup only once:</p>
<ul>
<li>For S3, you can do this by calling <code>generic.class()</code> instead of <code>generic()</code>.</li>
<li>For S4, you can do this by using <code>findMethod()</code> to find the method, saving  it to a variable, and then calling that function.</li>
</ul>
<p>For example, calling <code>mean.default()</code> quite a bit faster than calling <code>mean()</code> for small vectors:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- runif(1e2)</span><br><span class="line"></span><br><span class="line">microbenchmark(</span><br><span class="line">  mean(x),</span><br><span class="line">  mean.default(x)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>This optimisation is a little risky. While <code>mean.default()</code> is almost twice as fast, itâll fail in surprising ways if <code>x</code> is not a numeric vector. You should only use it if you know for sure what <code>x</code> is.</p>
<p>Knowing that youâre dealing with a specific type of input can be another way to write faster code. For example, <code>as.data.frame()</code> is quite slow because it coerces each element into a data frame and then <code>rbind()</code>s them together. If you have a named list with vectors of equal length, you can directly transform it into a data frame. In this case, if youâre able to make strong assumptions about your input, you can write a method thatâs about 20x faster than the default.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">quickdf &lt;- function(l) &#123;</span><br><span class="line">  class(l) &lt;- &quot;data.frame&quot;</span><br><span class="line">  attr(l, &quot;row.names&quot;) &lt;- .set_row_names(length(l[[1]]))</span><br><span class="line">  l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l &lt;- lapply(1:26, function(i) runif(1e3))</span><br><span class="line">names(l) &lt;- letters</span><br><span class="line"></span><br><span class="line">microbenchmark(</span><br><span class="line">  quick_df      = quickdf(l),</span><br><span class="line">  as.data.frame = as.data.frame(l)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Again, note the trade-off. This method is fast because itâs dangerous. If you give it bad inputs, youâll get a corrupt data frame:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quickdf(list(x = 1, y = 1:2))</span><br></pre></td></tr></table></figure>
<p>To come up with this minimal method, I carefully read through and then rewrote the source code for <code>as.data.frame.list()</code> and <code>data.frame()</code>. I made many small changes, each time checking that I hadnât broken existing behaviour. After several hours work, I was able to isolate the minimal code shown above. This is a very useful technique. Most base R functions are written for flexibility and functionality, not performance. Thus, rewriting for your specific need can often yield substantial improvements. To do this, youâll need to read the source code. It can be complex and confusing, but donât give up!</p>
<p>The following example shows a progressive simplification of the <code>diff()</code> function if you only want computing differences between adjacent values. At each step, I replace one argument with a specific case, and then check to see that the function still works. The initial function is long and complicated, but by restricting the arguments I not only make it around twice as fast, I also make it easier to understand.</p>
<p>First, I take the code of <code>diff()</code> and reformat it to my style:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">diff1 &lt;- function (x, lag = 1L, differences = 1L) &#123;</span><br><span class="line">  ismat &lt;- is.matrix(x)</span><br><span class="line">  xlen &lt;- if (ismat) dim(x)[1L] else length(x)</span><br><span class="line">  if (length(lag) &gt; 1L || length(differences) &gt; 1L ||</span><br><span class="line">      lag &lt; 1L || differences &lt; 1L)</span><br><span class="line">    stop(&quot;&apos;lag&apos; and &apos;differences&apos; must be integers &gt;= 1&quot;)</span><br><span class="line"></span><br><span class="line">  if (lag * differences &gt;= xlen) &#123;</span><br><span class="line">    return(x[0L])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  r &lt;- unclass(x)</span><br><span class="line">  i1 &lt;- -seq_len(lag)</span><br><span class="line">  if (ismat) &#123;</span><br><span class="line">    for (i in seq_len(differences)) &#123;</span><br><span class="line">      r &lt;- r[i1, , drop = FALSE] -</span><br><span class="line">        r[-nrow(r):-(nrow(r) - lag + 1L), , drop = FALSE]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    for (i in seq_len(differences)) &#123;</span><br><span class="line">      r &lt;- r[i1] - r[-length(r):-(length(r) - lag + 1L)]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class(r) &lt;- oldClass(x)</span><br><span class="line">  r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Next, I assume vector input. This allows me to remove the <code>is.matrix()</code> test and the method that uses matrix subsetting.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">diff2 &lt;- function (x, lag = 1L, differences = 1L) &#123;</span><br><span class="line">  xlen &lt;- length(x)</span><br><span class="line">  if (length(lag) &gt; 1L || length(differences) &gt; 1L ||</span><br><span class="line">      lag &lt; 1L || differences &lt; 1L)</span><br><span class="line">    stop(&quot;&apos;lag&apos; and &apos;differences&apos; must be integers &gt;= 1&quot;)</span><br><span class="line"></span><br><span class="line">  if (lag * differences &gt;= xlen) &#123;</span><br><span class="line">    return(x[0L])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i1 &lt;- -seq_len(lag)</span><br><span class="line">  for (i in seq_len(differences)) &#123;</span><br><span class="line">    x &lt;- x[i1] - x[-length(x):-(length(x) - lag + 1L)]</span><br><span class="line">  &#125;</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br><span class="line">diff2(cumsum(0:10))</span><br></pre></td></tr></table></figure>
<p>I now assume that <code>difference = 1L</code>. This simplifies input checking and eliminates the for loop:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">diff3 &lt;- function (x, lag = 1L) &#123;</span><br><span class="line">  xlen &lt;- length(x)</span><br><span class="line">  if (length(lag) &gt; 1L || lag &lt; 1L)</span><br><span class="line">    stop(&quot;&apos;lag&apos; must be integer &gt;= 1&quot;)</span><br><span class="line"></span><br><span class="line">  if (lag &gt;= xlen) &#123;</span><br><span class="line">    return(x[0L])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i1 &lt;- -seq_len(lag)</span><br><span class="line">  x[i1] - x[-length(x):-(length(x) - lag + 1L)]</span><br><span class="line">&#125;</span><br><span class="line">diff3(cumsum(0:10))</span><br></pre></td></tr></table></figure>
<p>Finally I assume <code>lag = 1L</code>. This eliminates input checking and simplifies subsetting.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">diff4 &lt;- function (x) &#123;</span><br><span class="line">  xlen &lt;- length(x)</span><br><span class="line">  if (xlen &lt;= 1) return(x[0L])</span><br><span class="line"></span><br><span class="line">  x[-1] - x[-xlen]</span><br><span class="line">&#125;</span><br><span class="line">diff4(cumsum(0:10))</span><br></pre></td></tr></table></figure>
<p>Now <code>diff4()</code> is both considerably simpler and considerably faster than <code>diff1()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- runif(100)</span><br><span class="line">microbenchmark(</span><br><span class="line">  diff1(x),</span><br><span class="line">  diff2(x),</span><br><span class="line">  diff3(x),</span><br><span class="line">  diff4(x)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Youâll be able to make <code>diff()</code> even faster for this special case once youâve read <a href="#rcpp">Rcpp</a>.</p>
<p>A final example of doing less work is to use simpler data structures. For example, when working with rows from a data frame, itâs often faster to work with row indices than data frames. For instance, if you wanted to compute a bootstrap estimate of the correlation between two columns in a data frame, there are two basic approaches: you can either work with the whole data frame or with the individual vectors. The following example shows that working with vectors is about twice as fast.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sample_rows &lt;- function(df, i) sample.int(nrow(df), i,</span><br><span class="line">  replace = TRUE)</span><br><span class="line"></span><br><span class="line"># Generate a new data frame containing randomly selected rows</span><br><span class="line">boot_cor1 &lt;- function(df, i) &#123;</span><br><span class="line">  sub &lt;- df[sample_rows(df, i), , drop = FALSE]</span><br><span class="line">  cor(sub$x, sub$y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Generate new vectors from random rows</span><br><span class="line">boot_cor2 &lt;- function(df, i ) &#123;</span><br><span class="line">  idx &lt;- sample_rows(df, i)</span><br><span class="line">  cor(df$x[idx], df$y[idx])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df &lt;- data.frame(x = runif(100), y = runif(100))</span><br><span class="line">microbenchmark(</span><br><span class="line">  boot_cor1(df, 10),</span><br><span class="line">  boot_cor2(df, 10)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-54"><a href="#Exercises-54" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>How do the results change if you compare <code>mean()</code> and <code>mean.default()</code>    on 10,000 observations, rather than on 100?</li>
<li><p>The following code provides an alternative implementation of <code>rowSums()</code>.    Why is it faster for this input?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rowSums2 &lt;- function(df) &#123;</span><br><span class="line">  out &lt;- df[[1L]]</span><br><span class="line">  if (ncol(df) == 1) return(out)</span><br><span class="line"></span><br><span class="line">  for (i in 2:ncol(df)) &#123;</span><br><span class="line">    out &lt;- out + df[[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df &lt;- as.data.frame(</span><br><span class="line">  replicate(1e3, sample(100, 1e4, replace = TRUE))</span><br><span class="line">)</span><br><span class="line">system.time(rowSums(df))</span><br><span class="line">system.time(rowSums2(df))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Whatâs the difference between <code>rowSums()</code> and <code>.rowSums()</code>?</p>
</li>
<li>Make a faster version of <code>chisq.test()</code> that only computes the chi-square    test statistic when the input is two numeric vectors with no missing    values. You can try simplifying <code>chisq.test()</code> or by coding from the    <a href="http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test" target="_blank" rel="external">mathematical definition</a>.</li>
<li>Can you make a faster version of <code>table()</code> for the case of an input of    two integer vectors with no missing values? Can you use it to    speed up your chi-square test?</li>
<li><p>Imagine you want to compute the bootstrap distribution of a sample    correlation using <code>cor_df()</code> and the data in the example below. Given that you    want to run this many times, how can you make this code faster? (Hint: the    function has three components that you can speed up.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n &lt;- 1e6</span><br><span class="line">df &lt;- data.frame(a = rnorm(n), b = rnorm(n))</span><br><span class="line"></span><br><span class="line">cor_df &lt;- function(i) &#123;</span><br><span class="line">  i &lt;- sample(seq(n), n * 0.01)</span><br><span class="line">  cor(q[i, , drop = FALSE])[2,1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Is there a way to vectorise this procedure?</p>
</li>
</ol>
<h2 id="Vectorise"><a href="#Vectorise" class="headerlink" title="Vectorise"></a><a href="id=&quot;vectorise&quot;">Vectorise</a></h2><p>If youâve used R for any length of time, youâve probably heard the admonishment to âvectorise your codeâ. But what does that actually mean? Vectorising your code is not just about avoiding for loops, although thatâs often a step. Vectorising is about taking a âwhole objectâ approach to a problem, thinking about vectors, not scalars. There are two key attributes of a vectorised function:</p>
<ul>
<li>It makes many problems simpler. Instead of having to think about the  components of a vector, you only think about entire vectors.</li>
<li>The loops in a vectorised function are written in C instead of R. Loops in C  are much faster because they have much less overhead.</li>
</ul>
<p><a href="#functionals">Functionals</a> stressed the importance of vectorised code as a higher level abstraction. Vectorisation is also important for writing fast R code. This doesnât mean simply using <code>apply()</code> or <code>lapply()</code>, or even <code>Vectorise()</code>. Those functions improve the interface of a function, but donât fundamentally change performance. Using vectorisation for performance means finding the existing R function that is implemented in C and most closely applies to your problem.</p>
<p>Vectorised functions that apply to many common performance bottlenecks include:</p>
<ul>
<li><p><code>rowSums()</code>, <code>colSums()</code>, <code>rowMeans()</code>, and <code>colMeans()</code>. These vectorised  matrix functions will always be faster than using <code>apply()</code>. You can  sometimes use these functions to build other vectorised functions.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rowAny &lt;- function(x) rowSums(x) &gt; 0</span><br><span class="line">rowAll &lt;- function(x) rowSums(x) == ncol(x)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vectorised subsetting can lead to big improvements in speed. Remember the  techniques behind lookup tables (<a href="#lookup-tables">lookup tables</a>) and matching  and merging by hand (<a href="#matching-merging">matching and merging by hand</a>). Also  remember that you can use subsetting assignment to replace multiple values in  a single step. If <code>x</code> is a vector, matrix or data frame then<br><code>x[is.na(x)] &lt;- 0</code> will replace all missing values with 0.</p>
</li>
<li>If youâre extracting or replacing values in scattered locations in a matrix  or data frame, subset with an integer matrix.<br>See <a href="#matrix-subsetting">matrix subsetting</a> for more details.</li>
<li>If youâre converting continuous values to categorical make sure you know  how to use <code>cut()</code> and <code>findInterval()</code>.</li>
<li>Be aware of vectorised functions like <code>cumsum()</code> and <code>diff()</code>.</li>
</ul>
<p>Matrix algebra is a general example of vectorisation. There loops are executed by highly tuned external libraries like BLAS. If you can figure out a way to use matrix algebra to solve your problem, youâll often get a very fast solution. The ability to solve problems with matrix algebra is a product of experience. While this skill is something youâll develop over time, a good place to start is to ask people with experience in your domain.</p>
<p>The downside of vectorisation is that it makes it harder to predict how operations will scale. The following example measures how long it takes to use character subsetting to lookup 1, 10, and 100 elements from a list. You might expect that looking up 10 elements would take 10x as long as looking up 1, and that looking up 100 elements would take 10x longer again. In fact, the following example shows that it only takes about 9 times longer to look up 100 elements than it does to look up 1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lookup &lt;- setNames(as.list(sample(100, 26)), letters)</span><br><span class="line"></span><br><span class="line">x1 &lt;- &quot;j&quot;</span><br><span class="line">x10 &lt;- sample(letters, 10)</span><br><span class="line">x100 &lt;- sample(letters, 100, replace = TRUE)</span><br><span class="line"></span><br><span class="line">microbenchmark(</span><br><span class="line">  lookup[x1],</span><br><span class="line">  lookup[x10],</span><br><span class="line">  lookup[x100]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Vectorisation wonât solve every problem, and rather than torturing an existing algorithm into one that uses a vectorised approach, youâre often better off writing your own vectorised function in C++. Youâll learn how to do so in <a href="#rcpp">Rcpp</a>.</p>
<h3 id="Exercises-55"><a href="#Exercises-55" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>The density functions, e.g., <code>dnorm()</code>, have a common interface. Which    arguments are vectorised over? What does <code>rnorm(10, mean = 10:1)</code> do?</li>
<li>Compare the speed of <code>apply(x, 1, sum)</code> with <code>rowSums(x)</code> for varying sizes    of <code>x</code>.</li>
<li>How can you use <code>crossprod()</code> to compute a weighted sum? How much faster is    it than the naive <code>sum(x * w)</code>?</li>
</ol>
<h2 id="Avoid-copies"><a href="#Avoid-copies" class="headerlink" title="Avoid copies"></a><a href="id=&quot;avoid-copies&quot;">Avoid copies</a></h2><p>A pernicious source of slow R code is growing an object with a loop. Whenever you use <code>c()</code>, <code>append()</code>, <code>cbind()</code>, <code>rbind()</code>, or <code>paste()</code> to create a bigger object, R must first allocate space for the new object and then copy the old object to its new home. If youâre repeating this many times, like in a for loop, this can be quite expensive. Youâve entered Circle 2 of the <a href="http://www.burns-stat.com/pages/Tutor/R_inferno.pdf" target="_blank" rel="external">âR infernoâ</a>.</p>
<p>Hereâs a little example that shows the problem. We first generate some random strings, and then combine them either iteratively with a loop using <code>collapse()</code>, or in a single pass using <code>paste()</code>. Note that the performance of <code>collapse()</code> gets relatively worse as the number of strings grows: combining 100 strings takes almost 30 times longer than combining 10 strings.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">random_string &lt;- function() &#123;</span><br><span class="line">  paste(sample(letters, 50, replace = TRUE), collapse = &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">strings10 &lt;- replicate(10, random_string())</span><br><span class="line">strings100 &lt;- replicate(100, random_string())</span><br><span class="line"></span><br><span class="line">collapse &lt;- function(xs) &#123;</span><br><span class="line">  out &lt;- &quot;&quot;</span><br><span class="line">  for (x in xs) &#123;</span><br><span class="line">    out &lt;- paste0(out, x)</span><br><span class="line">  &#125;</span><br><span class="line">  out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">microbenchmark(</span><br><span class="line">  loop10  = collapse(strings10),</span><br><span class="line">  loop100 = collapse(strings100),</span><br><span class="line">  vec10   = paste(strings10, collapse = &quot;&quot;),</span><br><span class="line">  vec100  = paste(strings100, collapse = &quot;&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Modifying an object in a loop, e.g., <code>x[i] &lt;- y</code>, can also create a copy, depending on the class of <code>x</code>. <a href="#modification">Modification in place</a> discusses this issue in more depth and gives you some tools to determine when youâre making copies.</p>
<h2 id="Byte-code-compilation"><a href="#Byte-code-compilation" class="headerlink" title="Byte code compilation"></a><a href="id=&quot;byte-code&quot;">Byte code compilation</a></h2><p>R 2.13.0 introduced a byte code compiler which can increase the speed of some code. Using the compiler is an easy way to get improvements in speed. Even if it doesnât work well for your function, you wonât have invested a lot of time in the effort. The following example shows the pure R version of <code>lapply()</code> from <a href="#lapply">functionals</a>. Compiling it gives a considerable speedup, although itâs still not quite as fast as the C version provided by base R.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lapply2 &lt;- function(x, f, ...) &#123;</span><br><span class="line">  out &lt;- vector(&quot;list&quot;, length(x))</span><br><span class="line">  for (i in seq_along(x)) &#123;</span><br><span class="line">    out[[i]] &lt;- f(x[[i]], ...)</span><br><span class="line">  &#125;</span><br><span class="line">  out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lapply2_c &lt;- compiler::cmpfun(lapply2)</span><br><span class="line"></span><br><span class="line">x &lt;- list(1:10, letters, c(F, T), NULL)</span><br><span class="line">microbenchmark(</span><br><span class="line">  lapply2(x, is.null),</span><br><span class="line">  lapply2_c(x, is.null),</span><br><span class="line">  lapply(x, is.null)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Byte code compilation really helps here, but in most cases youâre more likely to get a 5-10% improvement. All base R functions are byte code compiled by default.</p>
<h2 id="Case-study-t-test"><a href="#Case-study-t-test" class="headerlink" title="Case study: t-test"></a><a href="id=&quot;t-test&quot;">Case study: t-test</a></h2><p>The following case study shows how to make t-tests faster using some of the techniques described above. Itâs based on an example in <a href="http://stat-computing.org/newsletter/issues/scgn-18-1.pdf" target="_blank" rel="external">âComputing thousands of test statistics simultaneously in Râ</a> by Holger Schwender and Tina MÃ¼ller. I thoroughly recommend reading the paper in full to see the same idea applied to other tests.</p>
<p>Imagine we have run 1000 experiments (rows), each of which collects data on 50 individuals (columns). The first 25 individuals in each experiment are assigned to group 1 and the rest to group 2. Weâll first generate some random data to represent this problem:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m &lt;- 1000</span><br><span class="line">n &lt;- 50</span><br><span class="line">X &lt;- matrix(rnorm(m * n, mean = 10, sd = 3), nrow = m)</span><br><span class="line">grp &lt;- rep(1:2, each = n / 2)</span><br></pre></td></tr></table></figure>
<p>For data in this form, there are two ways to use <code>t.test()</code>. We can either use the formula interface or provide two vectors, one for each group. Timing reveals that the formula interface is considerably slower.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">system.time(for(i in 1:m) t.test(X[i, ] ~ grp)$stat)</span><br><span class="line">system.time(</span><br><span class="line">  for(i in 1:m) t.test(X[i, grp == 1], X[i, grp == 2])$stat</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Of course, a for loop computes, but doesnât save the values. Weâll use <code>apply()</code> to do that. This adds a little overhead:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compT &lt;- function(x, grp)&#123;</span><br><span class="line">  t.test(x[grp == 1], x[grp == 2])$stat</span><br><span class="line">&#125;</span><br><span class="line">system.time(t1 &lt;- apply(X, 1, compT, grp = grp))</span><br></pre></td></tr></table></figure>
<p>How can we make this faster? First, we could try doing less work. If you look at the source code of <code>stats:::t.test.default()</code>, youâll see that it does a lot more than just compute the t-statistic. It also computes the p-value and formats the output for printing. We can try to make our code faster by stripping out those pieces.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">my_t &lt;- function(x, grp) &#123;</span><br><span class="line">  t_stat &lt;- function(x) &#123;</span><br><span class="line">    m &lt;- mean(x)</span><br><span class="line">    n &lt;- length(x)</span><br><span class="line">    var &lt;- sum((x - m) ^ 2) / (n - 1)</span><br><span class="line"></span><br><span class="line">    list(m = m, n = n, var = var)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g1 &lt;- t_stat(x[grp == 1])</span><br><span class="line">  g2 &lt;- t_stat(x[grp == 2])</span><br><span class="line"></span><br><span class="line">  se_total &lt;- sqrt(g1$var / g1$n + g2$var / g2$n)</span><br><span class="line">  (g1$m - g2$m) / se_total</span><br><span class="line">&#125;</span><br><span class="line">system.time(t2 &lt;- apply(X, 1, my_t, grp = grp))</span><br><span class="line">stopifnot(all.equal(t1, t2))</span><br></pre></td></tr></table></figure>
<p>This gives us about a 6x speed improvement.</p>
<p>Now that we have a fairly simple function, we can make it faster still by vectorising it. Instead of looping over the array outside the function, we will modify <code>t_stat()</code> to work with a matrix of values. Thus, <code>mean()</code> becomes <code>rowMeans()</code>, <code>length()</code> becomes <code>ncol()</code>, and <code>sum()</code> becomes <code>rowSums()</code>. The rest of the code stays the same.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rowtstat &lt;- function(X, grp)&#123;</span><br><span class="line">  t_stat &lt;- function(X) &#123;</span><br><span class="line">    m &lt;- rowMeans(X)</span><br><span class="line">    n &lt;- ncol(X)</span><br><span class="line">    var &lt;- rowSums((X - m) ^ 2) / (n - 1)</span><br><span class="line"></span><br><span class="line">    list(m = m, n = n, var = var)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g1 &lt;- t_stat(X[, grp == 1])</span><br><span class="line">  g2 &lt;- t_stat(X[, grp == 2])</span><br><span class="line"></span><br><span class="line">  se_total &lt;- sqrt(g1$var / g1$n + g2$var / g2$n)</span><br><span class="line">  (g1$m - g2$m) / se_total</span><br><span class="line">&#125;</span><br><span class="line">system.time(t3 &lt;- rowtstat(X, grp))</span><br><span class="line">stopifnot(all.equal(t1, t3))</span><br></pre></td></tr></table></figure>
<p>Thatâs much faster! Itâs at least 40x faster than our previous effort, and around 1000x faster than where we started.</p>
<p>Finally, we could try byte code compilation. Here weâll need to use <code>microbenchmark()</code> instead of <code>system.time()</code> in order to get enough accuracy to see a difference:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rowtstat_bc &lt;- compiler::cmpfun(rowtstat)</span><br><span class="line"></span><br><span class="line">microbenchmark(</span><br><span class="line">  rowtstat(X, grp),</span><br><span class="line">  rowtstat_bc(X, grp),</span><br><span class="line">  unit = &quot;ms&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>In this example, byte code compilation doesnât help at all.</p>
<h2 id="Parallelise"><a href="#Parallelise" class="headerlink" title="Parallelise"></a><a href="id=&quot;parallelise&quot;">Parallelise</a></h2><p>Parallelisation uses multiple cores to work simultaneously on different parts of a problem. It doesnât reduce the computing time, but it saves your time because youâre using more of your computerâs resources. Parallel computing is a complex topic, and thereâs no way to cover it in depth here. Some resources I recommend are:</p>
<ul>
<li><a href="http://amzn.com/B005Z29QT4" target="_blank" rel="external"><em>Parallel R</em></a> by Q. Ethan McCallum and Stephen Weston.</li>
<li><a href="http://heather.cs.ucdavis.edu/paralleldatasci.pdf" target="_blank" rel="external"><em>Parallel Computing for Data Science</em></a> by<br>Norm Matloff.</li>
</ul>
<p>What I want to show is a simple application of parallel computing to what are called âembarrassingly parallel problemsâ. An embarrassingly parallel problem is one thatâs made up of many simple problems that can be solved independently. A great example of this is <code>lapply()</code> because it operates on each element independently of the others. Itâs very easy to parallelise <code>lapply()</code> on Linux and the Mac because you simply substitute <code>mclapply()</code> for <code>lapply()</code>. The following code snippet runs a trivial (but slow) function on all cores of your computer.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library(parallel)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cores &lt;- detectCores()</span><br><span class="line">cores</span><br><span class="line"></span><br><span class="line">pause &lt;- function(i) &#123;</span><br><span class="line">  function(x) Sys.sleep(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system.time(lapply(1:10, pause(0.25)))</span><br><span class="line">system.time(mclapply(1:10, pause(0.25), mc.cores = cores))</span><br></pre></td></tr></table></figure>
<p>Life is a bit harder in Windows. You need to first set up a local cluster and then use <code>parLapply()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster &lt;- makePSOCKcluster(cores)</span><br><span class="line">system.time(parLapply(cluster, 1:10, function(i) Sys.sleep(1)))</span><br></pre></td></tr></table></figure>
<p>The main difference between <code>mclapply()</code> and <code>makePSOCKcluster()</code> is that the individual processes generated by <code>mclapply()</code> inherit from the current process, while those generated by <code>makePSOCKcluster()</code> start with a fresh session. This means that most real code will need some setup. Use <code>clusterEvalQ()</code> to run arbitrary code on each cluster and load needed packages, and <code>clusterExport()</code> to copy objects in the current session to the remote sessions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 10</span><br><span class="line">psock &lt;- parallel::makePSOCKcluster(1L)</span><br><span class="line">clusterEvalQ(psock, x)</span><br><span class="line">#&gt; Error: one node produced an error: object &apos;x&apos; not found</span><br><span class="line"></span><br><span class="line">clusterExport(psock, &quot;x&quot;)</span><br><span class="line">clusterEvalQ(psock, x)</span><br><span class="line">#&gt; [[1]]</span><br><span class="line">#&gt; [1] 10</span><br></pre></td></tr></table></figure>
<p>There is some communication overhead with parallel computing. If the subproblems are very small, then parallelisation might hurt rather than help. Itâs also possible to distribute computation over a network of computers (not just the cores on your local computer) but thatâs beyond the scope of this book, because it gets increasingly complicated to balance computation and communication costs. A good place to start for more information is the <a href="http://cran.r-project.org/web/views/HighPerformanceComputing.html" target="_blank" rel="external">high performance computing CRAN task view</a>.</p>
<h2 id="Other-techniques"><a href="#Other-techniques" class="headerlink" title="Other techniques"></a><a href="id=&quot;more-techniques&quot;">Other techniques</a></h2><p>Being able to write fast R code is part of being a good R programmer. Beyond the specific hints in this chapter, if you want to write fast R code, youâll need to improve your general programming skills. Some ways to do this are to:</p>
<ul>
<li><a href="http://www.r-bloggers.com/" target="_blank" rel="external">Read R blogs</a> to see what performance  problems other people have struggled with, and how they have made their  code faster.</li>
<li>Read other R programming books, like Norm Matloffâs  <a href="http://amzn.com/1593273843" target="_blank" rel="external"><em>The Art of R Programming</em></a> or Patrick Burnsâ  <a href="http://www.burns-stat.com/documents/books/the-r-inferno/" target="_blank" rel="external"><em>R Inferno</em></a> to  learn about common traps.</li>
<li>Take an algorithms and data structure course to learn some  well known ways of tackling certain classes of problems. I have heard  good things about Princetonâs  <a href="https://www.coursera.org/course/algs4partI" target="_blank" rel="external">Algorithms course</a> offered on<br>Coursera.</li>
<li>Read general books about optimisation like  <a href="http://carlos.bueno.org/optimization/mature-optimization.pdf" target="_blank" rel="external"><em>Mature optimisation</em></a>  by Carlos Bueno, or the <a href="http://amzn.com/020161622X" target="_blank" rel="external"><em>Pragmatic Programmer</em></a>  by Andrew Hunt and David Thomas.</li>
</ul>
<p>You can also reach out to the community for help. Stackoverflow can be a useful resource. Youâll need to put some effort into creating an easily digestible example that also captures the salient features of your problem. If your example is too complex, few people will have the time and motivation to attempt a solution. If itâs too simple, youâll get answers that solve the toy problem but not the real problem. If you also try to answer questions on stackoverflow, youâll quickly get a feel for what makes a good question.</p>
<hr>
<h1 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a><a href="id=&quot;memory&quot;">Memory</a></h1><p>A solid understanding of Râs memory management will help you predict how much memory youâll need for a given task and help you to make the most of the memory you have. It can even help you write faster code because accidental copies are a major cause of slow code. The goal of this chapter is to help you understand the basics of memory management in R, moving from individual objects to functions to larger blocks of code. Along the way, youâll learn about some common myths, such as that you need to call <code>gc()</code> to free up memory, or that <code>for</code> loops are always slow.</p>
<h5 id="Outline-12"><a href="#Outline-12" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#object-size">Object size</a> shows you how to use <code>object_size()</code> to see  how much memory an object occupies, and uses that as a launching point to  improve your understanding of how R objects are stored in memory.</li>
<li><a href="#gc">Memory usage and garbage collection</a> introduces you to the <code>mem_used()</code>  and <code>mem_change()</code> functions that will help you understand how R allocates  and frees memory.</li>
<li><a href="#memory-profiling">Memory profiling with lineprof</a> shows you how to use  the lineprof package to understand how memory is allocated and released in  larger code blocks.</li>
<li><a href="#modification">Modification in place</a> introduces you to the <code>address()</code> and  <code>refs()</code> functions so that you can understand when R modifies in place and  when R modifies a copy. Understanding when objects are copied is very  important for writing efficient R code.</li>
</ul>
<h5 id="Prerequisites-9"><a href="#Prerequisites-9" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><p>In this chapter, weâll use tools from the pryr and lineprof packages to understand memory usage, and a sample dataset from ggplot2. If you donât already have them, run this code to get the packages you need:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">install.packages(&quot;ggplot2&quot;)</span><br><span class="line">install.packages(&quot;pryr&quot;)</span><br><span class="line">install.packages(&quot;devtools&quot;)</span><br><span class="line">devtools::install_github(&quot;hadley/lineprof&quot;)</span><br></pre></td></tr></table></figure>
<h5 id="Sources"><a href="#Sources" class="headerlink" title="Sources"></a>Sources</h5><!-- FIXME: cite R-exts and R-ints formally -->
<p>The details of Râs memory management are not documented in a single place. Most of the information in this chapter was gleaned from a close reading of the documentation (particularly <code>?Memory</code> and <code>?gc</code>), the <a href="http://cran.r-project.org/doc/manuals/R-exts.html#Profiling-R-code-for-memory-use" target="_blank" rel="external">memory profiling</a> section of R-exts, and the <a href="http://cran.r-project.org/doc/manuals/R-ints.html#SEXPs" target="_blank" rel="external">SEXPs</a> section of R-ints. The rest I figured out by reading the C source code, performing small experiments, and asking questions on R-devel. Any mistakes are entirely mine.</p>
<h2 id="Object-size"><a href="#Object-size" class="headerlink" title="Object size"></a><a href="id=&quot;object-size&quot;">Object size</a></h2><p>To understand memory usage in R, we will start with <code>pryr::object_size()</code>. This function tells you how many bytes of memory an object occupies:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library(pryr)</span><br><span class="line">object_size(1:10)</span><br><span class="line">object_size(mean)</span><br><span class="line">object_size(mtcars)</span><br></pre></td></tr></table></figure>
<p>(This function is better than the built-in <code>object.size()</code> because it accounts for shared elements within an object and includes the size of environments.)</p>
<p>Something interesting occurs if we use <code>object_size()</code> to systematically explore the size of an integer vector. The code below computes and plots the memory usage of integer vectors ranging in length from 0 to 50 elements. You might expect that the size of an empty vector would be zero and that memory usage would grow proportionately with length. Neither of those things are true!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizes &lt;- sapply(0:50, function(n) object_size(seq_len(n)))</span><br><span class="line">plot(0:50, sizes, xlab = &quot;Length&quot;, ylab = &quot;Size (bytes)&quot;,</span><br><span class="line">  type = &quot;s&quot;)</span><br></pre></td></tr></table></figure>
<p>This isnât just an artefact of integer vectors. Every length 0 vector occupies 40 bytes of memory:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object_size(numeric())</span><br><span class="line">object_size(logical())</span><br><span class="line">object_size(raw())</span><br><span class="line">object_size(list())</span><br></pre></td></tr></table></figure>
<p>Those 40 bytes are used to store four components possessed by every object in R:</p>
<ul>
<li>Object metadata (4 bytes). These metadata store the base type (e.g. integer)  and information used for debugging and memory management.</li>
<li>Two pointers: one to the next object in memory and one to the previous  object (2 * 8 bytes). This doubly-linked list makes it easy for internal  R code to loop through every object in memory.</li>
<li>A pointer to the attributes (8 bytes).</li>
</ul>
<p>All vectors have three additional components:</p>
<ul>
<li>The length of the vector (4 bytes). By using only 4 bytes, you might expect  that R could only support vectors up to $2 ^ {4 \times 8 - 1}$ ($2 ^ {31}$, about  two billion) elements. But in R 3.0.0 and later, you can actually have  vectors up to $2 ^ {52}$ elements. <a href="http://cran.r-project.org/doc/manuals/R-ints.html#Long-vectors" target="_blank" rel="external">Read R-internals</a> to see how  support for long vectors was added without having to change the size of this  field.</li>
<li>The âtrueâ length of the vector (4 bytes). This is basically never used,  except when the object is the hash table used for an environment. In that  case, the true length represents the allocated space, and the length  represents the space currently used.</li>
<li>The data (?? bytes). An empty vector has 0 bytes of data, but itâs  obviously very important otherwise! Numeric vectors occupy 8 bytes for  every element, integer vectors 4, and complex vectors 16.</li>
</ul>
<p>If youâre keeping count youâll notice that this only adds up to 36 bytes. The remaining 4 bytes are used for padding so that each component starts on an 8 byte (= 64-bit) boundary. Most cpu architectures require pointers to be aligned in this way, and even if they donât require it, accessing non-aligned pointers tends to be rather slow. (If youâre interested, you can read more about it in <a href="http://www.catb.org/esr/structure-packing/" target="_blank" rel="external">C structure packing</a>.)</p>
<p>This explains the intercept on the graph. But why does the memory size grow irregularly? To understand why, you need to know a little bit about how R requests memory from the operating system. Requesting memory (with <code>malloc()</code>) is a relatively expensive operation. Having to request memory every time a small vector is created would slow R down considerably. Instead, R asks for a big block of memory and then manages that block itself. This block is called the small vector pool and is used for vectors less than 128 bytes long. For efficiency and simplicity, it only allocates vectors that are 8, 16, 32, 48, 64, or 128 bytes long. If we adjust our previous plot to remove the 40 bytes of overhead, we can see that those values correspond to the jumps in memory use.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plot(0:50, sizes - 40, xlab = &quot;Length&quot;,</span><br><span class="line">  ylab = &quot;Bytes excluding overhead&quot;, type = &quot;n&quot;)</span><br><span class="line">abline(h = 0, col = &quot;grey80&quot;)</span><br><span class="line">abline(h = c(8, 16, 32, 48, 64, 128), col = &quot;grey80&quot;)</span><br><span class="line">abline(a = 0, b = 4, col = &quot;grey90&quot;, lwd = 4)</span><br><span class="line">lines(sizes - 40, type = &quot;s&quot;)</span><br></pre></td></tr></table></figure>
<p>Beyond 128 bytes, it no longer makes sense for R to manage vectors. After all, allocating big chunks of memory is something that operating systems are very good at. Beyond 128 bytes, R will ask for memory in multiples of 8 bytes. This ensures good alignment.</p>
<p>A subtlety of the size of an object is that components can be shared across multiple objects. For example, look at the following code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1:1e6</span><br><span class="line">object_size(x)</span><br><span class="line"></span><br><span class="line">y &lt;- list(x, x, x)</span><br><span class="line">object_size(y)</span><br></pre></td></tr></table></figure>
<p><code>y</code> isnât three times as big as <code>x</code> because R is smart enough to not copy <code>x</code> three times; instead it just points to the existing <code>x</code>.</p>
<p>Itâs misleading to look at the sizes of <code>x</code> and <code>y</code> individually. If you want to know how much space they take up together, you have to supply them to the same <code>object_size()</code> call:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_size(x, y)</span><br></pre></td></tr></table></figure>
<p>In this case, <code>x</code> and <code>y</code> together take up the same amount of space as <code>y</code> alone. This is not always the case. If there are no shared components, as in the following example, then you can add up the sizes of individual components to find out the total size:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1 &lt;- 1:1e6</span><br><span class="line">y1 &lt;- list(1:1e6, 1:1e6, 1:1e6)</span><br><span class="line"></span><br><span class="line">object_size(x1)</span><br><span class="line">object_size(y1)</span><br><span class="line">object_size(x1, y1)</span><br><span class="line">object_size(x1) + object_size(y1) == object_size(x1, y1)</span><br></pre></td></tr></table></figure>
<p>The same issue also comes up with strings, because R has a global string pool. This means that each unique string is only stored in one place, and therefore character vectors take up less memory than you might expect:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object_size(&quot;banana&quot;)</span><br><span class="line">object_size(rep(&quot;banana&quot;, 10))</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-56"><a href="#Exercises-56" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Repeat the analysis above for numeric, logical, and complex vectors.</li>
<li>If a data frame has one million rows, and three variables (two numeric, and    one integer), how much space will it take up? Work it out from theory,    then verify your work by creating a data frame and measuring its size.</li>
<li><p>Compare the sizes of the elements in the following two lists. Each    contains basically the same data, but one contains vectors of small    strings while the other contains a single long string.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec &lt;- lapply(0:50, function(i) c(&quot;ba&quot;, rep(&quot;na&quot;, i)))</span><br><span class="line">str &lt;- lapply(vec, paste0, collapse = &quot;&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Which takes up more memory: a factor (<code>x</code>) or the equivalent character    vector (<code>as.character(x)</code>)? Why?</p>
</li>
<li>Explain the difference in size between <code>1:5</code> and <code>list(1:5)</code>.</li>
</ol>
<h2 id="Memory-usage-and-garbage-collection"><a href="#Memory-usage-and-garbage-collection" class="headerlink" title="Memory usage and garbage collection"></a><a href="id=&quot;gc&quot;">Memory usage and garbage collection</a></h2><p>While <code>object_size()</code> tells you the size of a single object, <code>pryr::mem_used()</code> tells you the total size of all objects in memory:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library(pryr)</span><br><span class="line">mem_used()</span><br></pre></td></tr></table></figure>
<p>This number wonât agree with the amount of memory reported by your operating system for a number of reasons:</p>
<ol>
<li>It only includes objects created by R, not the R interpreter itself.</li>
<li>Both R and the operating system are lazy: they wonât reclaim memory   until itâs actually needed. R might be holding on to memory because   the OS hasnât yet asked for it back.</li>
<li>R counts the memory occupied by objects but there may be gaps due to   deleted objects. This problem is known as memory fragmentation.</li>
</ol>
<p><code>mem_change()</code> builds on top of <code>mem_used()</code> to tell you how memory changes during code execution. Positive numbers represent an increase in the memory used by R, and negative numbers represent a decrease.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Need about 4 mb to store 1 million integers</span><br><span class="line">mem_change(x &lt;- 1:1e6)</span><br><span class="line"># We get that memory back when we delete it</span><br><span class="line">mem_change(rm(x))</span><br></pre></td></tr></table></figure>
<p>Even operations that donât do anything use up a little memory. This is because R is tracking the history of everything you do. You can ignore anything on the order of around 2 kB.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mem_change(NULL)</span><br><span class="line">mem_change(NULL)</span><br></pre></td></tr></table></figure>
<p>In some languages, you have to explicitly delete unused objects for their memory to be returned. R uses an alternative approach: garbage collection (or GC for short). GC automatically releases memory when an object is no longer used. It does this by tracking how many names point to each object, and when there are no names pointing to an object, it deletes that object.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm(y)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Create a big object</span><br><span class="line">mem_change(x &lt;- 1:1e6)</span><br><span class="line"># Also point to 1:1e6 from y</span><br><span class="line">mem_change(y &lt;- x)</span><br><span class="line"># Remove x, no memory freed because y is still pointing to it</span><br><span class="line">mem_change(rm(x))</span><br><span class="line"># Now nothing points to it and the memory can be freed</span><br><span class="line">mem_change(rm(y))</span><br></pre></td></tr></table></figure>
<p>Despite what you might have read elsewhere, thereâs never any need to call <code>gc()</code> yourself. R will automatically run garbage collection whenever it needs more space; if you want to see when that is, call <code>gcinfo(TRUE)</code>. The only reason you <em>might</em> want to call <code>gc()</code> is to ask R to return memory to the operating system. However, even that might not have any effect: older versions of Windows had no way for a program to return memory to the OS.</p>
<p>GC takes care of releasing objects that are no longer used. However, you do need to be aware of possible memory leaks. A memory leak occurs when you keep pointing to an object without realising it. In R, the two main causes of memory leaks are formulas and closures because they both capture the enclosing environment. The following code illustrates the problem. In <code>f1()</code>, <code>1:1e6</code> is only referenced inside the function, so when the function completes the memory is returned and the net memory change is 0. <code>f2()</code> and <code>f3()</code> both return objects that capture environments, so that <code>x</code> is not freed when the function completes.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">f1 &lt;- function() &#123;</span><br><span class="line">  x &lt;- 1:1e6</span><br><span class="line">  10</span><br><span class="line">&#125;</span><br><span class="line">mem_change(x &lt;- f1())</span><br><span class="line">object_size(x)</span><br><span class="line"></span><br><span class="line">f2 &lt;- function() &#123;</span><br><span class="line">  x &lt;- 1:1e6</span><br><span class="line">  a ~ b</span><br><span class="line">&#125;</span><br><span class="line">mem_change(y &lt;- f2())</span><br><span class="line">object_size(y)</span><br><span class="line"></span><br><span class="line">f3 &lt;- function() &#123;</span><br><span class="line">  x &lt;- 1:1e6</span><br><span class="line">  function() 10</span><br><span class="line">&#125;</span><br><span class="line">mem_change(z &lt;- f3())</span><br><span class="line">object_size(z)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm(y, z)</span><br></pre></td></tr></table></figure>
<h2 id="Memory-profiling-with-lineprof"><a href="#Memory-profiling-with-lineprof" class="headerlink" title="Memory profiling with lineprof"></a><a href="id=&quot;memory-profiling&quot;">Memory profiling with lineprof</a></h2><p><code>mem_change()</code> captures the net change in memory when running a block of code. Sometimes, however, we may want to measure incremental change. One way to do this is to use memory profiling to capture usage every few milliseconds. This functionality is provided by <code>utils::Rprof()</code> but it doesnât provide a very useful display of the results. Instead weâll use the <a href="https://github.com/hadley/lineprof" target="_blank" rel="external">lineprof</a> package. It is powered by <code>Rprof()</code>, but displays the results in a more informative manner.</p>
<p>To demonstrate <code>lineprof</code>, weâre going to explore a bare-bones implementation of <code>read.delim()</code> with only three arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">We&apos;ll also create a sample csv file:</span><br><span class="line"></span><br><span class="line">```&#123;r&#125;</span><br><span class="line">library(ggplot2)</span><br><span class="line">write.csv(diamonds, &quot;diamonds.csv&quot;, row.names = FALSE)</span><br></pre></td></tr></table></figure>
<p>Using lineprof is straightforward. <code>source()</code> the code, apply <code>lineprof()</code> to an expression, then use <code>shine()</code> to view the results. Note that you <em>must</em> use <code>source()</code> to load the code. This is because lineprof uses srcrefs to match up the code and run times. The needed srcrefs are only created when you load code from disk.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">library(lineprof)</span><br><span class="line"></span><br><span class="line">source(&quot;code/read-delim.R&quot;)</span><br><span class="line">prof &lt;- lineprof(read_delim(&quot;diamonds.csv&quot;))</span><br><span class="line">shine(prof)</span><br></pre></td></tr></table></figure>
<p><img src="screenshots/memory-lineprof.png" alt=""></p>
<p><code>shine()</code> will also open a new web page (or if youâre using RStudio, a new pane) that shows your source code annotated with information about memory usage. <code>shine()</code> starts a shiny app which will âblockâ your R session. To exit, press escape or ctrl + break.</p>
<p>Next to the source code, four columns provide details about the performance of the code:</p>
<ul>
<li><code>t</code>, the time (in seconds) spent on that line of code (explained in  <a href="#measure-perf">measuring performance</a>).</li>
<li><code>a</code>, the memory (in megabytes) allocated by that line of code.</li>
<li><code>r</code>, the memory (in megabytes) released by that line of code. While memory  allocation is deterministic, memory release is stochastic: it depends on when  the GC was run. This means that memory release only tells you that the memory  released was no longer needed before this line.</li>
<li><code>d</code>, the number of vector duplications that occurred. A vector duplication  occurs when R copies a vector as a result of its copy on modify semantics.</li>
</ul>
<p>You can hover over any of the bars to get the exact numbers. In this example, looking at the allocations tells us most of the story:</p>
<ul>
<li><code>scan()</code> allocates about 2.5 MB of memory, which is very close to the 2.8 MB  of space that the file occupies on disk. You wouldnât expect the two numbers  to be identical because R doesnât need to store the commas and because the  global string pool will save some memory.</li>
<li>Converting the columns allocates another 0.6 MB of memory. Youâd also expect  this step to free some memory because weâve converted string columns into  integer and numeric columns (which occupy less space), but we canât see those  releases because GC hasnât been triggered yet.</li>
<li>Finally, calling <code>as.data.frame()</code> on a list allocates about 1.6 megabytes  of memory and performs over 600 duplications. This is because  <code>as.data.frame()</code> isnât terribly efficient and ends up copying the input  multiple times. Weâll discuss duplication more in the next section.</li>
</ul>
<p>There are two downsides to profiling:</p>
<ol>
<li><code>read_delim()</code> only takes around half a second, but profiling can, at best,   capture memory usage every 1 ms. This means weâll only get about 500 samples.</li>
<li>Since GC is lazy, we can never tell exactly when memory is no longer needed.</li>
</ol>
<p>You can work around both problems by using <code>torture = TRUE</code>, which forces R to run GC after every allocation (see <code>gctorture()</code> for more details). This helps with both problems because memory is freed as soon as possible, and R runs 10â100x slower. This effectively makes the resolution of the timer greater, so that you can see smaller allocations and exactly when memory is no longer needed.</p>
<h3 id="Exercises-57"><a href="#Exercises-57" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>When the input is a list, we can make a more efficient <code>as.data.frame()</code>   by using special knowledge. A data frame is a list with class <code>data.frame</code>   and <code>row.names</code> attribute. <code>row.names</code> is either a character vector or   vector of sequential integers, stored in a special format created by   <code>.set_row_names()</code>. This leads to an alternative <code>as.data.frame()</code>:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">to_df &lt;- function(x) &#123;</span><br><span class="line">  class(x) &lt;- &quot;data.frame&quot;</span><br><span class="line">  attr(x, &quot;row.names&quot;) &lt;- .set_row_names(length(x[[1]]))</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> What impact does this function have on <code>read_delim()</code>?  What are the    downsides of this function?</p>
</li>
<li><p>Line profile the following function with <code>torture = TRUE</code>. What is    surprising? Read the source code of <code>rm()</code> to figure out whatâs going on.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f &lt;- function(n = 1e5) &#123;</span><br><span class="line">  x &lt;- rep(1, n)</span><br><span class="line">  rm(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Modification-in-place"><a href="#Modification-in-place" class="headerlink" title="Modification in place"></a><a href="id=&quot;modification&quot;">Modification in place</a></h2><p>What happens to <code>x</code> in the following code?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1:10</span><br><span class="line">x[5] &lt;- 10</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<p>There are two possibilities:</p>
<ol>
<li>R modifies <code>x</code> in place.</li>
<li>R makes a copy of <code>x</code> to a new location, modifies the copy, and then uses   the name <code>x</code> to point to the new location.</li>
</ol>
<p>It turns out that R can do either depending on the circumstances. In the example above, it will modify in place. But if another variable also points to <code>x</code>, then R will copy it to a new location. To explore whatâs going on in greater detail, we use two tools from the pryr package. Given the name of a variable, <code>address()</code> will tell us the variableâs location in memory and <code>refs()</code> will tell us how many names point to that location.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">library(pryr)</span><br><span class="line">x &lt;- 1:10</span><br><span class="line">c(address(x), refs(x))</span><br><span class="line"># [1] &quot;0x103100060&quot; &quot;1&quot;</span><br><span class="line"></span><br><span class="line">y &lt;- x</span><br><span class="line">c(address(y), refs(y))</span><br><span class="line"># [1] &quot;0x103100060&quot; &quot;2&quot;</span><br></pre></td></tr></table></figure>
<p>(Note that if youâre using RStudio, <code>refs()</code> will always return 2: the environment browser makes a reference to every object you create on the command line.)</p>
<p><code>refs()</code> is only an estimate. It can only distinguish between one and more than one reference (future versions of R might do better). This means that <code>refs()</code> returns 2 in both of the following cases:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1:5</span><br><span class="line">y &lt;- x</span><br><span class="line">rm(y)</span><br><span class="line"># Should really be 1, because we&apos;ve deleted y</span><br><span class="line">refs(x)</span><br><span class="line"></span><br><span class="line">x &lt;- 1:5</span><br><span class="line">y &lt;- x</span><br><span class="line">z &lt;- x</span><br><span class="line"># Should really be 3</span><br><span class="line">refs(x)</span><br></pre></td></tr></table></figure>
<p>When <code>refs(x)</code> is 1, modification will occur in place. When <code>refs(x)</code> is 2, R will make a copy (this ensures that other pointers to the object remain unaffected). Note that in the following example, <code>y</code> keeps pointing to the same location while <code>x</code> changes.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1:10</span><br><span class="line">y &lt;- x</span><br><span class="line">c(address(x), address(y))</span><br><span class="line"></span><br><span class="line">x[5] &lt;- 6L</span><br><span class="line">c(address(x), address(y))</span><br></pre></td></tr></table></figure>
<p>Another useful function is <code>tracemem()</code>. It prints a message every time the traced object is copied:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- 1:10</span><br><span class="line"># Prints the current memory location of the object</span><br><span class="line">tracemem(x)</span><br><span class="line"># [1] &quot;&lt;0x7feeaaa1c6b8&gt;&quot;</span><br><span class="line"></span><br><span class="line">x[5] &lt;- 6L</span><br><span class="line"></span><br><span class="line">y &lt;- x</span><br><span class="line"># Prints where it has moved from and to</span><br><span class="line">x[5] &lt;- 6L</span><br><span class="line"># tracemem[0x7feeaaa1c6b8 -&gt; 0x7feeaaa1c768]:</span><br></pre></td></tr></table></figure>
<p>For interactive use, <code>tracemem()</code> is slightly more useful than <code>refs()</code>, but because it just prints a message, itâs harder to program with. I donât use it in this book because it interacts poorly with <a href="http://yihui.name/knitr/" target="_blank" rel="external">knitr</a>, the tool I use to interleave text and code.</p>
<p>Non-primitive functions that touch the object always increment the ref count. Primitive functions usually donât. (The reasons are a little complicated, but see the R-devel thread <a href="http://r.789695.n4.nabble.com/Confused-about-NAMED-td4103326.html" target="_blank" rel="external">confused about NAMED</a>.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Touching the object forces an increment</span><br><span class="line">f &lt;- function(x) x</span><br><span class="line">&#123;x &lt;- 1:10; f(x); refs(x)&#125;</span><br><span class="line"></span><br><span class="line"># Sum is primitive, so no increment</span><br><span class="line">&#123;x &lt;- 1:10; sum(x); refs(x)&#125;</span><br><span class="line"></span><br><span class="line"># f() and g() never evaluate x, so refs don&apos;t increment</span><br><span class="line">f &lt;- function(x) 10</span><br><span class="line">g &lt;- function(x) substitute(x)</span><br><span class="line"></span><br><span class="line">&#123;x &lt;- 1:10; f(x); refs(x)&#125;</span><br><span class="line">&#123;x &lt;- 1:10; g(x); refs(x)&#125;</span><br></pre></td></tr></table></figure>
<p>Generally, provided that the object is not referred to elsewhere, any primitive replacement function will modify in place. This includes <code>[[&lt;-</code>, <code>[&lt;-</code>, <code>@&lt;-</code>, <code>$&lt;-</code>, <code>attr&lt;-</code>, <code>attributes&lt;-</code>, <code>class&lt;-</code>, <code>dim&lt;-</code>, <code>dimnames&lt;-</code>, <code>names&lt;-</code>, and <code>levels&lt;-</code>. To be precise, all non-primitive functions increment refs, but a primitive function may be written in such a way that it doesnât. The rules are sufficiently complicated that thereâs little point in trying to memorise them. Instead, you should approach the problem practically by using <code>refs()</code> and <code>address()</code> to figure out when objects are being copied.</p>
<p>While determining that copies are being made is not hard, preventing such behaviour is. If you find yourself resorting to exotic tricks to avoid copies, it may be time to rewrite your function in C++, as described in <a href="#rcpp">Rcpp</a>.</p>
<h3 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h3><p>For loops in R have a reputation for being slow. Often that slowness is because youâre modifying a copy instead of modifying in place. Consider the following code. It subtracts the median from each column of a large data frame:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- data.frame(matrix(runif(100 * 1e4), ncol = 100))</span><br><span class="line">medians &lt;- vapply(x, median, numeric(1))</span><br><span class="line"></span><br><span class="line">for(i in seq_along(medians)) &#123;</span><br><span class="line">  x[, i] &lt;- x[, i] - medians[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You may be surprised to realise that every iteration of the loop copies the data frame. We can see that more clearly by using <code>address()</code> and <code>refs()</code> for a small sample of the loop:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(i in 1:5) &#123;</span><br><span class="line">  x[, i] &lt;- x[, i] - medians[i]</span><br><span class="line">  print(c(address(x), refs(x)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For each iteration, <code>x</code> is moved to a new location so <code>refs(x)</code> is always 2. This occurs because <code>[&lt;-.data.frame</code> is not a primitive function, so it always increments the refs. We can make the function substantially more efficient by using a list instead of a data frame. Modifying a list uses primitive functions, so the refs are not incremented and all modifications occur in place:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y &lt;- as.list(x)</span><br><span class="line"></span><br><span class="line">for(i in 1:5) &#123;</span><br><span class="line">  y[[i]] &lt;- y[[i]] - medians[i]</span><br><span class="line">  print(c(address(y), refs(y)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This behaviour was substantially more problematic prior to R 3.1.0, because every copy of the data frame was a deep copy. This made the motivating example take around 5 s, compared to 0.01 s today.</p>
<h3 id="Exercises-58"><a href="#Exercises-58" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>The code below makes one duplication. Where does it occur and why?    (Hint: look at <code>refs(y)</code>.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y &lt;- as.list(x)</span><br><span class="line">for(i in seq_along(medians)) &#123;</span><br><span class="line">  y[[i]] &lt;- y[[i]] - medians[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>The implementation of <code>as.data.frame()</code> in the previous section has one    big downside. What is it and how could you avoid it?</p>
</li>
</ol>
<hr>
<h1 id="High-performance-functions-with-Rcpp"><a href="#High-performance-functions-with-Rcpp" class="headerlink" title="High performance functions with Rcpp"></a><a href="id=&quot;rcpp&quot;">High performance functions with Rcpp</a></h1><p>Sometimes R code just isnât fast enough. Youâve used profiling to figure out where your bottlenecks are, and youâve done everything you can in R, but your code still isnât fast enough. In this chapter youâll learn how to improve performance by rewriting key functions in C++. This magic comes by way of the <a href="http://www.rcpp.org/" target="_blank" rel="external">Rcpp</a> package, a fantastic tool written by Dirk Eddelbuettel and Romain Francois (with key contributions by Doug Bates, John Chambers, and JJ Allaire). Rcpp makes it very simple to connect C++ to R. While it is <em>possible</em> to write C or Fortran code for use in R, it will be painful by comparison. Rcpp provides a clean, approachable API that lets you write high-performance code, insulated from Râs arcane C API.</p>
<p>Typical bottlenecks that C++ can address include:</p>
<ul>
<li>Loops that canât be easily vectorised because subsequent iterations depend  on previous ones.</li>
<li>Recursive functions, or problems which involve calling functions millions of  times. The overhead of calling a function in C++ is much lower than that in  R.</li>
<li>Problems that require advanced data structures and algorithms that R doesnât  provide. Through the standard template library (STL), C++ has efficient  implementations of many important data structures, from ordered maps to  double-ended queues.</li>
</ul>
<p>The aim of this chapter is to discuss only those aspects of C++ and Rcpp that are absolutely necessary to help you eliminate bottlenecks in your code. We wonât spend much time on advanced features like object oriented programming or templates because the focus is on writing small, self-contained functions, not big programs. A working knowledge of C++ is helpful, but not essential. Many good tutorials and references are freely available, including <a href="http://www.learncpp.com/" target="_blank" rel="external">http://www.learncpp.com/</a> and <a href="http://www.cplusplus.com/" target="_blank" rel="external">http://www.cplusplus.com/</a>. For more advanced topics, the <em>Effective C++</em> series by Scott Meyers is popular choice. You may also enjoy Dirk Eddelbuettelâs <a href="http://www.springer.com/statistics/computational+statistics/book/978-1-4614-6867-7" target="_blank" rel="external"><em>Seamless R and C++ integration with Rcpp</em></a>, which goes into much greater detail into all aspects of Rcpp.</p>
<h5 id="Outline-13"><a href="#Outline-13" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#rcpp-intro">Getting started with C++</a> teaches you how to write C++ by  converting simple R functions to their C++ equivalents. Youâll learn how  C++ differs from R, and what the key scalar, vector, and matrix classes  are called.</li>
<li><a href="#sourceCpp">Using sourceCpp</a> shows you how to use <code>sourceCpp()</code> to load  a C++ file from disk in the same way you use <code>source()</code> to load a file of  R code.</li>
<li><a href="#rcpp-classes">Attributes &amp; other classes</a> discusses how to modify  attributes from Rcpp, and mentions some of the other important classes.</li>
<li><a href="#rcpp-na">Missing values</a> teaches you how to work with Râs missing values  in C++.</li>
<li><a href="#rcpp-sugar">Rcpp sugar</a> discusses Rcpp âsugarâ, which allows you to  avoid loops in C++ and write code that looks very similar to vectorised R  code.</li>
<li><a href="#stl">The STL</a> shows you how to use some of the most important data  structures and algorithms from the standard template library, or STL,  built-in to C++.</li>
<li><a href="#rcpp-case-studies">Case studies</a> shows two real case studies where  Rcpp was used to get considerable performance improvements.</li>
<li><a href="#rcpp-package">Putting Rcpp in a package</a> teaches you how to add C++ code  to a package.</li>
<li><a href="#rcpp-more">Learning more</a> concludes the chapter with pointers to  more resources to help you learn Rcpp and C++.</li>
</ul>
<h5 id="Prerequistes"><a href="#Prerequistes" class="headerlink" title="Prerequistes"></a>Prerequistes</h5><p>All examples in this chapter need version 0.10.1 or above of the <code>Rcpp</code> package. This version includes <code>cppFunction()</code> and <code>sourceCpp()</code>, which makes it very easy to connect C++ to R. Install the latest version of Rcpp from CRAN with <code>install.packages(&quot;Rcpp&quot;)</code>.</p>
<p>Youâll also need a working C++ compiler. To get it:</p>
<ul>
<li>On Windows, install <a href="http://cran.r-project.org/bin/windows/Rtools/" target="_blank" rel="external">Rtools</a>.</li>
<li>On Mac, install Xcode from the app store.</li>
<li>On Linux, <code>sudo apt-get install r-base-dev</code> or similar.</li>
</ul>
<h2 id="Getting-started-with-C"><a href="#Getting-started-with-C" class="headerlink" title="Getting started with C++"></a><a href="id=&quot;rcpp-intro&quot;">Getting started with C++</a></h2><p><code>cppFunction()</code> allows you to write C++ functions in R:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">library(Rcpp)</span><br><span class="line">cppFunction(&apos;int add(int x, int y, int z) &#123;</span><br><span class="line">  int sum = x + y + z;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;&apos;)</span><br><span class="line"># add works like a regular R function</span><br><span class="line">add</span><br><span class="line">add(1, 2, 3)</span><br></pre></td></tr></table></figure>
<p>When you run this code, Rcpp will compile the C++ code and construct an R function that connects to the compiled C++ function. Weâre going to use this simple interface to learn how to write C++. C++ is a large language, and thereâs no way to cover it all in just one chapter. Instead, youâll get the basics so that you can start writing useful functions to address bottlenecks in your R code.</p>
<p>The following sections will teach you the basics by translating simple R functions to their C++ equivalents. Weâll start simple with a function that has no inputs and a scalar output, and then get progressively more complicated:</p>
<ul>
<li>Scalar input and scalar output</li>
<li>Vector input and scalar output</li>
<li>Vector input and vector output</li>
<li>Matrix input and vector output</li>
</ul>
<h3 id="No-inputs-scalar-output"><a href="#No-inputs-scalar-output" class="headerlink" title="No inputs, scalar output"></a>No inputs, scalar output</h3><p>Letâs start with a very simple function. It has no arguments and always returns the integer 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one &lt;- function() 1L</span><br></pre></td></tr></table></figure>
<p>The equivalent C++ function is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can compile and use this from R with <code>cppFunction</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cppFunction(&apos;int one() &#123;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;&apos;)</span><br></pre></td></tr></table></figure>
<p>This small function illustrates a number of important differences between R and C++:</p>
<ul>
<li>The syntax to create a function looks like the syntax to call a function;  you donât use assignment to create functions as you do in R.</li>
<li>You must declare the type of output the function returns. This function  returns an <code>int</code> (a scalar integer). The classes for the most common types  of R vectors are: <code>NumericVector</code>, <code>IntegerVector</code>, <code>CharacterVector</code>, and  <code>LogicalVector</code>.</li>
<li>Scalars and vectors are different. The scalar equivalents of numeric,  integer, character, and logical vectors are: <code>double</code>, <code>int</code>, <code>String</code>, and  <code>bool</code>.</li>
<li>You must use an explicit <code>return</code> statement to return a value from a  function.</li>
<li>Every statement is terminated by a <code>;</code>.</li>
</ul>
<h3 id="Scalar-input-scalar-output"><a href="#Scalar-input-scalar-output" class="headerlink" title="Scalar input, scalar output"></a>Scalar input, scalar output</h3><p>The next example function implements a scalar version of the <code>sign()</code> function which returns 1 if the input is positive, and -1 if itâs negative:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">signR &lt;- function(x) &#123;</span><br><span class="line">  if (x &gt; 0) &#123;</span><br><span class="line">    1</span><br><span class="line">  &#125; else if (x == 0) &#123;</span><br><span class="line">    0</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    -1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cppFunction(&apos;int signC(int x) &#123;</span><br><span class="line">  if (x &gt; 0) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125; else if (x == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&apos;)</span><br></pre></td></tr></table></figure>
<p>In the C++ version:</p>
<ul>
<li>We declare the type of each input in the same way we declare the type of the  output. While this makes the code a little more verbose, it also makes it  very obvious what type of input the function needs.</li>
<li>The <code>if</code> syntax is identical â while there are some big differences between  R and C++, there are also lots of similarities! C++ also has a <code>while</code>  statement that works the same way as Râs. As in R you can use <code>break</code> to  exit the loop, but to skip one iteration you need to use <code>continue</code> instead  of <code>next</code>.</li>
</ul>
<h3 id="Vector-input-scalar-output"><a href="#Vector-input-scalar-output" class="headerlink" title="Vector input, scalar output"></a>Vector input, scalar output</h3><p>One big difference between R and C++ is that the cost of loops is much lower in C++. For example, we could implement the <code>sum</code> function in R using a loop. If youâve been programming in R a while, youâll probably have a visceral reaction to this function!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sumR &lt;- function(x) &#123;</span><br><span class="line">  total &lt;- 0</span><br><span class="line">  for (i in seq_along(x)) &#123;</span><br><span class="line">    total &lt;- total + x[i]</span><br><span class="line">  &#125;</span><br><span class="line">  total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In C++, loops have very little overhead, so itâs fine to use them. In <a href="#stl">STL</a>, youâll see alternatives to <code>for</code> loops that more clearly express your intent; theyâre not faster, but they can make your code easier to understand.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cppFunction(&apos;double sumC(NumericVector x) &#123;</span><br><span class="line">  int n = x.size();</span><br><span class="line">  double total = 0;</span><br><span class="line">  for(int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    total += x[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return total;</span><br><span class="line">&#125;&apos;)</span><br></pre></td></tr></table></figure>
<p>The C++ version is similar, but:</p>
<ul>
<li>To find the length of the vector, we use the <code>.size()</code> method, which returns  an integer. C++ methods are called with <code>.</code> (i.e., a full stop).</li>
<li>The <code>for</code> statement has a different syntax: <code>for(init; check; increment)</code>.  This loop is initialised by creating a new variable called <code>i</code> with value 0.  Before each iteration we check that <code>i &lt; n</code>, and terminate the loop if itâs  not. After each iteration, we increment the value of <code>i</code> by one, using the  special prefix operator <code>++</code> which increases the value of <code>i</code> by 1.</li>
<li>In C++, vector indices start at 0. Iâll say this again because itâs so  important: <strong>IN C++, VECTOR INDICES START AT 0</strong>! This is a very common  source of bugs when converting R functions to C++.</li>
<li>Use <code>=</code> for assignment, not <code>&lt;-</code>.</li>
<li>C++ provides operators that modify in-place: <code>total += x[i]</code> is equivalent to  <code>total = total + x[i]</code>. Similar in-place operators are <code>-=</code>, <code>*=</code>, and <code>/=</code>.</li>
</ul>
<p>This is a good example of where C++ is much more efficient than R. As shown by the following microbenchmark, <code>sumC()</code> is competitive with the built-in (and highly optimised) <code>sum()</code>, while <code>sumR()</code> is several orders of magnitude slower.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- runif(1e3)</span><br><span class="line">microbenchmark(</span><br><span class="line">  sum(x),</span><br><span class="line">  sumC(x),</span><br><span class="line">  sumR(x)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Vector-input-vector-output"><a href="#Vector-input-vector-output" class="headerlink" title="Vector input, vector output"></a>Vector input, vector output</h3><!-- FIXME: come up with better example. Also fix in two other places it occurs -->
<p>Next weâll create a function that computes the Euclidean distance between a value and a vector of values:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pdistR &lt;- function(x, ys) &#123;</span><br><span class="line">  sqrt((x - ys) ^ 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Itâs not obvious that we want <code>x</code> to be a scalar from the function definition. Weâd need to make that clear in the documentation. Thatâs not a problem in the C++ version because we have to be explicit about types:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cppFunction(&apos;NumericVector pdistC(double x, NumericVector ys) &#123;</span><br><span class="line">  int n = ys.size();</span><br><span class="line">  NumericVector out(n);</span><br><span class="line"></span><br><span class="line">  for(int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    out[i] = sqrt(pow(ys[i] - x, 2.0));</span><br><span class="line">  &#125;</span><br><span class="line">  return out;</span><br><span class="line">&#125;&apos;)</span><br></pre></td></tr></table></figure>
<p>This function introduces only a few new concepts:</p>
<ul>
<li>We create a new numeric vector of length <code>n</code> with a constructor: <code>NumericVector out(n)</code>. Another useful way of making a vector is to copy an existing one: <code>NumericVector zs = clone(ys)</code>.</li>
<li>C++ uses <code>pow()</code>, not <code>^</code>, for exponentiation.</li>
</ul>
<p>Note that because the R version is fully vectorised, itâs already going to be fast. On my computer, it takes around 8 ms with a 1 million element <code>y</code> vector. The C++ function is twice as fast, ~4 ms, but assuming it took you 10 minutes to write the C++ function, youâd need to run it ~150,000 times to make rewriting worthwhile. The reason why the C++ function is faster is subtle, and relates to memory management. The R version needs to create an intermediate vector the same length as y (<code>x - ys</code>), and allocating memory is an expensive operation. The C++ function avoids this overhead because it uses an intermediate scalar.</p>
<p>In the sugar section, youâll see how to rewrite this function to take advantage of Rcppâs vectorised operations so that the C++ code is almost as concise as R code.</p>
<h3 id="Matrix-input-vector-output"><a href="#Matrix-input-vector-output" class="headerlink" title="Matrix input, vector output"></a>Matrix input, vector output</h3><p>Each vector type has a matrix equivalent: <code>NumericMatrix</code>, <code>IntegerMatrix</code>, <code>CharacterMatrix</code>, and <code>LogicalMatrix</code>. Using them is straightforward. For example, we could create a function that reproduces <code>rowSums()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cppFunction(&apos;NumericVector rowSumsC(NumericMatrix x) &#123;</span><br><span class="line">  int nrow = x.nrow(), ncol = x.ncol();</span><br><span class="line">  NumericVector out(nrow);</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; nrow; i++) &#123;</span><br><span class="line">    double total = 0;</span><br><span class="line">    for (int j = 0; j &lt; ncol; j++) &#123;</span><br><span class="line">      total += x(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    out[i] = total;</span><br><span class="line">  &#125;</span><br><span class="line">  return out;</span><br><span class="line">&#125;&apos;)</span><br><span class="line">set.seed(1014)</span><br><span class="line">x &lt;- matrix(sample(100), 10)</span><br><span class="line">rowSums(x)</span><br><span class="line">rowSumsC(x)</span><br></pre></td></tr></table></figure>
<p>The main differences:</p>
<ul>
<li>In C++, you subset a matrix with <code>()</code>, not <code>[]</code>.</li>
<li>Use <code>.nrow()</code> and <code>.ncol()</code> <em>methods</em> to get the dimensions of a matrix.</li>
</ul>
<h3 id="Using-sourceCpp"><a href="#Using-sourceCpp" class="headerlink" title="Using sourceCpp"></a><a href="id=&quot;sourceCpp&quot;">Using sourceCpp</a></h3><p>So far, weâve used inline C++ with <code>cppFunction()</code>. This makes presentation simpler, but for real problems, itâs usually easier to use stand-alone C++ files and then source them into R using <code>sourceCpp()</code>. This lets you take advantage of text editor support for C++ files (e.g., syntax highlighting) as well as making it easier to identify the line numbers in compilation errors.</p>
<p>Your stand-alone C++ file should have extension <code>.cpp</code>, and needs to start with:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Rcpp.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Rcpp;</span><br></pre></td></tr></table></figure>
<p>And for each function that you want available within R, you need to prefix it with:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [[Rcpp::export]]</span></span><br></pre></td></tr></table></figure>
<p>Note that the space is mandatory.</p>
<p>If youâre familiar with roxygen2, you might wonder how this relates to <code>@export</code>. <code>Rcpp::export</code> controls whether a function is exported from C++ to R; <code>@export</code> controls whether a function is exported from a package and made available to the user.</p>
<p>You can embed R code in special C++ comment blocks. This is really convenient if you want to run some test code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** R</span><br><span class="line"># This is R code</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>The R code is run with <code>source(echo = TRUE)</code> so you donât need to explicitly print output.</p>
<p>To compile the C++ code, use <code>sourceCpp(&quot;path/to/file.cpp&quot;)</code>. This will create the matching R functions and add them to your current session. Note that these functions can not be saved in a <code>.Rdata</code> file and reloaded in a later session; they must be recreated each time you restart R. For example, running <code>sourceCpp()</code> on the following file implements mean in C++ and then compares it to the built-in <code>mean()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">double meanC(NumericVector x) &#123;</span><br><span class="line">  int n = x.size();</span><br><span class="line">  double total = 0;</span><br><span class="line"></span><br><span class="line">  for(int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    total += x[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return total / n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*** R</span><br><span class="line">library(microbenchmark)</span><br><span class="line">x &lt;- runif(1e5)</span><br><span class="line">microbenchmark(</span><br><span class="line">  mean(x),</span><br><span class="line">  meanC(x)</span><br><span class="line">)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>NB: if you run this code yourself, youâll notice that <code>meanC()</code> is much faster than the built-in <code>mean()</code>. This is because it trades numerical accuracy for speed.</p>
<p>For the remainder of this chapter C++ code will be presented stand-alone rather than wrapped in a call to <code>cppFunction</code>. If you want to try compiling and/or modifying the examples you should paste them into a C++ source file that includes the elements described above.</p>
<h3 id="Exercises-59"><a href="#Exercises-59" class="headerlink" title="Exercises"></a>Exercises</h3><p>With the basics of C++ in hand, itâs now a great time to practice by reading and writing some simple C++ functions. For each of the following functions, read the code and figure out what the corresponding base R function is. You might not understand every part of the code yet, but you should be able to figure out the basics of what the function does.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(NumericVector x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line">  <span class="keyword">double</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    y += x[i] / n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NumericVector <span class="title">f2</span><span class="params">(NumericVector x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line">  <span class="function">NumericVector <span class="title">out</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  out[<span class="number">0</span>] = x[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    out[i] = out[i - <span class="number">1</span>] + x[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f3</span><span class="params">(LogicalVector x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f4</span><span class="params">(Function pred, List x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    LogicalVector res = pred(x[i]);</span><br><span class="line">    <span class="keyword">if</span> (res[<span class="number">0</span>]) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NumericVector <span class="title">f5</span><span class="params">(NumericVector x, NumericVector y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">std</span>::max(x.size(), y.size());</span><br><span class="line">  NumericVector x1 = rep_len(x, n);</span><br><span class="line">  NumericVector y1 = rep_len(y, n);</span><br><span class="line"></span><br><span class="line">  <span class="function">NumericVector <span class="title">out</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    out[i] = <span class="built_in">std</span>::min(x1[i], y1[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To practice your function writing skills, convert the following functions into C++. For now, assume the inputs have no missing values.</p>
<ol>
<li><code>all()</code></li>
<li><code>cumprod()</code>, <code>cummin()</code>, <code>cummax()</code>.</li>
<li><code>diff()</code>. Start by assuming lag 1, and then generalise for lag <code>n</code>.</li>
<li><code>range</code>.</li>
<li><code>var</code>. Read about the approaches you can take on   <a href="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance" target="_blank" rel="external">wikipedia</a>.   Whenever implementing a numerical algorithm, itâs always good to check what   is already known about the problem.</li>
</ol>
<h2 id="Attributes-and-other-classes"><a href="#Attributes-and-other-classes" class="headerlink" title="Attributes and other classes"></a><a href="id=&quot;rcpp-classes&quot;">Attributes and other classes</a></h2><p>Youâve already seen the basic vector classes (<code>IntegerVector</code>, <code>NumericVector</code>, <code>LogicalVector</code>, <code>CharacterVector</code>) and their scalar (<code>int</code>, <code>double</code>, <code>bool</code>, <code>String</code>) and matrix (<code>IntegerMatrix</code>, <code>NumericMatrix</code>, <code>LogicalMatrix</code>, <code>CharacterMatrix</code>) equivalents.</p>
<p>All R objects have attributes, which can be queried and modified with <code>.attr()</code>. Rcpp also provides <code>.names()</code> as an alias for the name attribute. The following code snippet illustrates these methods. Note the use of <code>::create()</code>, a <em>class</em> method. This allows you to create an R vector from C++ scalar values:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">NumericVector attribs() &#123;</span><br><span class="line">  NumericVector out = NumericVector::create(1, 2, 3);</span><br><span class="line"></span><br><span class="line">  out.names() = CharacterVector::create(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">  out.attr(&quot;my-attr&quot;) = &quot;my-value&quot;;</span><br><span class="line">  out.attr(&quot;class&quot;) = &quot;my-class&quot;;</span><br><span class="line"></span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For S4 objects, <code>.slot()</code> plays a similar role to <code>.attr()</code>.</p>
<h3 id="Lists-and-data-frames"><a href="#Lists-and-data-frames" class="headerlink" title="Lists and data frames"></a>Lists and data frames</h3><p>Rcpp also provides classes <code>List</code> and <code>DataFrame</code>, but they are more useful for output than input. This is because lists and data frames can contain arbitrary classes but C++ needs to know their classes in advance. If the list has known structure (e.g., itâs an S3 object), you can extract the components and manually convert them to their C++ equivalents with <code>as()</code>. For example, the object created by <code>lm()</code>, the function that fits a linear model, is a list whose components are always of the same type. The following code illustrates how you might extract the mean percentage error (<code>mpe()</code>) of a linear model. This isnât a good example of when to use C++, because itâs so easily implemented in R, but it shows how to work with an important S3 class. Note the use of <code>.inherits()</code> and the <code>stop()</code> to check that the object really is a linear model.</p>
<!-- FIXME: needs better motivation -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">double mpe(List mod) &#123;</span><br><span class="line">  if (!mod.inherits(&quot;lm&quot;)) stop(&quot;Input must be a linear model&quot;);</span><br><span class="line"></span><br><span class="line">  NumericVector resid = as&lt;NumericVector&gt;(mod[&quot;residuals&quot;]);</span><br><span class="line">  NumericVector fitted = as&lt;NumericVector&gt;(mod[&quot;fitted.values&quot;]);</span><br><span class="line"></span><br><span class="line">  int n = resid.size();</span><br><span class="line">  double err = 0;</span><br><span class="line">  for(int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    err += resid[i] / (fitted[i] + resid[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return err / n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mod &lt;- lm(mpg ~ wt, data = mtcars)</span><br><span class="line">mpe(mod)</span><br></pre></td></tr></table></figure>
<h3 id="Functions-1"><a href="#Functions-1" class="headerlink" title="Functions"></a><a href="id=&quot;functions-rcpp&quot;">Functions</a></h3><p>You can put R functions in an object of type <code>Function</code>. This makes calling an R function from C++ straightforward. We first define our C++ function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">RObject callWithOne(Function f) &#123;</span><br><span class="line">  return f(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then call it from R:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">callWithOne(function(x) x + 1)</span><br><span class="line">callWithOne(paste)</span><br></pre></td></tr></table></figure>
<p>What type of object does an R function return? We donât know, so we use the catchall type <code>RObject</code>. An alternative is to return a <code>List</code>. For example, the following code is a basic implementation of <code>lapply</code> in C++:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">List lapply1(List input, Function f) &#123;</span><br><span class="line">  int n = input.size();</span><br><span class="line">  List out(n);</span><br><span class="line"></span><br><span class="line">  for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    out[i] = f(input[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Calling R functions with positional arguments is obvious:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="string">"y"</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>But to use named arguments, you need a special syntax:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(_[<span class="string">"x"</span>] = <span class="string">"y"</span>, _[<span class="string">"value"</span>] = <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Other-types"><a href="#Other-types" class="headerlink" title="Other types"></a>Other types</h3><p>There are also classes for many more specialised language objects: <code>Environment</code>, <code>ComplexVector</code>, <code>RawVector</code>, <code>DottedPair</code>, <code>Language</code>,  <code>Promise</code>, <code>Symbol</code>, <code>WeakReference</code>, and so on. These are beyond the scope of this chapter and wonât be discussed further.</p>
<h2 id="Missing-values"><a href="#Missing-values" class="headerlink" title="Missing values"></a><a href="id=&quot;rcpp-na&quot;">Missing values</a></h2><p>If youâre working with missing values, you need to know two things:</p>
<ul>
<li>how Râs missing values behave in C++âs scalars (e.g., <code>double</code>).</li>
<li>how to get and set missing values in vectors (e.g., <code>NumericVector</code>).</li>
</ul>
<h3 id="Scalars"><a href="#Scalars" class="headerlink" title="Scalars"></a>Scalars</h3><p>The following code explores what happens when you take one of Râs missing values, coerce it into a scalar, and then coerce back to an R vector. Note that this kind of experimentation is a useful way to figure out what any operation does.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">List scalar_missings() &#123;</span><br><span class="line">  int int_s = NA_INTEGER;</span><br><span class="line">  String chr_s = NA_STRING;</span><br><span class="line">  bool lgl_s = NA_LOGICAL;</span><br><span class="line">  double num_s = NA_REAL;</span><br><span class="line"></span><br><span class="line">  return List::create(int_s, chr_s, lgl_s, num_s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str(scalar_missings())</span><br></pre></td></tr></table></figure>
<p>With the exception of <code>bool</code>, things look pretty good here: all of the missing values have been preserved. However, as weâll see in the following sections, things are not quite as straightforward as they seem.</p>
<h4 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h4><p>With integers, missing values are stored as the smallest integer. If you donât do anything to them, theyâll be preserved. But, since C++ doesnât know that the smallest integer has this special behaviour, if you do anything to it youâre likely to get an incorrect value: for example, <code>evalCpp(&#39;NA_INTEGER + 1&#39;)</code> gives -2147483647.</p>
<p>So if you want to work with missing values in integers, either use a length one <code>IntegerVector</code> or be very careful with your code.</p>
<h4 id="Doubles"><a href="#Doubles" class="headerlink" title="Doubles"></a>Doubles</h4><p>With doubles, you may be able to get away with ignoring missing values and working with NaNs (not a number). This is because Râs NA is a special type of IEEE 754 floating point number NaN. So any logical expression that involves a NaN (or in C++, NAN) always evaluates as FALSE:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library(Rcpp)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evalCpp(&quot;NAN == 1&quot;)</span><br><span class="line">evalCpp(&quot;NAN &lt; 1&quot;)</span><br><span class="line">evalCpp(&quot;NAN &gt; 1&quot;)</span><br><span class="line">evalCpp(&quot;NAN == NAN&quot;)</span><br></pre></td></tr></table></figure>
<p>But be careful when combining then with boolean values:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">evalCpp(&quot;NAN &amp;&amp; TRUE&quot;)</span><br><span class="line">evalCpp(&quot;NAN || FALSE&quot;)</span><br></pre></td></tr></table></figure>
<p>However, in numeric contexts NaNs will propagate NAs:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evalCpp(&quot;NAN + 1&quot;)</span><br><span class="line">evalCpp(&quot;NAN - 1&quot;)</span><br><span class="line">evalCpp(&quot;NAN / 1&quot;)</span><br><span class="line">evalCpp(&quot;NAN * 1&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p><code>String</code> is a scalar string class introduced by Rcpp, so it knows how to deal with missing values.</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>While C++âs <code>bool</code> has two possible values (<code>true</code> or <code>false</code>), a logical vector in R has three (<code>TRUE</code>, <code>FALSE</code>, and <code>NA</code>). If you coerce a length 1 logical vector, make sure it doesnât contain any missing values otherwise they will be converted to TRUE.</p>
<h3 id="Vectors-1"><a href="#Vectors-1" class="headerlink" title="Vectors"></a><a href="id=&quot;vectors-rcpp&quot;">Vectors</a></h3><p>With vectors, you need to use a missing value specific to the type of vector, <code>NA_REAL</code>, <code>NA_INTEGER</code>, <code>NA_LOGICAL</code>, <code>NA_STRING</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">List missing_sampler() &#123;</span><br><span class="line">  return List::create(</span><br><span class="line">    NumericVector::create(NA_REAL),</span><br><span class="line">    IntegerVector::create(NA_INTEGER),</span><br><span class="line">    LogicalVector::create(NA_LOGICAL),</span><br><span class="line">    CharacterVector::create(NA_STRING));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str(missing_sampler())</span><br></pre></td></tr></table></figure>
<p>To check if a value in a vector is missing, use the class method <code>::is_na()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">LogicalVector is_naC(NumericVector x) &#123;</span><br><span class="line">  int n = x.size();</span><br><span class="line">  LogicalVector out(n);</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    out[i] = NumericVector::is_na(x[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_naC(c(NA, 5.4, 3.2, NA))</span><br></pre></td></tr></table></figure>
<p>Another alternative is the sugar function <code>is_na()</code>, which takes a vector and returns a logical vector.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">LogicalVector is_naC2(NumericVector x) &#123;</span><br><span class="line">  return is_na(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_naC2(c(NA, 5.4, 3.2, NA))</span><br></pre></td></tr></table></figure>
<h3 id="Exercises-60"><a href="#Exercises-60" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Rewrite any of the functions from the first exercise to deal with missing   values. If <code>na.rm</code> is true, ignore the missing values. If <code>na.rm</code> is false,   return a missing value if the input contains any missing values. Some   good functions to practice with are <code>min()</code>, <code>max()</code>, <code>range()</code>, <code>mean()</code>,   and <code>var()</code>.</li>
<li>Rewrite <code>cumsum()</code> and <code>diff()</code> so they can handle missing values. Note that   these functions have slightly more complicated behaviour.</li>
</ol>
<h2 id="Rcpp-sugar"><a href="#Rcpp-sugar" class="headerlink" title="Rcpp sugar"></a><a href="id=&quot;rcpp-sugar&quot;">Rcpp sugar</a></h2><p>Rcpp provides a lot of syntactic âsugarâ to ensure that C++ functions work very similarly to their R equivalents. In fact, Rcpp sugar makes it possible to write efficient C++ code that looks almost identical to its R equivalent. If thereâs a sugar version of the function youâre interested in, you should use it: itâll be both expressive and well tested. Sugar functions arenât always faster than a handwritten equivalent, but they will get faster in the future as more time is spent on optimising Rcpp.</p>
<p>Sugar functions can be roughly broken down into</p>
<ul>
<li>arithmetic and logical operators</li>
<li>logical summary functions</li>
<li>vector views</li>
<li>other useful functions</li>
</ul>
<h3 id="Arithmetic-and-logical-operators"><a href="#Arithmetic-and-logical-operators" class="headerlink" title="Arithmetic and logical operators"></a>Arithmetic and logical operators</h3><p>All the basic arithmetic and logical operators are vectorised: <code>+</code> <code>*</code>, <code>-</code>, <code>/</code>, <code>pow</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>, <code>!</code>.  For example, we could use sugar to considerably simplify the implementation of <code>pdistC()</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pdistR &lt;- function(x, ys) &#123;</span><br><span class="line">  sqrt((x - ys) ^ 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">NumericVector pdistC2(double x, NumericVector ys) &#123;</span><br><span class="line">  return sqrt(pow((x - ys), 2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Logical-summary-functions"><a href="#Logical-summary-functions" class="headerlink" title="Logical summary functions"></a>Logical summary functions</h3><p>The sugar function <code>any()</code> and <code>all()</code> are fully lazy so that <code>any(x == 0)</code>, for example, might only need to evaluate one element of a vector, and return a special type that can be converted into a <code>bool</code> using <code>.is_true()</code>, <code>.is_false()</code>, or <code>.is_na()</code>. We could also use this sugar to write an efficient function to determine whether or not a numeric vector contains any missing values. To do this in R, we could use <code>any(is.na(x))</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">any_naR &lt;- function(x) any(is.na(x))</span><br></pre></td></tr></table></figure>
<p>However, this will do the same amount of work regardless of the location of the missing value. Hereâs the C++ implementation:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">bool any_naC(NumericVector x) &#123;</span><br><span class="line">  return is_true(any(is_na(x)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x0 &lt;- runif(1e5)</span><br><span class="line">x1 &lt;- c(x0, NA)</span><br><span class="line">x2 &lt;- c(NA, x0)</span><br><span class="line"></span><br><span class="line">microbenchmark(</span><br><span class="line">  any_naR(x0), any_naC(x0),</span><br><span class="line">  any_naR(x1), any_naC(x1),</span><br><span class="line">  any_naR(x2), any_naC(x2)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Vector-views"><a href="#Vector-views" class="headerlink" title="Vector views"></a>Vector views</h3><p>A number of helpful functions provide a âviewâ of a vector: <code>head()</code>, <code>tail()</code>, <code>rep_each()</code>, <code>rep_len()</code>, <code>rev()</code>, <code>seq_along()</code>, and <code>seq_len()</code>. In R these would all produce copies of the vector, but in Rcpp they simply point to the existing vector and override the subsetting operator (<code>[</code>) to implement special behaviour. This makes them very efficient: for instance, <code>rep_len(x, 1e6)</code> does not have to make a million copies of x.</p>
<h3 id="Other-useful-functions"><a href="#Other-useful-functions" class="headerlink" title="Other useful functions"></a>Other useful functions</h3><p>Finally, thereâs a grab bag of sugar functions that mimic frequently used R functions:</p>
<ul>
<li>Math functions: <code>abs()</code>, <code>acos()</code>, <code>asin()</code>, <code>atan()</code>, <code>beta()</code>, <code>ceil()</code>, <code>ceiling()</code>, <code>choose()</code>, <code>cos()</code>, <code>cosh()</code>, <code>digamma()</code>, <code>exp()</code>, <code>expm1()</code>, <code>factorial()</code>, <code>floor()</code>, <code>gamma()</code>, <code>lbeta()</code>, <code>lchoose()</code>, <code>lfactorial()</code>, <code>lgamma()</code>, <code>log()</code>, <code>log10()</code>, <code>log1p()</code>, <code>pentagamma()</code>, <code>psigamma()</code>, <code>round()</code>, <code>signif()</code>, <code>sin()</code>, <code>sinh()</code>, <code>sqrt()</code>, <code>tan()</code>, <code>tanh()</code>, <code>tetragamma()</code>, <code>trigamma()</code>, <code>trunc()</code>.</li>
<li>Scalar summaries: <code>mean()</code>, <code>min()</code>, <code>max()</code>, <code>sum()</code>, <code>sd()</code>, and  (for vectors) <code>var()</code>.</li>
<li>Vector summaries: <code>cumsum()</code>, <code>diff()</code>, <code>pmin()</code>, and <code>pmax()</code>.</li>
<li>Finding values: <code>match()</code>, <code>self_match()</code>, <code>which_max()</code>, <code>which_min()</code>.</li>
<li>Dealing with duplicates: <code>duplicated()</code>, <code>unique()</code>.</li>
<li><code>d/q/p/r</code> for all standard distributions.</li>
</ul>
<p>Finally, <code>noNA(x)</code> asserts that the vector <code>x</code> does not contain any missing  values, and allows optimisation of some mathematical operations.</p>
<h2 id="The-STL"><a href="#The-STL" class="headerlink" title="The STL"></a><a href="id=&quot;stl&quot;">The STL</a></h2><p>The real strength of C++ shows itself when you need to implement more complex algorithms. The standard template library (STL) provides a set of extremely useful data structures and algorithms. This section will explain some of the most important algorithms and data structures and point you in the right direction to learn more.  I canât teach you everything you need to know about the STL, but hopefully the examples will show you the power of the STL, and persuade you that itâs useful to learn more.</p>
<p>If you need an algorithm or data structure that isnât implemented in STL, a good place to look is <a href="http://www.boost.org/doc/" target="_blank" rel="external">boost</a>. Installing boost on your computer is beyond the scope of this chapter, but once you have it installed, you can use boost data structures and algorithms by including the appropriate header file with (e.g.) <code>#include &lt;boost/array.hpp&gt;</code>.</p>
<h3 id="Using-iterators"><a href="#Using-iterators" class="headerlink" title="Using iterators"></a>Using iterators</h3><p>Iterators are used extensively in the STL: many functions either accept or return iterators. They are the next step up from basic loops, abstracting away the details of the underlying data structure. Iterators have three main operators:</p>
<ol>
<li>Advance with <code>++</code>.</li>
<li>Get the value they refer to, or <strong>dereference</strong>, with <code>*</code>.</li>
<li>Compare with <code>==</code>.</li>
</ol>
<p>For example we could re-write our sum function using iterators:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">double sum3(NumericVector x) &#123;</span><br><span class="line">  double total = 0;</span><br><span class="line"></span><br><span class="line">  NumericVector::iterator it;</span><br><span class="line">  for(it = x.begin(); it != x.end(); ++it) &#123;</span><br><span class="line">    total += *it;</span><br><span class="line">  &#125;</span><br><span class="line">  return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The main changes are in the for loop:</p>
<ul>
<li>We start at <code>x.begin()</code> and loop until we get to <code>x.end()</code>. A small  optimization is to store the value of the end iterator so we donât need to  look it up each time. This only saves about 2 ns per iteration, so itâs only  important when the calculations in the loop are very simple.</li>
<li>Instead of indexing into x, we use the dereference operator to get its  current value: <code>*it</code>.</li>
<li>Notice the type of the iterator: <code>NumericVector::iterator</code>. Each vector  type has its own iterator type: <code>LogicalVector::iterator</code>,  <code>CharacterVector::iterator</code>, etc.</li>
</ul>
<p>Iterators also allow us to use the C++ equivalents of the apply family of functions. For example, we could again rewrite <code>sum()</code> to use the <code>accumulate()</code> function, which takes a starting and an ending iterator, and adds up all the values in the vector. The third argument to accumulate gives the initial value: itâs particularly important because this also determines the data type that accumulate uses (so we use <code>0.0</code> and not <code>0</code> so that accumulate uses a <code>double</code>, not an <code>int</code>.). To use <code>accumulate()</code> we need to include the <code>&lt;numeric&gt;</code> header.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">double sum4(NumericVector x) &#123;</span><br><span class="line">  return std::accumulate(x.begin(), x.end(), 0.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>accumulate()</code> (along with the other functions in <code>&lt;numeric&gt;</code>, like <code>adjacent_difference()</code>, <code>inner_product()</code>, and <code>partial_sum()</code>) is not that important in Rcpp because Rcpp sugar provides equivalents.</p>
<h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><p>The <code>&lt;algorithm&gt;</code> header provides a large number of algorithms that work with iterators. A good reference is available at <a href="http://www.cplusplus.com/reference/algorithm/" target="_blank" rel="external">http://www.cplusplus.com/reference/algorithm/</a>. For example, we could write a basic Rcpp version of <code>findInterval()</code> that takes two arguments a vector of values and a vector of breaks, and locates the bin that each x falls into. This shows off a few more advanced iterator features. Read the code below and see if you can figure out how it works.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">IntegerVector findInterval2(NumericVector x, NumericVector breaks) &#123;</span><br><span class="line">  IntegerVector out(x.size());</span><br><span class="line"></span><br><span class="line">  NumericVector::iterator it, pos;</span><br><span class="line">  IntegerVector::iterator out_it;</span><br><span class="line"></span><br><span class="line">  for(it = x.begin(), out_it = out.begin(); it != x.end();</span><br><span class="line">      ++it, ++out_it) &#123;</span><br><span class="line">    pos = std::upper_bound(breaks.begin(), breaks.end(), *it);</span><br><span class="line">    *out_it = std::distance(breaks.begin(), pos);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The key points are:</p>
<ul>
<li>We step through two iterators (input and output) simultaneously.</li>
<li>We can assign into an dereferenced iterator (<code>out_it</code>) to change the values  in <code>out</code>.</li>
<li><code>upper_bound()</code> returns an iterator. If we wanted the value of the  <code>upper_bound()</code> we could dereference it; to figure out its location, we  use the <code>distance()</code> function.</li>
<li>Small note: if we want this function to be as fast as <code>findInterval()</code> in R  (which uses handwritten C code), we need to compute the calls to <code>.begin()</code>  and <code>.end()</code> once and save the results.  This is easy, but it distracts from  this example so it has been omitted.  Making this change yields a function  thatâs slightly faster than Râs <code>findInterval()</code> function, but is about 1/10  of the code.</li>
</ul>
<p>Itâs generally better to use algorithms from the STL than hand rolled loops. In <em>Effective STL</em>, Scott Meyers gives three reasons: efficiency, correctness, and maintainability. Algorithms from the STL are written by C++ experts to be extremely efficient, and they have been around for a long time so they are well tested. Using standard algorithms also makes the intent of your code more clear, helping to make it more readable and more maintainable.</p>
<h3 id="Data-structures-1"><a href="#Data-structures-1" class="headerlink" title="Data structures"></a><a href="id=&quot;data-structures-rcpp&quot;">Data structures</a></h3><p>The STL provides a large set of data structures: <code>array</code>, <code>bitset</code>, <code>list</code>, <code>forward_list</code>, <code>map</code>, <code>multimap</code>, <code>multiset</code>, <code>priority_queue</code>, <code>queue</code>, <code>dequeue</code>, <code>set</code>, <code>stack</code>, <code>unordered_map</code>, <code>unordered_set</code>, <code>unordered_multimap</code>, <code>unordered_multiset</code>, and <code>vector</code>.  The most important of these data structures are the <code>vector</code>, the <code>unordered_set</code>, and the <code>unordered_map</code>.  Weâll focus on these three in this section, but using the others is similar: they just have different performance trade-offs. For example, the <code>deque</code> (pronounced âdeckâ) has a very similar interface to vectors but a different underlying implementation that has different performance trade-offs. You may want to try them for your problem. A good reference for STL data structures is <a href="http://www.cplusplus.com/reference/stl/" target="_blank" rel="external">http://www.cplusplus.com/reference/stl/</a> â I recommend you keep it open while working with the STL.</p>
<p>Rcpp knows how to convert from many STL data structures to their R equivalents, so you can return them from your functions without explicitly converting to R data structures.</p>
<h3 id="Vectors-2"><a href="#Vectors-2" class="headerlink" title="Vectors"></a><a href="id=&quot;vectors-stl&quot;">Vectors</a></h3><p>An STL vector is very similar to an R vector, except that it grows efficiently. This makes vectors appropriate to use when you donât know in advance how big the output will be.  Vectors are templated, which means that you need to specify the type of object the vector will contain when you create it: <code>vector&lt;int&gt;</code>, <code>vector&lt;bool&gt;</code>, <code>vector&lt;double&gt;</code>, <code>vector&lt;String&gt;</code>.  You can access individual elements of a vector using the standard <code>[]</code> notation, and you can add a new element to the end of the vector using <code>.push_back()</code>.  If you have some idea in advance how big the vector will be, you can use <code>.reserve()</code> to allocate sufficient storage.</p>
<p>The following code implements run length encoding (<code>rle()</code>). It produces two vectors of output: a vector of values, and a vector <code>lengths</code> giving how many times each element is repeated. It works by looping through the input vector <code>x</code> comparing each value to the previous: if itâs the same, then it increments the last value in <code>lengths</code>; if itâs different, it adds the value to the end of <code>values</code>, and sets the corresponding length to 1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">List rleC(NumericVector x) &#123;</span><br><span class="line">  std::vector&lt;int&gt; lengths;</span><br><span class="line">  std::vector&lt;double&gt; values;</span><br><span class="line"></span><br><span class="line">  // Initialise first value</span><br><span class="line">  int i = 0;</span><br><span class="line">  double prev = x[0];</span><br><span class="line">  values.push_back(prev);</span><br><span class="line">  lengths.push_back(1);</span><br><span class="line"></span><br><span class="line">  NumericVector::iterator it;</span><br><span class="line">  for(it = x.begin() + 1; it != x.end(); ++it) &#123;</span><br><span class="line">    if (prev == *it) &#123;</span><br><span class="line">      lengths[i]++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      values.push_back(*it);</span><br><span class="line">      lengths.push_back(1);</span><br><span class="line"></span><br><span class="line">      i++;</span><br><span class="line">      prev = *it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return List::create(</span><br><span class="line">    _[&quot;lengths&quot;] = lengths,</span><br><span class="line">    _[&quot;values&quot;] = values</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(An alternative implementation would be to replace <code>i</code> with the iterator <code>lengths.rbegin()</code> which always points to the last element of the vector. You might want to try implementing that yourself.)</p>
<p>Other methods of a vector are described at <a href="http://www.cplusplus.com/reference/vector/vector/" target="_blank" rel="external">http://www.cplusplus.com/reference/vector/vector/</a>.</p>
<h3 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h3><p>Sets maintain a unique set of values, and can efficiently tell if youâve seen a value before. They are useful for problems that involve duplicates or unique values (like <code>unique</code>, <code>duplicated</code>, or <code>in</code>). C++ provides both ordered (<code>std::set</code>) and unordered sets (<code>std::unordered_set</code>), depending on whether or not order matters for you. Unordered sets tend to be much faster (because they use a hash table internally rather than a tree), so even if you need an ordered set, you should consider using an unordered set and then sorting the output. Like vectors, sets are templated, so you need to request the appropriate type of set for your purpose: <code>unordered_set&lt;int&gt;</code>, <code>unordered_set&lt;bool&gt;</code>, etc. More details are available at <a href="http://www.cplusplus.com/reference/set/set/" target="_blank" rel="external">http://www.cplusplus.com/reference/set/set/</a> and <a href="http://www.cplusplus.com/reference/unordered_set/unordered_set/" target="_blank" rel="external">http://www.cplusplus.com/reference/unordered_set/unordered_set/</a>.</p>
<p>The following function uses an unordered set to implement an equivalent to <code>duplicated()</code> for integer vectors. Note the use of <code>seen.insert(x[i]).second</code>. <code>insert()</code> returns a pair, the <code>.first</code> value is an iterator that points to element and the <code>.second</code> value is a boolean thatâs true if the value was a new addition to the set.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// [[Rcpp::plugins(cpp11)]]</span><br><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">LogicalVector duplicatedC(IntegerVector x) &#123;</span><br><span class="line">  std::unordered_set&lt;int&gt; seen;</span><br><span class="line">  int n = x.size();</span><br><span class="line">  LogicalVector out(n);</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    out[i] = !seen.insert(x[i]).second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that unordered sets are only available in C++ 11, which means we need to use the <code>cpp11</code> plugin, <code>[[Rcpp::plugins(cpp11)]]</code>.</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>A map is similar to a set, but instead of storing presence or absence, it can store additional data. Itâs useful for functions like <code>table()</code> or <code>match()</code> that need to look up a value. As with sets, there are ordered (<code>std::map</code>) and unordered (<code>std::unordered_map</code>) versions. Since maps have a value and a key, you need to specify both types when initialising a map: <code>map&lt;double, int&gt;</code>, <code>unordered_map&lt;int, double&gt;</code>, and so on. The following example shows how you could use a <code>map</code> to implement <code>table()</code> for numeric vectors:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">std::map&lt;double, int&gt; tableC(NumericVector x) &#123;</span><br><span class="line">  std::map&lt;double, int&gt; counts;</span><br><span class="line"></span><br><span class="line">  int n = x.size();</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    counts[x[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return counts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that unordered maps are only available in C++ 11, so to use them, youâll again need <code>[[Rcpp::plugins(cpp11)]]</code>.</p>
<h3 id="Exercises-61"><a href="#Exercises-61" class="headerlink" title="Exercises"></a>Exercises</h3><p>To practice using the STL algorithms and data structures, implement the following using R functions in C++, using the hints provided:</p>
<ol>
<li><code>median.default()</code> using <code>partial_sort</code>.</li>
<li><code>%in%</code> using <code>unordered_set</code> and the <code>find()</code> or <code>count()</code> methods.</li>
<li><code>unique()</code> using an <code>unordered_set</code> (challenge: do it in one line!).</li>
<li><code>min()</code> using <code>std::min()</code>, or <code>max()</code> using <code>std::max()</code>.</li>
<li><code>which.min()</code> using <code>min_element</code>, or <code>which.max()</code> using <code>max_element</code>.</li>
<li><code>setdiff()</code>, <code>union()</code>, and <code>intersect()</code> for integers using sorted ranges   and <code>set_union</code>, <code>set_intersection</code> and <code>set_difference</code>.</li>
</ol>
<h2 id="Case-studies"><a href="#Case-studies" class="headerlink" title="Case studies"></a><a href="id=&quot;rcpp-case-studies&quot;">Case studies</a></h2><p>The following case studies illustrate some real life uses of C++ to replace slow R code.</p>
<h3 id="Gibbs-sampler"><a href="#Gibbs-sampler" class="headerlink" title="Gibbs sampler"></a>Gibbs sampler</h3><!-- FIXME: needs more context? -->
<p>The following case study updates an example <a href="http://dirk.eddelbuettel.com/blog/2011/07/14/" target="_blank" rel="external">blogged about</a> by Dirk Eddelbuettel, illustrating the conversion of a Gibbs sampler in R to C++. The R and C++ code shown below is very similar (it only took a few minutes to convert the R version to the C++ version), but runs about 20 times faster on my computer. Dirkâs blog post also shows another way to make it even faster: using the faster random number generator functions in GSL (easily accessible from R through the RcppGSL package) can make it another 2â3x faster.</p>
<p>The R code is as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gibbs_r &lt;- function(N, thin) &#123;</span><br><span class="line">  mat &lt;- matrix(nrow = N, ncol = 2)</span><br><span class="line">  x &lt;- y &lt;- 0</span><br><span class="line"></span><br><span class="line">  for (i in 1:N) &#123;</span><br><span class="line">    for (j in 1:thin) &#123;</span><br><span class="line">      x &lt;- rgamma(1, 3, y * y + 4)</span><br><span class="line">      y &lt;- rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))</span><br><span class="line">    &#125;</span><br><span class="line">    mat[i, ] &lt;- c(x, y)</span><br><span class="line">  &#125;</span><br><span class="line">  mat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is straightforward to convert to C++.  We:</p>
<ul>
<li>add type declarations to all variables</li>
<li>use <code>(</code> instead of <code>[</code> to index into the matrix</li>
<li>subscript the results of <code>rgamma</code> and <code>rnorm</code> to convert from a vector  into a scalar</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">NumericMatrix gibbs_cpp(int N, int thin) &#123;</span><br><span class="line">  NumericMatrix mat(N, 2);</span><br><span class="line">  double x = 0, y = 0;</span><br><span class="line"></span><br><span class="line">  for(int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    for(int j = 0; j &lt; thin; j++) &#123;</span><br><span class="line">      x = rgamma(1, 3, 1 / (y * y + 4))[0];</span><br><span class="line">      y = rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))[0];</span><br><span class="line">    &#125;</span><br><span class="line">    mat(i, 0) = x;</span><br><span class="line">    mat(i, 1) = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return(mat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Benchmarking the two implementations yields:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">microbenchmark(</span><br><span class="line">  gibbs_r(100, 10),</span><br><span class="line">  gibbs_cpp(100, 10)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="R-vectorisation-vs-C-vectorisation"><a href="#R-vectorisation-vs-C-vectorisation" class="headerlink" title="R vectorisation vs. C++ vectorisation"></a>R vectorisation vs. C++ vectorisation</h3><!-- FIXME: needs more context? -->
<p>This example is adapted from <a href="http://www.babelgraph.org/wp/?p=358" target="_blank" rel="external">âRcpp is smoking fast for agent-based models in data framesâ</a>. The challenge is to predict a model response from three inputs. The basic R version of the predictor looks like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vacc1a &lt;- function(age, female, ily) &#123;</span><br><span class="line">  p &lt;- 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily</span><br><span class="line">  p &lt;- p * if (female) 1.25 else 0.75</span><br><span class="line">  p &lt;- max(0, p)</span><br><span class="line">  p &lt;- min(1, p)</span><br><span class="line">  p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We want to be able to apply this function to many inputs, so we might write a vector-input version using a for loop.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vacc1 &lt;- function(age, female, ily) &#123;</span><br><span class="line">  n &lt;- length(age)</span><br><span class="line">  out &lt;- numeric(n)</span><br><span class="line">  for (i in seq_len(n)) &#123;</span><br><span class="line">    out[i] &lt;- vacc1a(age[i], female[i], ily[i])</span><br><span class="line">  &#125;</span><br><span class="line">  out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If youâre familiar with R, youâll have a gut feeling that this will be slow, and indeed it is. There are two ways we could attack this problem. If you have a good R vocabulary, you might immediately see how to vectorise the function (using <code>ifelse()</code>, <code>pmin()</code>, and <code>pmax()</code>). Alternatively, we could rewrite <code>vacc1a()</code> and <code>vacc1()</code> in C++, using our knowledge that loops and function calls have much lower overhead in C++.</p>
<p>Either approach is fairly straightforward. In R:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vacc2 &lt;- function(age, female, ily) &#123;</span><br><span class="line">  p &lt;- 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily</span><br><span class="line">  p &lt;- p * ifelse(female, 1.25, 0.75)</span><br><span class="line">  p &lt;- pmax(0, p)</span><br><span class="line">  p &lt;- pmin(1, p)</span><br><span class="line">  p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(If youâve worked R a lot you might recognise some potential bottlenecks in this code: <code>ifelse</code>, <code>pmin</code>, and <code>pmax</code> are known to be slow, and could be replaced with <code>p + 0.75 + 0.5 * female</code>, <code>p[p &lt; 0] &lt;- 0</code>, <code>p[p &gt; 1] &lt;- 1</code>.  You might want to try timing those variations yourself.)</p>
<p>Or in C++:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Rcpp.h&gt;</span><br><span class="line">using namespace Rcpp;</span><br><span class="line"></span><br><span class="line">double vacc3a(double age, bool female, bool ily)&#123;</span><br><span class="line">  double p = 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily;</span><br><span class="line">  p = p * (female ? 1.25 : 0.75);</span><br><span class="line">  p = std::max(p, 0.0);</span><br><span class="line">  p = std::min(p, 1.0);</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// [[Rcpp::export]]</span><br><span class="line">NumericVector vacc3(NumericVector age, LogicalVector female,</span><br><span class="line">                    LogicalVector ily) &#123;</span><br><span class="line">  int n = age.size();</span><br><span class="line">  NumericVector out(n);</span><br><span class="line"></span><br><span class="line">  for(int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    out[i] = vacc3a(age[i], female[i], ily[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We next generate some sample data, and check that all three versions return the same values:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n &lt;- 1000</span><br><span class="line">age &lt;- rnorm(n, mean = 50, sd = 10)</span><br><span class="line">female &lt;- sample(c(T, F), n, rep = TRUE)</span><br><span class="line">ily &lt;- sample(c(T, F), n, prob = c(0.8, 0.2), rep = TRUE)</span><br><span class="line"></span><br><span class="line">stopifnot(</span><br><span class="line">  all.equal(vacc1(age, female, ily), vacc2(age, female, ily)),</span><br><span class="line">  all.equal(vacc1(age, female, ily), vacc3(age, female, ily))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>The original blog post forgot to do this, and introduced a bug in the C++ version: it used <code>0.004</code> instead of <code>0.04</code>.  Finally, we can benchmark our three approaches:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">microbenchmark(</span><br><span class="line">  vacc1 = vacc1(age, female, ily),</span><br><span class="line">  vacc2 = vacc2(age, female, ily),</span><br><span class="line">  vacc3 = vacc3(age, female, ily)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Not surprisingly, our original approach with loops is very slow.  Vectorising in R gives a huge speedup, and we can eke out even more performance (~10x) with the C++ loop. I was a little surprised that the C++ was so much faster, but it is because the R version has to create 11 vectors to store intermediate results, where the C++ code only needs to create 1.</p>
<h2 id="Using-Rcpp-in-a-package"><a href="#Using-Rcpp-in-a-package" class="headerlink" title="Using Rcpp in a package"></a><a href="id=&quot;rcpp-package&quot;">Using Rcpp in a package</a></h2><p>The same C++ code that is used with <code>sourceCpp()</code> can also be bundled into a package. There are several benefits of moving code from a stand-alone C++ source file to a package:</p>
<ol>
<li>Your code can be made available to users without C++ development tools.</li>
<li>Multiple source files and their dependencies are handled automatically by   the R package build system.</li>
<li>Packages provide additional infrastructure for testing, documentation, and   consistency.</li>
</ol>
<p>To add <code>Rcpp</code> to an existing package, you put your C++ files in the <code>src/</code> directory and modify/create the following configuration files:</p>
<ul>
<li><p>In <code>DESCRIPTION</code> add</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkingTo: Rcpp</span><br><span class="line">Imports: Rcpp</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make sure your <code>NAMESPACE</code> includes:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useDynLib(mypackage)</span><br><span class="line">importFrom(Rcpp, sourceCpp)</span><br></pre></td></tr></table></figure>
<p>  We need to import something (anything) from Rcpp so that internal Rcpp code    is properly loaded. This is a bug in R and hopefully will be fixed in the    future.</p>
</li>
</ul>
<p>To generate a new Rcpp package that includes a simple âhello worldâ function you can use <code>Rcpp.package.skeleton()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rcpp.package.skeleton(&quot;NewPackage&quot;, attributes = TRUE)</span><br></pre></td></tr></table></figure>
<p>To generate a package based on C++ files that youâve been using with <code>sourceCpp()</code>, use the <code>cpp_files</code> parameter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rcpp.package.skeleton(&quot;NewPackage&quot;, example_code = FALSE,</span><br><span class="line">                      cpp_files = c(&quot;convolve.cpp&quot;))</span><br></pre></td></tr></table></figure>
<p>Before building the packge, youâll need to run <code>Rcpp::compileAttributes()</code>. This function scans the C++ files for <code>Rcpp::export</code> attributes and generates the code required to make the functions available in R. Re-run <code>compileAttributes()</code> whenever functions are added, removed, or have their signatures changed. This is done automatically by the devtools package and by Rstudio.</p>
<p>For more details see the Rcpp package vignette, <code>vignette(&quot;Rcpp-package&quot;)</code>.</p>
<h2 id="Learning-more"><a href="#Learning-more" class="headerlink" title="Learning more"></a><a href="id=&quot;rcpp-more&quot;">Learning more</a></h2><p>This chapter has only touched on a small part of Rcpp, giving you the basic tools to rewrite poorly performing R code in C++. The <a href="http://www.rcpp.org/book" target="_blank" rel="external">Rcpp book</a> is the best reference to learn more about Rcpp. As noted, Rcpp has many other capabilities that make it easy to interface R to existing C++ code, including:</p>
<ul>
<li>Additional features of attributes including specifying default arguments,  linking in external C++ dependencies, and exporting C++ interfaces from  packages. These features and more are covered in the Rcpp attributes vignette,  <code>vignette(&quot;Rcpp-attributes&quot;)</code>.</li>
<li>Automatically creating wrappers between C++ data structures and R data  structures, including mapping C++ classes to reference classes. A good  introduction to this topic is Rcpp modules vignette,  <code>vignette(&quot;Rcpp-modules&quot;)</code></li>
<li>The Rcpp quick reference guide, <code>vignette(&quot;Rcpp-quickref&quot;)</code>, contains a useful  summary of Rcpp classes and common programming idioms.</li>
</ul>
<p>I strongly recommend keeping an eye on the <a href="http://www.rcpp.org" target="_blank" rel="external">Rcpp homepage</a> and <a href="http://dirk.eddelbuettel.com/code/rcpp.html" target="_blank" rel="external">Dirkâs Rcpp page</a> as well as signing up for the <a href="http://lists.r-forge.r-project.org/cgi-bin/mailman/listinfo/rcpp-devel" target="_blank" rel="external">Rcpp mailing list</a>. Rcpp is still under active development, and is getting better with every release.</p>
<p>Other resources Iâve found helpful in learning C++ are:</p>
<ul>
<li><a href="http://amzn.com/0321334876?tag=devtools-20" target="_blank" rel="external"><em>Effective C++</em></a> and  <a href="http://amzn.com/0201749629?tag=devtools-20" target="_blank" rel="external"><em>Effective STL</em></a> by Scott Meyers.</li>
<li><a href="http://www.icce.rug.nl/documents/cplusplus/cplusplus.html" target="_blank" rel="external"><em>C++ Annotations</em></a>,  aimed at âknowledgeable users of C (or any other language using a C-like  grammar, like Perl or Java) who would like to know more about, or make the  transition to, C++â.</li>
<li><a href="http://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/" target="_blank" rel="external"><em>Algorithm Libraries</em></a>,  which provides a more technical, but still concise, description of  important STL concepts. (Follow the links under notes).</li>
</ul>
<p>Writing performance code may also require you to rethink your basic approach: a solid understanding of basic data structures and algorithms is very helpful here. Thatâs beyond the scope of this book, but Iâd suggest the <a href="http://amzn.com/0387948600?tag=devtools-20" target="_blank" rel="external"><em>Algorithm Design Manual</em></a>, MITâs <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/" target="_blank" rel="external"><em>Introduction to Algorithms</em></a>, <em>Algorithms</em> by Robert Sedgewick and Kevin Wayne which has a free <a href="http://algs4.cs.princeton.edu/home/" target="_blank" rel="external">online textbook</a> and a matching <a href="https://www.coursera.org/course/algs4partI" target="_blank" rel="external">coursera course</a>.</p>
<h2 id="Acknowledgments-1"><a href="#Acknowledgments-1" class="headerlink" title="Acknowledgments"></a>Acknowledgments</h2><p>Iâd like to thank the Rcpp-mailing list for many helpful conversations, particularly Romain Francois and Dirk Eddelbuettel who have not only provided detailed answers to many of my questions, but have been incredibly responsive at improving Rcpp. This chapter would not have been possible without JJ Allaire; he encouraged me to learn C++ and then answered many of my dumb questions along the way.</p>
<hr>
<h1 id="Râs-C-interface"><a href="#Râs-C-interface" class="headerlink" title="Râs C interface"></a><a href="id=&quot;c-api&quot;">Râs C interface</a></h1><p>Reading Râs source code is an extremely powerful technique for improving your programming skills. However, many base R functions, and many functions in older packages, are written in C. Itâs useful to be able to figure out how those functions work, so this chapter will introduce you to Râs C API. Youâll need some basic C knowledge, which you can get from a standard C text (e.g., <a href="http://amzn.com/0131101633?tag=devtools-20" target="_blank" rel="external"><em>The C Programming Language</em></a> by Kernigan and Ritchie), or from <a href="#rcpp">Rcpp</a>. Youâll need a little patience, but it is possible to read Râs C source code, and you will learn a lot doing it.</p>
<p>The contents of this chapter draw heavily from Section 5 (âSystem and foreign language interfacesâ) of <a href="http://cran.r-project.org/doc/manuals/R-exts.html" target="_blank" rel="external">Writing R extensions</a>, but focus on best practices and modern tools. This means it does not cover the old <code>.C</code> interface, the old API defined in <code>Rdefines.h</code>, or rarely used language features. To see Râs complete C API, look at the header file <code>Rinternals.h</code>. Itâs easiest to find and display this file from within R:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rinternals &lt;- file.path(R.home(&quot;include&quot;), &quot;Rinternals.h&quot;)</span><br><span class="line">file.show(rinternals)</span><br></pre></td></tr></table></figure>
<p>All functions are defined with either the prefix <code>Rf_</code> or <code>R_</code> but are exported without it (unless <code>#define R_NO_REMAP</code> has been used).</p>
<p>I do not recommend using C for writing new high-performance code. Instead write C++ with Rcpp. The Rcpp API protects you from many of the historical idiosyncracies of the R API, takes care of memory management for you, and provides many useful helper methods.</p>
<h5 id="Outline-14"><a href="#Outline-14" class="headerlink" title="Outline"></a>Outline</h5><ul>
<li><a href="#calling-c">Calling C</a> shows the basics of creating and calling C functions  with the inline package.</li>
<li><a href="#c-data-structures">C data structures</a> shows how to translate data  structure names from R to C.</li>
<li><a href="#c-vectors">Creating and modifying vectors</a> teaches you how to create,  modify, and coerce vectors in C.</li>
<li><a href="#c-pairlists">Pairlists</a> shows you how to work with pairlists. You need  to know this because the distinction between pairlists and list is more  important in C than R.</li>
<li><a href="#c-input-validation">Input validation</a> talks about the importance of  input validation so that your C function doesnât crash R.</li>
<li><a href="#c-find-source">Finding the C source for a function</a> concludes the  chapter by showing you how to find the C source code for internal and  primitive R functions.</li>
</ul>
<h5 id="Prerequisites-10"><a href="#Prerequisites-10" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><p>To understand existing C code, itâs useful to generate simple examples of your own that you can experiment with. To that end, all examples in this chapter use the <code>inline</code> package, which makes it extremely easy to compile and link C code to your current R session. Get it by running <code>install.packages(&quot;inline&quot;)</code>. To easily find the C code associated with internal and primitive functions, youâll need a function from pryr. Get the package with <code>install.packages(&quot;pryr&quot;)</code>.</p>
<p>Youâll also need a C compiler. Windows users can use <a href="http://cran.r-project.org/bin/windows/Rtools/" target="_blank" rel="external">Rtools</a>. Mac users will need the <a href="http://developer.apple.com/" target="_blank" rel="external">Xcode command line tools</a>. Most Linux distributions will come with the necessary compilers.</p>
<p>In Windows, itâs necessary that the Rtools executables directory (typically <code>C:\Rtools\bin</code>) and the C compiler executables directory (typically <code>C:\Rtools\gcc-4.6.3\bin</code>) are included in the Windows <code>PATH</code> environment variable. You may need to reboot Windows before R can recognise these values.</p>
<h2 id="Calling-C-functions-from-R"><a href="#Calling-C-functions-from-R" class="headerlink" title="Calling C functions from R"></a><a href="id=&quot;calling-c&quot;">Calling C functions from R</a></h2><p>Generally, calling a C function from R requires two pieces: a C function and an R wrapper function that uses <code>.Call()</code>. The simple function below adds two numbers together and illustrates some of the complexities of coding in C:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In C ----------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;R.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Rinternals.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">SEXP <span class="title">add</span><span class="params">(SEXP a, SEXP b)</span> </span>&#123;</span><br><span class="line">  SEXP result = PROTECT(allocVector(REALSXP, <span class="number">1</span>));</span><br><span class="line">  REAL(result)[<span class="number">0</span>] = asReal(a) + asReal(b);</span><br><span class="line">  UNPROTECT(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># In R ----------------------------------------</span><br><span class="line">add &lt;- function(a, b) &#123;</span><br><span class="line">  .Call(&quot;add&quot;, a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(An alternative to using <code>.Call</code> is to use <code>.External</code>.  It is used almost identically, except that the C function will receive a single argument containing a <code>LISTSXP</code>, a pairlist from which the arguments can be extracted. This makes it possible to write functions that take a variable number of arguments. However, itâs not commonly used in base R and <code>inline</code> does not currently support <code>.External</code> functions so I donât discuss it further in this chapter.)</p>
<p>In this chapter weâll produce the two pieces in one step by using the <code>inline</code> package. This allows us to write:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add &lt;- cfunction(c(a = &quot;integer&quot;, b = &quot;integer&quot;), &quot;</span><br><span class="line">  SEXP result = PROTECT(allocVector(REALSXP, 1));</span><br><span class="line">  REAL(result)[0] = asReal(a) + asReal(b);</span><br><span class="line">  UNPROTECT(1);</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&quot;)</span><br><span class="line">add(1, 5)</span><br></pre></td></tr></table></figure>
<p>Before we begin reading and writing C code, we need to know a little about the basic data structures.</p>
<h2 id="C-data-structures"><a href="#C-data-structures" class="headerlink" title="C data structures"></a><a href="id=&quot;c-data-structures&quot;">C data structures</a></h2><p>At the C-level, all R objects are stored in a common datatype, the <code>SEXP</code>, or S-expression. All R objects are S-expressions so every C function that you create must return a <code>SEXP</code> as output and take <code>SEXP</code>s as inputs. (Technically, this is a pointer to a structure with typedef <code>SEXPREC</code>.) A <code>SEXP</code> is a variant type, with subtypes for all Râs data structures. The most important types are:</p>
<ul>
<li><code>REALSXP</code>: numeric vector</li>
<li><code>INTSXP</code>: integer vector</li>
<li><code>LGLSXP</code>: logical vector</li>
<li><code>STRSXP</code>: character vector</li>
<li><code>VECSXP</code>: list</li>
<li><code>CLOSXP</code>: function (closure)</li>
<li><code>ENVSXP</code>: environment</li>
</ul>
<p><strong>Beware:</strong> In C, lists are called <code>VECSXP</code>s not <code>LISTSXP</code>s. This is because early implementations of lists were Lisp-like linked lists, which are now known as âpairlistsâ.</p>
<p>Character vectors are a little more complicated than the other atomic vectors. A <code>STRSXP</code>s contains a vector of <code>CHARSXP</code>s, where each <code>CHARSXP</code> points to C-style string stored in a global pool. This design allows individual <code>CHARSXP</code>âs to be shared between multiple character vectors, reducing memory usage. See <a href="#object-size">object size</a> for more details.</p>
<p>There are also <code>SEXP</code>s for less common object types:</p>
<ul>
<li><code>CPLXSXP</code>: complex vectors</li>
<li><code>LISTSXP</code>: âpairâ lists. At the R level, you only need to care about the distinction lists and pairlists for function arguments, but internally they are used in many more places</li>
<li><code>DOTSXP</code>: ââ¦â</li>
<li><code>SYMSXP</code>: names/symbols</li>
<li><code>NILSXP</code>: <code>NULL</code></li>
</ul>
<p>And <code>SEXP</code>s for internal objects, objects that are usually only created and used by C functions, not R functions:</p>
<ul>
<li><code>LANGSXP</code>: language constructs</li>
<li><code>CHARSXP</code>: âscalarâ strings</li>
<li><code>PROMSXP</code>: promises, lazily evaluated function arguments</li>
<li><code>EXPRSXP</code>: expressions</li>
</ul>
<p>Thereâs no built-in R function to easily access these names, but pryr provides <code>sexp_type()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library(pryr)</span><br><span class="line"></span><br><span class="line">sexp_type(10L)</span><br><span class="line">sexp_type(&quot;a&quot;)</span><br><span class="line">sexp_type(T)</span><br><span class="line">sexp_type(list(a = 1))</span><br><span class="line">sexp_type(pairlist(a = 1))</span><br></pre></td></tr></table></figure>
<h2 id="Creating-and-modifying-vectors"><a href="#Creating-and-modifying-vectors" class="headerlink" title="Creating and modifying vectors"></a><a href="id=&quot;c-vectors&quot;">Creating and modifying vectors</a></h2><p>At the heart of every C function are conversions between R data structures and C data structures. Inputs and output will always be R data structures (<code>SEXP</code>s) and you will need to convert them to C data structures in order to do any work. This section focusses on vectors because theyâre the type of object youâre most likely to work with.</p>
<p>An additional complication is the garbage collector: if you donât protect every R object you create, the garbage collector will think they are unused and delete them.</p>
<h3 id="Creating-vectors-and-garbage-collection"><a href="#Creating-vectors-and-garbage-collection" class="headerlink" title="Creating vectors and garbage collection"></a>Creating vectors and garbage collection</h3><p>The simplest way to create a new R-level object is to use <code>allocVector()</code>. It takes two arguments, the type of <code>SEXP</code> (or <code>SEXPTYPE</code>) to create, and the length of the vector. The following code creates a three element list containing a logical vector, a numeric vector, and an integer vector, all of length four:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dummy &lt;- cfunction(body = &apos;</span><br><span class="line">  SEXP dbls = PROTECT(allocVector(REALSXP, 4));</span><br><span class="line">  SEXP lgls = PROTECT(allocVector(LGLSXP, 4));</span><br><span class="line">  SEXP ints = PROTECT(allocVector(INTSXP, 4));</span><br><span class="line"></span><br><span class="line">  SEXP vec = PROTECT(allocVector(VECSXP, 3));</span><br><span class="line">  SET_VECTOR_ELT(vec, 0, dbls);</span><br><span class="line">  SET_VECTOR_ELT(vec, 1, lgls);</span><br><span class="line">  SET_VECTOR_ELT(vec, 2, ints);</span><br><span class="line"></span><br><span class="line">  UNPROTECT(4);</span><br><span class="line">  return vec;</span><br><span class="line">&apos;)</span><br><span class="line">dummy()</span><br></pre></td></tr></table></figure>
<p>You might wonder what all the <code>PROTECT()</code> calls do. They tell R that the object is in use and shouldnât be deleted if the garbage collector is activated. (We donât need to protect objects that R already knows weâre using, like function arguments.)</p>
<p>You also need to make sure that every protected object is unprotected. <code>UNPROTECT()</code> takes a single integer argument, <code>n</code>, and unprotects the last n objects that were protected. The number of protects and unprotects must match. If not, R will warn about a âstack imbalance in .Callâ.  Other specialised forms of protection are needed in some circumstances:</p>
<ul>
<li><p><code>UNPROTECT_PTR()</code> unprotects the object pointed to by the <code>SEXP</code>s.</p>
</li>
<li><p><code>PROTECT_WITH_INDEX()</code> saves an index of the protection location that can<br>be used to replace the protected value using <code>REPROTECT()</code>.</p>
</li>
</ul>
<p>Consult the R externals section on <a href="http://cran.r-project.org/doc/manuals/R-exts.html#Garbage-Collection" target="_blank" rel="external">garbage collection</a> for more details.</p>
<p>Properly protecting the R objects you allocate is extremely important! Improper protection leads to difficulty diagnosing errors, typically segfaults, but other corruption is possible as well. In general, if you allocate a new R object, you must <code>PROTECT</code> it.</p>
<p>If you run <code>dummy()</code> a few times, youâll notice the output varies. This is because <code>allocVector()</code> assigns memory to each output, but it doesnât clean it out first. For real functions, you may want to loop through each element in the vector and set it to a constant. The most efficient way to do that is to use <code>memset()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zeroes &lt;- cfunction(c(n_ = &quot;integer&quot;), &apos;</span><br><span class="line">  int n = asInteger(n_);</span><br><span class="line"></span><br><span class="line">  SEXP out = PROTECT(allocVector(INTSXP, n));</span><br><span class="line">  memset(INTEGER(out), 0, n * sizeof(int));</span><br><span class="line">  UNPROTECT(1);</span><br><span class="line"></span><br><span class="line">  return out;</span><br><span class="line">&apos;)</span><br><span class="line">zeroes(10);</span><br></pre></td></tr></table></figure>
<h3 id="Missing-and-non-finite-values"><a href="#Missing-and-non-finite-values" class="headerlink" title="Missing and non-finite values"></a>Missing and non-finite values</h3><p>Each atomic vector has a special constant for getting or setting missing values:</p>
<ul>
<li><code>INTSXP</code>: <code>NA_INTEGER</code></li>
<li><code>LGLSXP</code>: <code>NA_LOGICAL</code></li>
<li><code>STRSXP</code>: <code>NA_STRING</code></li>
</ul>
<p>Missing values are somewhat more complicated for <code>REALSXP</code> because there is an existing protocol for missing values defined by the floating point standard (<a href="http://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" rel="external">IEEE 754</a>). In doubles, an <code>NA</code> is <code>NaN</code> with a special bit pattern (the lowest word is 1954, the year Ross Ihaka was born), and there are other special values for positive and negative infinity. Use <code>ISNA()</code>, <code>ISNAN()</code>, and <code>!R_FINITE()</code> macros to check for missing, NaN, or non-finite values. Use the constants <code>NA_REAL</code>, <code>R_NaN</code>, <code>R_PosInf</code>, and <code>R_NegInf</code> to set those values.</p>
<p>We can use this knowledge to make a simple version of <code>is.NA()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">is_na &lt;- cfunction(c(x = &quot;ANY&quot;), &apos;</span><br><span class="line">  int n = length(x);</span><br><span class="line"></span><br><span class="line">  SEXP out = PROTECT(allocVector(LGLSXP, n));</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    switch(TYPEOF(x)) &#123;</span><br><span class="line">      case LGLSXP:</span><br><span class="line">        LOGICAL(out)[i] = (LOGICAL(x)[i] == NA_LOGICAL);</span><br><span class="line">        break;</span><br><span class="line">      case INTSXP:</span><br><span class="line">        LOGICAL(out)[i] = (INTEGER(x)[i] == NA_INTEGER);</span><br><span class="line">        break;</span><br><span class="line">      case REALSXP:</span><br><span class="line">        LOGICAL(out)[i] = ISNA(REAL(x)[i]);</span><br><span class="line">        break;</span><br><span class="line">      case STRSXP:</span><br><span class="line">        LOGICAL(out)[i] = (STRING_ELT(x, i) == NA_STRING);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        LOGICAL(out)[i] = NA_LOGICAL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  UNPROTECT(1);</span><br><span class="line"></span><br><span class="line">  return out;</span><br><span class="line">&apos;)</span><br><span class="line">is_na(c(NA, 1L))</span><br><span class="line">is_na(c(NA, 1))</span><br><span class="line">is_na(c(NA, &quot;a&quot;))</span><br><span class="line">is_na(c(NA, TRUE))</span><br></pre></td></tr></table></figure>
<p>Note that <code>base::is.na()</code> returns <code>TRUE</code> for both <code>NA</code> and <code>NaN</code>s in a numeric vector, as opposed to the C <code>ISNA()</code> macro, which returns <code>TRUE</code> only for <code>NA_REAL</code>s.</p>
<h3 id="Accessing-vector-data"><a href="#Accessing-vector-data" class="headerlink" title="Accessing vector data"></a>Accessing vector data</h3><p>There is a helper function for each atomic vector that allows you to access the C array which stores the data in a vector. Use <code>REAL()</code>, <code>INTEGER()</code>, <code>LOGICAL()</code>, <code>COMPLEX()</code>, and <code>RAW()</code> to access the C array inside numeric, integer, logical, complex, and raw vectors. The following example shows how to use <code>REAL()</code> to inspect and modify a numeric vector:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add_one &lt;- cfunction(c(x = &quot;numeric&quot;), &quot;</span><br><span class="line">  int n = length(x);</span><br><span class="line">  SEXP out = PROTECT(allocVector(REALSXP, n));</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    REAL(out)[i] = REAL(x)[i] + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  UNPROTECT(1);</span><br><span class="line"></span><br><span class="line">  return out;</span><br><span class="line">&quot;)</span><br><span class="line">add_one(as.numeric(1:10))</span><br></pre></td></tr></table></figure>
<p>When working with longer vectors, thereâs a performance advantage to using the helper function once and saving the result in a pointer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">add_two &lt;- cfunction(c(x = &quot;numeric&quot;), &quot;</span><br><span class="line">  int n = length(x);</span><br><span class="line">  double *px, *pout;</span><br><span class="line"></span><br><span class="line">  SEXP out = PROTECT(allocVector(REALSXP, n));</span><br><span class="line"></span><br><span class="line">  px = REAL(x);</span><br><span class="line">  pout = REAL(out);</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    pout[i] = px[i] + 2;</span><br><span class="line">  &#125;</span><br><span class="line">  UNPROTECT(1);</span><br><span class="line"></span><br><span class="line">  return out;</span><br><span class="line">&quot;)</span><br><span class="line">add_two(as.numeric(1:10))</span><br><span class="line"></span><br><span class="line">x &lt;- as.numeric(1:1e6)</span><br><span class="line">microbenchmark(</span><br><span class="line">  add_one(x),</span><br><span class="line">  add_two(x)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>On my computer, <code>add_two()</code> is about twice as fast as <code>add_one()</code> for a million element vector. This is a common idiom in base R.</p>
<h3 id="Character-vectors-and-lists"><a href="#Character-vectors-and-lists" class="headerlink" title="Character vectors and lists"></a>Character vectors and lists</h3><p>Strings and lists are more complicated because the individual elements of a vector are <code>SEXP</code>s, not basic C data structures. Each element of a <code>STRSXP</code> is a <code>CHARSXP</code>s, an immutable object that contains a pointer to C string stored in a global pool. Use <code>STRING_ELT(x, i)</code> to extract the <code>CHARSXP</code>, and <code>CHAR(STRING_ELT(x, i))</code> to get the actual <code>const char*</code> string. Set values with <code>SET_STRING_ELT(x, i, value)</code>. Use <code>mkChar()</code> to turn a C string into a <code>CHARSXP</code> and <code>mkString()</code> to turn a C string into a <code>STRSXP</code>. Use <code>mkChar()</code> to create strings to insert in an existing vector, use <code>mkString()</code> to create a new (length 1) vector.</p>
<p>The following function shows how to make a character vector containing known strings:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abc &lt;- cfunction(NULL, &apos;</span><br><span class="line">  SEXP out = PROTECT(allocVector(STRSXP, 3));</span><br><span class="line"></span><br><span class="line">  SET_STRING_ELT(out, 0, mkChar(&quot;a&quot;));</span><br><span class="line">  SET_STRING_ELT(out, 1, mkChar(&quot;b&quot;));</span><br><span class="line">  SET_STRING_ELT(out, 2, mkChar(&quot;c&quot;));</span><br><span class="line"></span><br><span class="line">  UNPROTECT(1);</span><br><span class="line"></span><br><span class="line">  return out;</span><br><span class="line">&apos;)</span><br><span class="line">abc()</span><br></pre></td></tr></table></figure>
<p>Things are a little harder if you want to modify the strings in the vector because you need to know a lot about string manipulation in C (which is hard, and harder to do right). For any problem that involves any kind of string modification, youâre better off using Rcpp.</p>
<p>The elements of a list can be any other <code>SEXP</code>, which generally makes them hard to work with in C (youâll need lots of <code>switch</code> statements to deal with the possibilities). The accessor functions for lists are <code>VECTOR_ELT(x, i)</code> and <code>SET_VECTOR_ELT(x, i, value)</code>.</p>
<h3 id="Modifying-inputs"><a href="#Modifying-inputs" class="headerlink" title="Modifying inputs"></a>Modifying inputs</h3><p>You must be very careful when modifying function inputs. The following function has some rather unexpected behaviour:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_three &lt;- cfunction(c(x = &quot;numeric&quot;), &apos;</span><br><span class="line">  REAL(x)[0] = REAL(x)[0] + 3;</span><br><span class="line">  return x;</span><br><span class="line">&apos;)</span><br><span class="line">x &lt;- 1</span><br><span class="line">y &lt;- x</span><br><span class="line">add_three(x)</span><br><span class="line">x</span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<p>Not only has it modified the value of <code>x</code>, it has also modified <code>y</code>! This happens because of Râs lazy copy-on-modify semantics. To avoid problems like this, always <code>duplicate()</code> inputs before modifying them:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add_four &lt;- cfunction(c(x = &quot;numeric&quot;), &apos;</span><br><span class="line">  SEXP x_copy = PROTECT(duplicate(x));</span><br><span class="line">  REAL(x_copy)[0] = REAL(x_copy)[0] + 4;</span><br><span class="line">  UNPROTECT(1);</span><br><span class="line">  return x_copy;</span><br><span class="line">&apos;)</span><br><span class="line">x &lt;- 1</span><br><span class="line">y &lt;- x</span><br><span class="line">add_four(x)</span><br><span class="line">x</span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<p>If youâre working with lists, use <code>shallow_duplicate()</code> to make a shallow copy; <code>duplicate()</code> will also copy every element in the list.</p>
<h3 id="Coercing-scalars"><a href="#Coercing-scalars" class="headerlink" title="Coercing scalars"></a>Coercing scalars</h3><p>There are a few helper functions that turn length one R vectors into C scalars:</p>
<ul>
<li><code>asLogical(x): LGLSXP -&gt; int</code></li>
<li><code>asInteger(x): INTSXP -&gt; int</code></li>
<li><code>asReal(x): REALSXP -&gt; double</code></li>
<li><code>CHAR(asChar(x)): STRSXP -&gt; const char*</code></li>
</ul>
<p>And helpers to go in the opposite direction:</p>
<ul>
<li><code>ScalarLogical(x): int -&gt; LGLSXP</code></li>
<li><code>ScalarInteger(x): int -&gt; INTSXP</code></li>
<li><code>ScalarReal(x): double -&gt; REALSXP</code></li>
<li><code>mkString(x): const char* -&gt; STRSXP</code></li>
</ul>
<p>These all create R-level objects, so they need to be <code>PROTECT()</code>ed.</p>
<h3 id="Long-vectors"><a href="#Long-vectors" class="headerlink" title="Long vectors"></a>Long vectors</h3><p>As of R 3.0.0, R vectors can have length greater than $2 ^ 31 -  1$. This means that vector lengths can no longer be reliably stored in an <code>int</code> and if you want your code to work with long vectors, you canât write code like <code>int n = length(x)</code>. Instead use the <code>R_xlen_t</code> type and the <code>xlength()</code> function, and write <code>R_xlen_t n = xlength(x)</code>.</p>
<h2 id="Pairlists-1"><a href="#Pairlists-1" class="headerlink" title="Pairlists"></a><a href="id=&quot;c-pairlists&quot;">Pairlists</a></h2><p>In R code, there are only a few instances when you need to care about the difference between a pairlist and a list (as described in <a href="#pairlists">Pairlists</a>). In C, pairlists play much more important role because they are used for calls, unevaluated arguments, attributes, and in <code>...</code>. In C, lists and pairlists differ primarily in how you access and name elements.</p>
<p>Unlike lists (<code>VECSXP</code>s), pairlists (<code>LISTSXP</code>s) have no way to index into an arbitrary location. Instead, R provides a set of helper functions that navigate along a linked list. The basic helpers are <code>CAR()</code>, which extracts the first element of the list, and <code>CDR()</code>, which extracts the rest of the list. These can be composed to get <code>CAAR()</code>, <code>CDAR()</code>, <code>CADDR()</code>, <code>CADDDR()</code>, and so on. Corresponding to the getters, R provides setters <code>SETCAR()</code>, <code>SETCDR()</code>, etc.</p>
<p>The following example shows how <code>CAR()</code> and <code>CDR()</code> can pull out pieces of a quoted function call:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">car &lt;- cfunction(c(x = &quot;ANY&quot;), &apos;return CAR(x);&apos;)</span><br><span class="line">cdr &lt;- cfunction(c(x = &quot;ANY&quot;), &apos;return CDR(x);&apos;)</span><br><span class="line">cadr &lt;- cfunction(c(x = &quot;ANY&quot;), &apos;return CADR(x);&apos;)</span><br><span class="line"></span><br><span class="line">x &lt;- quote(f(a = 1, b = 2))</span><br><span class="line"># The first element</span><br><span class="line">car(x)</span><br><span class="line"># Second and third elements</span><br><span class="line">cdr(x)</span><br><span class="line"># Second element</span><br><span class="line">car(cdr(x))</span><br><span class="line">cadr(x)</span><br></pre></td></tr></table></figure>
<p>Pairlists are always terminated with <code>R_NilValue</code>. To loop over all elements of a pairlist, use this template:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">count &lt;- cfunction(c(x = &quot;ANY&quot;), &apos;</span><br><span class="line">  SEXP el, nxt;</span><br><span class="line">  int i = 0;</span><br><span class="line"></span><br><span class="line">  for(nxt = x; nxt != R_NilValue; el = CAR(nxt), nxt = CDR(nxt)) &#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  return ScalarInteger(i);</span><br><span class="line">&apos;)</span><br><span class="line">count(quote(f(a, b, c)))</span><br><span class="line">count(quote(f()))</span><br></pre></td></tr></table></figure>
<p>You can make new pairlists with <code>CONS()</code> and new calls with <code>LCONS()</code>. Remember to set the last value to <code>R_NilValue</code>. Since these are R objects as well, they are eligible for garbage collection and must be <code>PROTECT</code>ed. In fact, it is unsafe to write code like the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new_call &lt;- cfunction(NULL, &apos;</span><br><span class="line">  return LCONS(install(&quot;+&quot;), LCONS(</span><br><span class="line">    ScalarReal(10), LCONS(</span><br><span class="line">      ScalarReal(5), R_NilValue</span><br><span class="line">    )</span><br><span class="line">  ));</span><br><span class="line">&apos;)</span><br><span class="line">gctorture(TRUE)</span><br><span class="line">new_call()</span><br><span class="line">gctorture(FALSE)</span><br></pre></td></tr></table></figure>
<p>On my machine, I get the result <code>5 + 5</code> â highly unexpected! In fact, to be safe, we must <code>PROTECT</code> each <code>ScalarReal</code> that is generated, as every R object allocation can trigger the garbage collector.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new_call &lt;- cfunction(NULL, &apos;</span><br><span class="line">  SEXP REALSXP_10 = PROTECT(ScalarReal(10));</span><br><span class="line">  SEXP REALSXP_5 = PROTECT(ScalarReal(5));</span><br><span class="line">  SEXP out = PROTECT(LCONS(install(&quot;+&quot;), LCONS(</span><br><span class="line">    REALSXP_10, LCONS(</span><br><span class="line">      REALSXP_5, R_NilValue</span><br><span class="line">    )</span><br><span class="line">  )));</span><br><span class="line">  UNPROTECT(3);</span><br><span class="line">  return out;</span><br><span class="line">&apos;)</span><br><span class="line">gctorture(TRUE)</span><br><span class="line">new_call()</span><br><span class="line">gctorture(FALSE)</span><br></pre></td></tr></table></figure>
<p><code>TAG()</code> and <code>SET_TAG()</code> allow you to get and set the tag (aka name) associated with an element of a pairlist. The tag should be a symbol. To create a symbol (the equivalent of <code>as.symbol()</code> in R), use <code>install()</code>.</p>
<p>Attributes are also pairlists, but come with the helper functions <code>setAttrib()</code> and <code>getAttrib()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set_attr &lt;- cfunction(c(obj = &quot;SEXP&quot;, attr = &quot;SEXP&quot;, value = &quot;SEXP&quot;), &apos;</span><br><span class="line">  const char* attr_s = CHAR(asChar(attr));</span><br><span class="line"></span><br><span class="line">  duplicate(obj);</span><br><span class="line">  setAttrib(obj, install(attr_s), value);</span><br><span class="line">  return obj;</span><br><span class="line">&apos;)</span><br><span class="line">x &lt;- 1:10</span><br><span class="line">set_attr(x, &quot;a&quot;, 1)</span><br></pre></td></tr></table></figure>
<p>(Note that <code>setAttrib()</code> and <code>getAttrib()</code> must do a linear search over the attributes pairlist.)</p>
<p>There are some (confusingly named) shortcuts for common setting operations: <code>classgets()</code>, <code>namesgets()</code>, <code>dimgets()</code>, and <code>dimnamesgets()</code> are the internal versions of the default methods of <code>class&lt;-</code>, <code>names&lt;-</code>, <code>dim&lt;-</code>, and <code>dimnames&lt;-</code>.</p>
<h2 id="Input-validation"><a href="#Input-validation" class="headerlink" title="Input validation"></a><a href="id=&quot;c-input-validation&quot;">Input validation</a></h2><p>If the user provides unexpected input to your function (e.g., a list instead of a numeric vector), itâs very easy to crash R. For this reason, itâs a good idea to write a wrapper function that checks arguments are of the correct type. Itâs usually easier to do this at the R level. For example, going back to our first example of C code, we might rename the C function to <code>add_</code> and write a wrapper around it to check that the inputs are ok:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add_ &lt;- cfunction(signature(a = &quot;integer&quot;, b = &quot;integer&quot;), &quot;</span><br><span class="line">  SEXP result = PROTECT(allocVector(REALSXP, 1));</span><br><span class="line">  REAL(result)[0] = asReal(a) + asReal(b);</span><br><span class="line">  UNPROTECT(1);</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&quot;)</span><br><span class="line">add &lt;- function(a, b) &#123;</span><br><span class="line">  stopifnot(is.numeric(a), is.numeric(b))</span><br><span class="line">  stopifnot(length(a) == 1, length(b) == 1)</span><br><span class="line">  add_(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Alternatively, if we wanted to be more accepting of diverse inputs we could do the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add &lt;- function(a, b) &#123;</span><br><span class="line">  a &lt;- as.numeric(a)</span><br><span class="line">  b &lt;- as.numeric(b)</span><br><span class="line"></span><br><span class="line">  if (length(a) &gt; 1) warning(&quot;Only first element of a used&quot;)</span><br><span class="line">  if (length(b) &gt; 1) warning(&quot;Only first element of b used&quot;)</span><br><span class="line"></span><br><span class="line">  add_(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To coerce objects at the C level, use <code>PROTECT(new = coerceVector(old, SEXPTYPE))</code>. This will return an error if the <code>SEXP</code> can not be converted to the desired type.</p>
<p>To check if an object is of a specified type, you can use <code>TYPEOF</code>, which returns a <code>SEXPTYPE</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">is_numeric &lt;- cfunction(c(&quot;x&quot; = &quot;ANY&quot;), &quot;</span><br><span class="line">  return ScalarLogical(TYPEOF(x) == REALSXP);</span><br><span class="line">&quot;)</span><br><span class="line">is_numeric(7)</span><br><span class="line">is_numeric(&quot;a&quot;)</span><br></pre></td></tr></table></figure>
<p>There are also a number of helper functions which return 0 for FALSE and 1 for TRUE:</p>
<ul>
<li>For atomic vectors: <code>isInteger()</code>, <code>isReal()</code>, <code>isComplex()</code>, <code>isLogical()</code>,  <code>isString()</code>.</li>
<li>For combinations of atomic vectors: <code>isNumeric()</code> (integer, logical, real),  <code>isNumber()</code> (integer, logical, real, complex), <code>isVectorAtomic()</code>  (logical, integer, numeric, complex, string, raw).</li>
<li>For matrices (<code>isMatrix()</code>) and arrays (<code>isArray()</code>).</li>
<li>For more esoteric objects: <code>isEnvironment()</code>, <code>isExpression()</code>, <code>isList()</code> (a pair list), <code>isNewList()</code> (a list), <code>isSymbol()</code>, <code>isNull()</code>, <code>isObject()</code> (S4 objects), <code>isVector()</code> (atomic vectors, lists, expressions).</li>
</ul>
<p>Note that some of these functions behave differently to similarly named R functions with similar names. For example <code>isVector()</code> is true for atomic vectors, lists, and expressions, where <code>is.vector()</code> returns <code>TRUE</code> only if its input has no attributes apart from names.</p>
<h2 id="Finding-the-C-source-code-for-a-function"><a href="#Finding-the-C-source-code-for-a-function" class="headerlink" title="Finding the C source code for a function"></a><a href="id=&quot;c-find-source&quot;">Finding the C source code for a function</a></h2><p>In the base package, R doesnât use <code>.Call()</code>. Instead, it uses two special functions: <code>.Internal()</code> and <code>.Primitive()</code>. Finding the source code for these functions is an arduous task: you first need to look for their C function name in <code>src/main/names.c</code> and then search the R source code. <code>pryr::show_c_source()</code> automates this task using GitHub code search:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tabulate</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pryr::show_c_source(.Internal(tabulate(bin, nbins)))</span><br><span class="line">#&gt; tabulate is implemented by do_tabulate with op = 0</span><br></pre></td></tr></table></figure>
<p>This reveals the following C source code (slightly edited for clarity):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SEXP attribute_hidden <span class="title">do_tabulate</span><span class="params">(SEXP call, SEXP op, SEXP args,</span><br><span class="line">                                  SEXP rho)</span> </span>&#123;</span><br><span class="line">  checkArity(op, args);</span><br><span class="line">  SEXP in = CAR(args), nbin = CADR(args);</span><br><span class="line">  <span class="keyword">if</span> (TYPEOF(in) != INTSXP)  error(<span class="string">"invalid input"</span>);</span><br><span class="line"></span><br><span class="line">  R_xlen_t n = XLENGTH(in);</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> could in principle be a long vector */</span></span><br><span class="line">  <span class="keyword">int</span> nb = asInteger(nbin);</span><br><span class="line">  <span class="keyword">if</span> (nb == NA_INTEGER || nb &lt; <span class="number">0</span>)</span><br><span class="line">    error(_(<span class="string">"invalid '%s' argument"</span>), <span class="string">"nbin"</span>);</span><br><span class="line"></span><br><span class="line">  SEXP ans = allocVector(INTSXP, nb);</span><br><span class="line">  <span class="keyword">int</span> *x = INTEGER(in), *y = INTEGER(ans);</span><br><span class="line">  <span class="built_in">memset</span>(y, <span class="number">0</span>, nb * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(R_xlen_t i = <span class="number">0</span> ; i &lt; n ; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x[i] != NA_INTEGER &amp;&amp; x[i] &gt; <span class="number">0</span> &amp;&amp; x[i] &lt;= nb) &#123;</span><br><span class="line">      y[x[i] - <span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Internal and primitive functions have a somewhat different interface than <code>.Call()</code> functions. They always have four arguments:</p>
<ul>
<li><code>SEXP call</code>: the complete call to the function. <code>CAR(call)</code> gives  the name of the function (as a symbol); <code>CDR(call)</code> gives the arguments.</li>
<li><code>SEXP op</code>: an âoffset pointerâ. This is used when multiple R functions use the  same C function. For example <code>do_logic()</code> implements <code>&amp;</code>, <code>|</code>, and <code>!</code>.  <code>show_c_source()</code> prints this out for you.</li>
<li><code>SEXP args</code>: a pairlist containing the unevaluated arguments to the function.</li>
<li><code>SEXP rho</code>: the environment in which the call was executed.</li>
</ul>
<p>This gives internal functions an incredible amount of flexibility as to how and when the arguments are evaluated. For example, internal S3 generics call <code>DispatchOrEval()</code> which either calls the appropriate S3 method or evaluates all the arguments in place. This flexibility come at a price, because it makes the code harder to understand. However, evaluating the arguments is usually the first step and the rest of the function is straightforward.</p>
<p>The following code shows <code>do_tabulate()</code> converted into standard a <code>.Call()</code> interface:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">tabulate2 &lt;- cfunction(c(bin = &quot;SEXP&quot;, nbins = &quot;SEXP&quot;), &apos;</span><br><span class="line">  if (TYPEOF(bin) != INTSXP)  error(&quot;invalid input&quot;);</span><br><span class="line"></span><br><span class="line">  R_xlen_t n = XLENGTH(bin);</span><br><span class="line">  /* FIXME: could in principle be a long vector */</span><br><span class="line">  int nb = asInteger(nbins);</span><br><span class="line">  if (nb == NA_INTEGER || nb &lt; 0)</span><br><span class="line">    error(&quot;invalid \&apos;%s\&apos; argument&quot;, &quot;nbin&quot;);</span><br><span class="line"></span><br><span class="line">  SEXP ans = allocVector(INTSXP, nb);</span><br><span class="line">  int *x = INTEGER(bin), *y = INTEGER(ans);</span><br><span class="line">  memset(y, 0, nb * sizeof(int));</span><br><span class="line">  for(R_xlen_t i = 0 ; i &lt; n ; i++) &#123;</span><br><span class="line">    if (x[i] != NA_INTEGER &amp;&amp; x[i] &gt; 0 &amp;&amp; x[i] &lt;= nb) &#123;</span><br><span class="line">      y[x[i] - 1]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return ans;</span><br><span class="line">&apos;)</span><br><span class="line">tabulate2(c(1L, 1L, 1L, 2L, 2L), 3)</span><br></pre></td></tr></table></figure>
<p>To get this to compile, I also removed the call to <code>_()</code> which is an internal R function used to translate error messages between different languages.</p>
<p>The final version below moves more of the coercion logic into an accompanying R function, and does some minor restructuring to make the code a little easier to understand. I also added a <code>PROTECT()</code>; this is probably missing in the original because the author knew that it would be safe.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">tabulate_ &lt;- cfunction(c(bin = &quot;SEXP&quot;, nbins = &quot;SEXP&quot;), &apos;</span><br><span class="line">  int nb = asInteger(nbins);</span><br><span class="line"></span><br><span class="line">  // Allocate vector for output - assumes that there are</span><br><span class="line">  // less than 2^32 bins, and that each bin has less than</span><br><span class="line">  // 2^32 elements in it.</span><br><span class="line">  SEXP out = PROTECT(allocVector(INTSXP, nb));</span><br><span class="line">  int *pbin = INTEGER(bin), *pout = INTEGER(out);</span><br><span class="line">  memset(pout, 0, nb * sizeof(int));</span><br><span class="line"></span><br><span class="line">  R_xlen_t n = xlength(bin);</span><br><span class="line">  for(R_xlen_t i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    int val = pbin[i];</span><br><span class="line">    if (val != NA_INTEGER &amp;&amp; val &gt; 0 &amp;&amp; val &lt;= nb) &#123;</span><br><span class="line">      pout[val - 1]++; // C is zero-indexed</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  UNPROTECT(1);</span><br><span class="line"></span><br><span class="line">  return out;</span><br><span class="line">&apos;)</span><br><span class="line"></span><br><span class="line">tabulate3 &lt;- function(bin, nbins) &#123;</span><br><span class="line">  bin &lt;- as.integer(bin)</span><br><span class="line">  if (length(nbins) != 1 || nbins &lt;= 0 || is.na(nbins)) &#123;</span><br><span class="line">    stop(&quot;nbins must be a positive integer&quot;, call. = FALSE)</span><br><span class="line">  &#125;</span><br><span class="line">  tabulate_(bin, nbins)</span><br><span class="line">&#125;</span><br><span class="line">tabulate3(c(1, 1, 1, 2, 2), 3)</span><br></pre></td></tr></table></figure>
</div></article><div class="tags"></div><div class="paginator"><a id="prev" href="/2016/08/07/R-data-analysis/" data-title="R data analysis" class="prev"><i class="iconfont icon-left"></i><span>Prev</span></a><a id="next" href="/2016/08/06/r-ninjia-5/" data-title="è°¢çè¾-five" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div id="disqus_thread"></div></section><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://yoursite.com/2016/08/06/R-advanced-english/';
    this.page.identifier = '2016/08/06/R-advanced-english/';
    this.page.title = 'R advanced(english edition)';
};
(function() {
var d = document, s = d.createElement('script');

s.src = '//Your disqus ID.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script></section><footer><div class="social"><a href="mailto:xiangpan2011@163.com" title="email" class="iconfont icon-email"></a><a href="/atom.xml" title="rss" class="iconfont icon-rss"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Xiang</span></p></div><div id="back2top"><i class="iconfont icon-up"></i></div></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>